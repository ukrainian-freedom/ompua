---
заголовок: Посібник з розробки плагінів
description: Керівництво по розробці плагінів
---

## Вступ

Я вирішив створити цю тему, щоб відповісти на питання, які часто задають про розробку плагінів. Я не є експертом з C/++ або SDK плагінів, я просто ділюся тим, що дізнався за час розробки плагінів. Сподіваюся, коли ця тема буде завершена, вона стане більш груповим проєктом з іншими користувачами, які надаватимуть інформацію, яку я міг не знати або забути включити. Це досить велика тема, яку я намагатимуся висвітлити, тому мені знадобиться допомога.

## Це не довідковий форум з C/++

Здається, люди дуже збентежені, коли справа доходить до цього допису. Я бачив багато людей, які ставлять цілком слушні запитання щодо SDK плагіна, які закінчуються кількома цитатами «Це не довідковий форум з C/++!». Те, що від когось очікується знання мов, **не** означає, що їм заборонено задавати питання про сам SDK! Є різниця між питанням про те, що таке вказівник, і питанням про те, як створювати зворотні виклики!

З огляду на це, є чудові сайти та форуми, присвячені навчанню та відповідям на запитання про C/++. Ось декілька з них, якими я користувався:

На цих сайтах є чудові навчальні посібники, за якими можна вчитися:

cprogramming.com

cplusplus.com

learncpp.com

Якщо ви застрягли на проблемі з C/++, ви можете скористатися одним з цих форумів, щоб попросити про допомогу:

dreamincode.net

stackoverflow.com

## FAQ

### Швидкі запитання

**Питання:** Як створюються плагіни?

- **Відповідь:** Плагіни створюються на C/++ за допомогою SDK плагінів. Цей FAQ припускає, що ви вже знаєте C/++, і надасть деяку інформацію про SDK пізніше в статті.

**Запитання:** Чи можна створити плагін на іншій мові програмування, ніж C/++?

- **Відповідь:** Теоретично це можливо. Були спроби перенесення SDK плагіна SA-MP на мову програмування D, яка підтримує прикладний двійковий інтерфейс C. Хоча я ніколи не бачив повністю робочого плагіна, написаного на D, цей приклад проливає світло на можливість написання плагінів на мовах, що підтримують C/++. Також говорили про можливість прив'язок, але я ще не бачив жодних підтверджень цьому.

**Питання:** Як зробити мій плагін багатоплатформним (доступним для linux та windows)?

- Відповідь: Linux та Windows - це дві різні операційні системи, які мають свої власні API та реалізації. Щоб ваш код працював на обох платформах, вам потрібно використовувати незалежний від платформи код або своєрідний фреймворк, який обробляє все, що пов'язано з платформами, ЗА вас. Після того, як ви переконалися, що ваш код не залежить від жодного API, вам просто потрібно скомпілювати код у потрібному вам середовищі (знову ж таки, цей посібник передбачає, що ви знаєте, як це зробити).

**Питання:** Чи може мій плагін використовувати хакерство пам'яті?

- Відповідь: Чесно кажучи, це свого роду сіра зона. Використання злому пам'яті для під'єднання зворотних викликів або виклику функцій здається цілком прийнятним. Все, що модифікує пам'ять сервера, здається, знаходиться за межами дозволеного (див. тут). Якщо ви плануєте створити плагін, який має використовувати злом пам'яті для чогось іншого, крім під'єднання зворотного виклику або виклику функцій, запитайте дозволу заздалегідь і отримайте схвалення перед публікацією; це, чесно кажучи, найкращий спосіб з'ясувати, чи можна це зробити!

**Питання:** Чи можна створити плагін, який **\_\_\_\_\_\_\_\_** ?

- **Відповідь:** У більшості випадків будь-яку ідею цілком можливо реалізувати. Для цього може знадобитися окрема програма, яка буде взаємодіяти з плагіном, але це цілком можливо. Такі питання не повинні **не повинні** публікуватися. Ви почули відповідь, тепер рухайтеся далі! Це не розділ запитів на плагіни. Сподіваємося, що настане день, коли буде достатньо розробників плагінів, щоб створити розділ або окрему тему для запитів (цей посібник призначений для ознайомлення і допомоги новим розробникам плагінів, тож будемо сподіватися).

**Питання:** Яку IDE/компілятор слід використовувати для **\_\_\_\_\_\_\_\_** ?

- **Відповідь:** Це повністю залежить від вас! Особисто я використовуватиму VC++ 2010 express як середовище розробки та компілятор для Windows, а також планую використовувати g++ як компілятор для Linux. Просто пограйтеся з різними варіантами і подивіться, який з них вам подобається найбільше!

**Питання:** Що таке файл визначення модуля (.def)?

- **Відповідь:** Файл визначення модуля - це спеціальний файл в IDE Visual Studio, який надає компонувальнику інформацію про програму, що компонується. Коли справа доходить до написання плагінів для SA-MP, ми використовуємо лише інструкцію «EXPORTS», яка надає інформацію про наші експортовані функції. Ми розглянемо цей оператор пізніше у статті.

**Питання:** Коли я випускаю плагін, чи повинен він мати вихідний код разом з ним?

- **Відповідь:** Якщо ви публікуєте щось на цьому форумі, воно **завжди** повинно мати вихідний код. Плагіни не є винятком (якщо тільки розробник не схвалив розміщення плагіна без вихідного коду - можливо, для захисту від обману?).

## Початок роботи

Ви були б шоковані, як часто мене запитують: «Як почати розробку плагінів?». Я вирішив додати цей розділ, щоб відповісти на це питання! Просто тому, що ви знаєте мову, ще не означає, що ви знаєте, як поводитися в IDE; я думаю, що це особливо вірно, коли мова йде про VC++ 2010. Візуальна студія може бути дуже страшним місцем для нових користувачів. Я не думаю, що буде справедливо просто дати вам SDK плагінів, не показавши вам, як тут все влаштовано! Робота зі сторінками властивостей та компонувальником може легко відлякати людей, тому я проведу вас через це.

**Примітка:** Якщо ви вирішили використовувати іншу IDE/компілятор, орієнтований на Windows, вам не пощастило! Схоже, що єдиним способом успішного експорту функцій є використання файлу визначення модуля (.DEF). Я спробував включити у цю статтю альтернативний метод за допомогою \_\_declspec(dllexport), але він просто не спрацював через правила виклику \_\_stdcall, які спотворюють імена експортованих функцій (див.: [Тут](https://pastebin.com/y3xkVY70)).

Ось список програм, які вам знадобляться для цього розділу:

**Visual C++ 2010 express:** [Безкоштовне завантаження](https://visualstudio.microsoft.com/vs/express/)

**Plugin SDK (Plain):** [Завантажити](https://github.com/Zeex/samp-plugin-sdk)

- Перше, що ми хочемо зробити, це створити новий проєкт. Для цього виберіть файл->новий->проєкт.

- Після створення нового проєкту програма запитає вас про тип проєкту, який ви створюєте. Виберіть пункт проєкт Win32, введіть назву проєкту і натисніть кнопку OK для продовження.

- Після того, як параметри проєкту буде визначено, має з'явитися таке діалогове вікно. Натисніть кнопку Далі, щоб продовжити.
- Після натискання кнопки продовжити ви побачите це діалогове вікно, яке запитає про тип і параметри вашої програми. Для типу виберіть DLL (бібліотека динамічних посилань), а для налаштувань - порожній проєкт. Закінчивши, натисніть кнопку «Готово» внизу.

- Наступне, що ми хочемо зробити, це перейти до нашого провідника рішень. Зазвичай провідник рішень знаходиться у лівій частині IDE. Якщо ви випадково вимкнули його, ви можете увімкнути його знову, натиснувши комбінацію клавіш CTRL+ALT+L або вибравши перегляд->інші вікна->оглядач рішень. Знайшовши провідник рішень, клацніть правою кнопкою миші на назві проєкту (у нашому прикладі це «Test») і виберіть властивості.

- Після того, як ви побачите сторінки властивостей, перейдіть до пункту Властивості конфігурації->Зв'язувач->Введення з лівого боку. Після цього вам потрібно додати файл визначення модуля. Ви можете назвати цей файл як завгодно, якщо він має розширення «.def» у кінці; зазвичай люди називають файли def на честь свого проєкту. Після того, як ви назвали файл визначення, натисніть кнопку OK.

- Тепер все, що нам потрібно зробити, це додати наші файли (це стосується і нашого файлу визначення!). Щоб додати файл до проєкту, знову перейдіть до провідника рішень, клацніть правою кнопкою миші на назві проєкту, виберіть пункт «Додати», а потім виберіть «Новий елемент». У цьому прикладі ми додамо наш файл визначення. Оскільки не існує опції для файлів визначення, просто виберіть вихідний файл (.cpp) і введіть ім'я файлу визначення модуля, який ви вирішили (Примітка: Переконайтеся, що ви включили розширення «.def», інакше буде додано розширення «.cpp»!). Після цього додайте вихідний файл проєкту таким же чином (за винятком того, що не додавайте розширення). Більшість людей використовують назву «Main» для головного вихідного файлу.

- Перш ніж ми зможемо почати додавати щось до наших двох наразі порожніх файлів, ми повинні додати SDK до проєкту. Якщо ви цього ще не зробили, завантажте SDK за посиланням, яке було надано на початку цього розділу. Після завантаження розпакуйте теку SDK до каталогу вашого поточного проєкту. Зауваження Ця частина є необов'язковою: особисто мені подобається створювати фільтри для впорядкування всіх наших файлів і коду. Фільтр - це організаційний інструмент у Visual Studio, який створює папки у вашому проєкті, але не створює відповідні папки у Windows (рекомендується створювати відповідні папки у вікнах). Щоб створити фільтр, клацніть правою кнопкою миші ваш проєкт у провіднику рішень->додати->Новий фільтр і виберіть ім'я для фільтра (у цьому випадку назвіть його SDK).

- Наступним кроком буде додавання всіх файлів SDK до нашого поточного проєкту. Щоб додати наявні файли до проєкту, просто клацніть правою кнопкою миші на теці або проєкті, до якого ви бажаєте їх додати, і виберіть пункт меню Додати -> Наявний елемент. Вам потрібно буде додати все, що знаходиться у теці SDK у каталозі вашого проєкту (Примітка: Ви можете вибрати декілька файлів, утримуючи клавішу Ctrl під час натискання на файли, які потрібно додати). Для узгодженості папок ми створимо ще один фільтр всередині фільтра SDK і назвемо його amx. Звичайно, ви захочете додати весь вміст теки SDK\amx\ до фільтра amx.

Тепер настав час скомпілювати плагін! Якщо ви правильно виконали інструкції, у вас повинні відкритися файл визначення модуля і вихідний файл; якщо ні, поверніться на кілька кроків назад і уважно виконайте інструкції. Скопіюйте та вставте наступну інформацію у відповідні файли. Не хвилюйтеся, якщо вам щось незрозуміло, ми розглянемо це у наступному розділі.

### Вихідний файл (\*.cpp)

```cpp
#include «SDK\amx\amx.h»
#include «SDK\plugincommon.h»


typedef void (*logprintf_t)(const char* format, ...);
logprintf_t logprintf;
extern void *pAMXFunctions;


cell AMX_NATIVE_CALL HelloWorld(AMX* amx, cell* params)
{
    logprintf(«Це було виведено з тестового плагіна! Ура!»);
    return 1;
}

PLUGIN_EXPORT unsigned int PLUGIN_CALL Supports()
{
    return SUPPORTS_VERSION | SUPPORTS_AMX_NATIVES;
}

PLUGIN_EXPORT bool PLUGIN_CALL Load(void **ppData)
{
    pAMXFunctions = ppData[PLUGIN_DATA_AMX_EXPORTS];
    logprintf = (logprintf_t) ppData[PLUGIN_DATA_LOGPRINTF];

    logprintf(« * Завантажено тестовий плагін.»);
    return true;
}

PLUGIN_EXPORT void PLUGIN_CALL Unload()
{
    logprintf(« * Тестовий плагін було вивантажено.»);
}

AMX_NATIVE_INFO PluginNatives[] =
{
    {«HelloWorld», HelloWorld},
    {0, 0}
};

PLUGIN_EXPORT int PLUGIN_CALL AmxLoad( AMX *amx )
{
    return amx_Register(amx, PluginNatives, -1);
}


PLUGIN_EXPORT int PLUGIN_CALL AmxUnload( AMX *amx )
{
    return AMX_ERR_NONE;
}
```

### Файл визначення модуля (\*.def)

```cpp
ЕКСПОРТИ
      Підтримка
      Завантажити
      Вивантажити
      AmxLoad
      AmxUnload
```

## Вивчення коду

У цьому розділі ми розглянемо деякі визначення, структури та функції, які пропонує SDK плагіна SA-MP. Перед тим, як продовжити, ви повинні добре розуміти мову C/++, оскільки я пояснюватиму інформацію, пов'язану з SDK, лише після того, як ми дійдемо до закодованих сегментів коду. З цього моменту я не буду тримати вас за руку!

### Файл визначення модуля

Перш ніж ми подивимося на код, ми перевіримо файл визначення модуля, який ми створили в попередньому розділі. Перш за все, що таке файл визначення модуля? Ми знаємо, що це ексклюзивна функція візуальної студії, але що саме вона робить? Все просто! Файл визначення модуля надає інформацію компонувальнику про код, який компонується. Існує багато правил і операторів, які можна використовувати в цих файлах, але ми поговоримо лише про один з них - оператор EXPORTS.

#### Що таке «**ЕКСПОРТ**»

Експорт - це інструкція, яка дозволяє нам... ну, експортувати дані в наш додаток! Чому ми це робимо? Тому що ми повинні, ось так просто. Функції, які ми експортуємо, є точками входу в наш файл DLL. Додатки можуть торкатися лише тих функцій у нашій DLL, які ми експортуємо; якщо ми не експортуємо їх, вони залишаються приватними для файлу DLL. Ми ж не хочемо цього зараз, чи не так? Ні. Тому ми експортуємо все, до чого програма матиме прямий доступ.

#### Експортовані функції

Наразі існує 6 функцій, які потрібно експортувати. Ми використовуємо 5 з них всередині нашого проєкту, який ми створюємо. Не хвилюйтеся про визначення `PLUGIN_EXPORT` і `PLUGIN_CALL`, які ви бачите в оголошеннях функцій. Ми розглянемо їх разом з деякими іншими важливими визначеннями (позначеними зеленим кольором) пізніше у статті.

| Функції | Опис
| -------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
**Supports()** | Ця функція повідомляє серверу, які можливості матиме наш плагін, виходячи з того, що вона повертає. Зазвичай ми використовуємо лише 3 прапори підтримки у плагінах: **SUPPORTS_VERSION**, **SUPPORTS_AMX_NATIVES** і **SUPPORTS_PROCESS_TICK**.                                                                                                                                                                                                                                                                         |
| **Load(void\*\*)** | Функція Load досить проста. Вона викликається при завантаженні плагіна і отримує масив адрес, які плагін буде використовувати для роботи. Зазвичай ми використовуємо два індекси: **PLUGIN_DATA_AMX_EXPORTS** та **PLUGIN_DATA_LOGPRINTF**.                                                                                                                                                                                                                                      |
| **Unload()** | Unload викликається, коли плагін вивантажується (сервер вимикається).                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| **AmxLoad(AMX\*)** | Викликається, коли на сервер завантажується новий екземпляр AMX. Він буде викликаний для кожного скрипту/режиму гри! Тому не варто зберігати один екземпляр AMX для всього плагіна, натомість використовуйте чергу/список/вектор. У цій функції ми також реєструємо наші власні нативні функції, які ми хочемо надати PAWN.                                                                                                                                                           |
**AmxUnload(AMX\*)** | Ця функція викликається щоразу, коли вивантажується екземпляр AMX. Якщо ви зберігаєте екземпляри AMX, переконайтеся, що ви їх видалили. Інакше ви матимете екземпляри для неіснуючих ігрових режимів/фільтрскриптів.                                                                                                                                                                                                                                                                                                           |
| **ProcessTick()** | ProcessTick - це функція, яка викликається на кожній ітерації циклу сервера. Люди зазвичай використовують цю функцію як метод керування часом, відстежуючи кількість пройдених тиків. Вважається, що сервер SA-MP має час сну 5 мс, тому, якщо пройшло 50 тиків, ви маєте уявлення про час, що минув (5 \* 50 = 250 мс). **Примітка:** Усім, хто використовує потоки у своїх плагінах і потребує взаємодії з PAWN, слід використовувати цю функцію, щоб переконатися, що PAWN не зайнятий виконанням іншого завдання! |

### Визначення та структури

Тепер настає найцікавіша частина, ми подивимось на код! Ви, мабуть, одразу помітите, що ми використовуємо багато визначень та структур у нашому маленькому прикладі з попереднього розділу. Якщо ви ніколи раніше не розробляли SA-MP плагіни, вони можуть здатися вам дуже заплутаними і навіть лякаючими. У цьому розділі ми проллємо трохи світла на ці визначення та структури.

| Визначення/структури | Опис
| --------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| «Комірка» - це типізоване визначення, яке існує лише для зручності перенесення. PAWN підтримує 16-, 32- та 64-розрядні цілі числа. Типізований тип «комірка» завжди матиме правильний розмір, у той час як «int» може не відповідати. Зазвичай у плагінах SA-MP цей тип завжди буде 32-бітним цілим числом. **Примітка:** Існує також типізація «ucell» для цілих беззнакових чисел, але вона майже не використовується.                                                 |
**AMX_NATIVE_CALL** | Цей параметр визначає угоду про виклик, яку використовуватимуть наші рідні функції. Наразі вона не визначена, тому буде використано значення за замовчуванням.                                                                                                                                                                                                                                                                              |
| **AMX** | Назва цієї структури має бути досить зрозумілою, це екземпляр AMX. Ця структура містить багато інформації про сегменти даних, а також багато іншої інформації, пов'язаної з amx. Ця структура має бути присутня у всіх оголошеннях нативних функцій разом із вказівником комірки на передані параметри; без цієї інформації ми не знаємо, який скрипт викликає нашу нативну функцію, а також не знаємо, що було передано. |
| **PLUGIN_EXPORT** | Визначається як «PLUGIN_EXTERN_C».                                                                                                                                                                                                                                                                                                                                                                                   |
| **PLUGIN_EXTERN_C** | Якщо використовується компілятор C++, це визначено як «extern “C”». Це зроблено для сумісності з C. C++ пропонує такі речі, як перевантаження функцій, тому додаткова інформація, така як кількість/розмір аргументів, зберігається разом з іменем функції, це називається «спотворенням імені». Коли використовується це визначення, воно вказує C++ використовувати зв'язування у стилі C і таким чином уникає спотворення імен у C++.                                          |
| **PLUGIN_CALL** | Цей визначник вказує C++, яку угоду про виклик використовувати для наших експортованих функцій. Якщо ви використовуєте компілятор, орієнтований на роботу з вікнами, він визначається як \_\_stdcall. В іншому випадку він не визначений, і використовується угода за замовчуванням.                                                                                                                                                                                         |
| **ВЕРСІЯ_ПІДТРИМКИ** | Цю ознаку слід використовувати у бітовій масці, яку повертає наша функція «Supports()». Цей прапорець використовується для перевірки сумісності з сервером.                                                                                                                                                                                                                                                                    |
| **SUPPORTS_AMX_NATIVES** | Це ще одна змінна, яка буде використовуватися функцією «Supports()». Будь-який плагін, який використовує функції AMX, повинен використовувати цей прапор! Без цього прапора ви отримаєте помилку 19 під час виконання через те, що ваші нативні функції не зареєстровані на сервері (amx_Register).
| **SUPPORTS_PROCESS_TICK** | Останній прапорець для нашої функції «Supports()». Якщо ви збираєтеся використовувати функцію «ProcessTick()», ви повинні додати його до бітової маски функції «Supports()», що повертається.                                                                                                                                                                                                                                           |
| **PLUGIN_DATA_AMX_EXPORTS** | Використовується як індекс багатовимірного масиву, який передається при завантаженні. Цей конкретний індекс містить таблицю функцій AMX. Усі плагіни повинні використовувати цей індекс для присвоєння адреси таблиці функцій pAMXFunctions.                                                                                                                                                                                      |
| **PLUGIN_DATA_LOGPRINTF** | Ще один індекс, який слід використовувати з багатовимірним масивом, що передається при завантаженні. Цей індекс містить адресу функції logprintf, яка друкує інформацію і зберігає її у файлі журналу сервера. Якщо ваш плагін використовує цю функцію, ви повинні використовувати цей індекс для присвоєння адреси вказівнику функції logprintf.                                                                  |
| **AMX_NATIVE_INFO** | Ця структура використовується разом з amx_Register. Вона містить рядок, який містить ім'я вашої нової нативної системи та вказівник на її адресу.                                                                                                                                                                                                                                                                            |

Є ще декілька важливих визначень, які стосуються помилок функцій AMX, але вони вже задокументовані у заголовку amx. Тому замість того, щоб вигадувати велосипед, я просто опублікую зчислення з усіма кодами помилок та відповідними коментарями. **Примітка:** Кожна функція amx, за винятком amx_NativeInfo, повертає один з цих кодів помилок, якщо виникла проблема.

```cpp
зчислення
{
  AMX_ERR_NONE,
  /* зарезервувати перші 15 кодів помилок для кодів виходу з абстрактної машини */
  AMX_ERR_EXIT, /* примусовий вихід */
  AMX_ERR_ASSERT, /* не вдалося виконати твердження */
  AMX_ERR_STACKERR, /* зіткнення стеку/купки */
  AMX_ERR_BOUNDS, /* індекс вийшов за межі */
  AMX_ERR_MEMACCESS, /* некоректний доступ до пам'яті */
  AMX_ERR_INVINSTR, /* некоректна інструкція */
  AMX_ERR_STACKLOW, /* переповнення стеку */
  AMX_ERR_HEAPLOW, /* переповнення динамічної пам'яті */
  AMX_ERR_CALLBACK, /* немає зворотного виклику, або невірний зворотний виклик */
  AMX_ERR_NATIVE, /* не вдалося виконати рідну функцію */
  AMX_ERR_DIVIDE, /* ділення на нуль */
  AMX_ERR_SLEEP, /* перейти у сплячий режим - код можна перезапустити */
  AMX_ERR_INVSTATE, /* неприпустимий стан для цього доступу */

  AMX_ERR_MEMORY = 16, /* за межами пам'яті */
  AMX_ERR_FORMAT, /* неприпустимий формат файлу */
  AMX_ERR_VERSION, /* файл для більш нової версії AMX */
  AMX_ERR_NOTFOUND, /* функцію не знайдено */
  AMX_ERR_INDEX, /* невірний параметр індексу (погана точка входу) */
  AMX_ERR_DEBUG, /* не вдається запустити відлагоджувач */
  AMX_ERR_INIT, /* AMX не ініціалізовано (або двічі ініціалізовано) */
  AMX_ERR_USERDATA, /* не вдається встановити поле даних користувача (таблиця переповнена) */
  AMX_ERR_INIT_JIT, /* не вдається ініціалізувати JIT*/.
  AMX_ERR_PARAMS, /* помилка параметрів */
  AMX_ERR_DOMAIN, /* помилка домену, результат виразу не поміщається в діапазон */
  AMX_ERR_GENERAL, /* загальна помилка (невідома або неспецифічна помилка) */
};
```

## Функції amx

Функції amx дуже добре задокументовано у посібнику для реалізаторів PAWN, який можна знайти тут. Замість того, щоб вигадувати велосипед і пояснювати всі функції своїми словами, я просто скопіюю їх сюди з посібника для реалізаторів і зроблю їх трохи більш презентабельними; я вважаю, що це зробить вміст набагато доступнішим. З огляду на це, цей розділ буде здебільшого посиланням на наступний розділ, який зосереджується на тому, чого бракує у посібнику для реалізаторів, а саме на прикладах коду. Примітка: Я розглядатиму лише ті функції, які, на мою думку, є життєво важливими для плагінів (поки що). Все інше можна знайти у посібнику для реалізаторів, просто переконайтеся, що ви використовуєте версію, на яку я дав посилання у цьому розділі!

### Ключ

\+ => Не доступний

## amx_Allot

\- Зарезервувати місце у купі в абстрактній машині

### Синтаксис

```cpp
int amx_Allot(AMX *amx, int cells, cell *amx_addr, cell **phys_addr);
```

| Параметр | Опис |
| ------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Абстрактна машина.                                                                                                                                                    |
**cells** | Кількість зарезервованих комірок.                                                                                                                                          |
**amx_addr** | Адреса виділеної комірки для доступу програми-пішака (яка працює на абстрактній машині). phys_addr Адреса комірки для доступу програм на мові C/C++. |

**Примітки:** У попередніх версіях pawn масиви та рядки потрібно було передавати скрипту після явного виділення пам'яті для них у стеку amx. У поточному випуску цю функціональність значною мірою замінено функціями amx_PushArray та amx_PushString. Функція-пішак може отримати доступ до пам'яті лише всередині своєї абстрактної машини. Якщо у пішакову функцію потрібно передати параметр «за посиланням», то в amx_Exec потрібно передати адресу цього параметра. Крім того, ця адреса також повинна знаходитись у діапазоні адрес абстрактної машини. Додаткова складність полягає в тому, що абстрактна машина використовує адреси, які відносяться до секції даних абстрактної машини, а хост-програма використовує адресу відносно оточення, яке надає їй операційна система.

amx_Allot виділяє комірки пам'яті всередині абстрактної машини і повертає дві адреси. Параметр amx_addr - це адреса змінної відносно «секції даних» абстрактної машини; саме це значення ви повинні передати amx_Exec (через amx_Push). Параметр phys_addr містить адресу відносно адресного простору хост-програми. Таким чином, C/C++ програма може використати цю адресу і записати у виділену пам'ять. Після повернення amx_Exec ви можете оглянути блок пам'яті (можливо, в нього записалася функція pawn, викликана amx_Exec) і, нарешті, звільнити його викликом amx_Release.

**Дивіться також:** [amx_Exec](#amx_exec), [amx_PushArray](#amx_pusharray), [amx_PushString](#amx_pushstring), [amx_Release](#amx_release)

## amx_ctof

\- Привести «комірку» до «числа з плаваючою комою»

### Синтаксис

```cpp
[float] amx_ctof([комірка] c);
```

| Параметр | Опис
| --------- | ---------------------------------------------- |
| Значення для приведення з типу «комірка» до типу «float». |

**Повертає:** Той самий бітовий шаблон, але тепер як тип з плаваючою комою.

**Примітки:** Цей макрос приводить тип «комірка» до типу «з плаваючою комою» без зміни бітової схеми. Звичайне приведення типів у C/C++ змінює представлення виразу у пам'яті так, щоб його числове значення у форматі IEEE 754 було максимально наближеним до початкового цілочисельного значення. Синтаксичний аналізатор та абстрактна машина зберігають значення з плаваючою комою у комірці - при отриманні значення з плаваючою комою з комірки не потрібно змінювати бітову структуру.

**Дивіться також:** [amx_ftoc](#amx_ftoc)

## amx_Exec

\- Виконати код

### Синтаксис

```cpp
  int amx_Exec(AMX *amx, long *retval, int index);
```

| Параметр | Опис
| ---------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
**amx** | Абстрактна машина, з якої можна викликати функцію.                                                                                                                                                                                           |
| **retval** | Міститиме значення, що повертається викликаною функцією після повернення. Цей параметр може бути NULL, якщо вас не цікавить значення, що повертається.                                                                                                        |
| **index** | Індекс у «таблиці загальнодоступних функцій»; вказує на функцію, яку слід виконати. Дивіться інформацію в amx_FindPublic. Використовуйте AMX_EXEC_MAIN для початку виконання головної функції, а AMX_EXEC_CONT для продовження виконання зі стану «сну». |

**Примітки:** Ця функція запускає скрипт, починаючи з вказаної функції. Вона викликає функцію зворотного виклику для будь-якого виклику власної функції, який виконує код в amx. amx_Exec припускає, що всі власні функції правильно ініціалізовані за допомогою amx_Register.

**Дивіться також:** [amx_FindPublic](#amx_findpublic), [amx_Register](#amx_register)

## amx_FindPublic

\- Повернути індекс загальнодоступної функції

### Синтаксис

```cpp
int amx_FindPublic(AMX *amx, char *funcname, int *index);
```

| Параметр | Опис
| ------------ | ---------------------------------------------------------------------------- |
| Абстрактна машина.                                                        |
**funcname** | Ім'я публічної функції для пошуку.                                     |
**index** | При поверненні цей параметр містить індекс запитуваної загальнодоступної функції. |

**Дивіться також:** [amx_Exec](#amx_exec), amx_FindNative+, amx_FindPubVar+, amx_GetPublic+, amx_NumPublics+

## amx_ftoc

\- Приведення «float» до «cell»

### Синтаксис

```cpp
[cell] amx_ftoc([float] f);
```

| Параметр | Опис
| --------- | ---------------------------------------------- |
**f** | Значення для приведення з типу «float» до типу «комірка». |

**Повертає:** Той самий бітовий шаблон, але тепер як тип «комірка».

**Примітки:** Цей макрос приводить тип «float» до типу «комірка» без зміни бітової схеми. Звичайне приведення типів у C/C++ змінює представлення виразу у пам'яті так, що його числове значення у цілочисельному форматі є інтегральним (усіченим) значенням вихідного раціонального значення. Синтаксичний аналізатор та абстрактна машина зберігають значення з плаваючою комою у комірці - при зберіганні значення з плаваючою комою у комірці розрядність не повинна змінюватися.

**Дивіться також:** [amx_ctof](#amx_ctof)

## amx_GetAddr

\- Розв'язати AMX-адресу

### Синтаксис

```cpp
int amx_GetAddr(AMX *amx,комірка amx_addr,комірка **phys_addr);
```

| Параметр | Опис
| ------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Абстрактна машина.                                                                                                                                                                          |
**amx_addr** | Адреса відносно абстрактної машини.                                                                                                                                                  |
| **phys_addr** | Вказівник на змінну, яка міститиме адресу пам'яті вказаної комірки. Якщо параметр amx_addr не є дійсною адресою всередині абстрактної машини, phys_addr буде встановлено у NULL.

**Примітки:** Ця функція повертає адресу пам'яті для адреси в абстрактній машині. Цю функцію зазвичай використовують у модулях розширення, оскільки вона дозволяє отримати доступ до змінних всередині абстрактної машини.

## amx_GetString

\- Отримати рядок з абстрактної машини

### Синтаксис

```cpp
int amx_GetString(char *dest, cell *source, int use_wchar, size_t size);
```

| Параметр | Опис
| ------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
**dest** | Вказівник на символьний масив достатнього розміру, щоб вмістити перетворений вихідний рядок.                                                                                         |
| **source** | Вказівник на вихідний рядок. Використовуйте amx_GetAddr для перетворення рядкової адреси в amx на фізичну адресу.                                                                 |
| **use_wchar** | Ненульове значення інтерпретує аргумент dest як вказівник на «широкі символи» - тобто wchar_t, незалежно від його типу char. Це дозволяє функції зберігати рядки у форматі Unicode. |
| **size** | Максимальна кількість символів для зберігання у dest, включаючи завершальний нульовий байт. Якщо рядок у джерелі довший, то рядок у dest буде урізано.           |

**Примітки:** Ця функція перетворює як запаковані, так і розпаковані рядки з формату «pawn» у формат «C». При отриманні розпакованого рядка з параметром use_wchar, встановленим у нуль, функція може усікати символи з широких символів до 8-бітних ASCII/ANSI.

**Дивіться також:** [amx_SetString](#amx_setstring)

## amx_Push

\- Передати числовий аргумент «за значенням»

### Синтаксис

```cpp
int amx_Push(AMX *amx, значення комірки);
```

| Параметр | Опис
| --------- | ----------------------------------------- |
| Абстрактна машина.                     |
| Значення, що передається до публічної функції. |

**Примітки:** Будь-які параметри до загальнодоступної функції мають бути передані у функцію перед викликом amx_Exec. Якщо загальнодоступна функція має декілька аргументів, аргументи слід передавати у зворотному порядку.

**Дивіться також:** [amx_Exec](#amx_exec), [amx_PushArray](#amx_pusharray), [amx_PushString](#amx_pushstring)

## amx_PushArray

\- Передати аргумент або масив «за посиланням»

### Синтаксис

```cpp
int amx_PushArray(AMX *amx, cell *amx_addr, cell **phys_addr, const cell array[], int numcells);
```

| Параметр | Опис
| ------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **amx** | Абстрактна машина.                                                                                                                                                    |
| **amx_addr** | Адреса виділеної комірки, за якою програма-пішак (яка працює в абстрактній машині) може отримати доступ до неї, необхідний для звільнення блоку пам'яті. Цей параметр може бути NULL. |
| **phys_addr** | Адреса комірки для доступу програм на мові C/C++. Цей параметр може бути NULL.                                                                                        |
| **array** | Масив значень для передачі у загальнодоступну функцію. Окрема комірка, яку потрібно передати за посиланням, розглядається як масив з однієї комірки.                                   |
| **numcells** | Кількість елементів у масиві.                                                                                                                                     |

**Примітки:** Будь-які параметри до загальнодоступної функції мають бути передані у функцію перед викликом amx_Exec. Якщо загальнодоступна функція має декілька аргументів, аргументи повинні бути передані в зворотному порядку. Функція виділяє пам'ять для масиву всередині «купи» абстрактної машини. Ця пам'ять повинна бути звільнена за допомогою amx_Release. Дивіться функцію amx_Allot для отримання детальної інформації про параметри amx_addr та phys_addr.

**Дивіться також:** [amx_Exec](#amx_exec), [amx_Push](#amx_push), [amx_PushString](#amx_pushstring), [amx_Release](#amx_release)

## amx_PushString

\- Передати аргумент у вигляді рядка

### Синтаксис

```cpp
int amx PushString(AMX *amx, комірка *amx_addr, комірка **phys_addr, const char *string, int pack, int use_wchar);
```

| Параметр | Опис
| ------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **amx** | Абстрактна машина.                                                                                                                                                            |
| **amx_addr** | Адреса виділеної комірки, за якою програма-пішак (яка працює в абстрактній машині) може отримати доступ до неї, необхідний для звільнення блоку пам'яті. Цей параметр може бути NULL.         |
| **phys_addr** | Адреса комірки для доступу програм на мові C/C++. Цей параметр може бути NULL.                                                                                                |
| **string** | Рядок для передачі у загальнодоступну функцію.                                                                                                                                       |
**pack** | Ненульове значення для перетворення вихідного рядка в упакований рядок в абстрактній машині, нульове - для перетворення вихідного рядка в рядок комірок.                                            |
| **use_wchar** | Ненульове значення інтерпретує рядковий аргумент як вказівник на «широкі символи», тобто wchar_t, незалежно від його типу char. Це дозволяє функції приймати рядки у кодуванні Unicode. |

**Примітки:** Будь-які параметри до загальнодоступної функції мають бути передані у функцію перед викликом amx_Exec. Якщо загальнодоступна функція має декілька аргументів, аргументи повинні бути передані у зворотному порядку. Функція виділяє пам'ять для масиву всередині «купи» абстрактної машини. Ця пам'ять повинна бути звільнена за допомогою amx_Release. Дивіться функцію amx_Allot для отримання детальної інформації про параметри amx_addr та phys_addr. Коли ви передаєте рядок Unicode і запитуєте упакований формат в абстрактній машині (тобто і pack, і use_wchar мають значення true), символи усікаються до 8 біт.

**Дивіться також:** [amx_Exec](#amx_exec), [amx_Push](#amx_push), [amx_PushArray](#amx_pusharray), [amx_Release](#amx_release), [amx_SetString](#amx_setstring)

## amx_Register

\- Зробити нативні функції відомими

### Синтаксис

```cpp
int amx Register(AMX *amx, AMX NATIVE INFO *list, int number);
```

| Параметр | Опис
| ---------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Абстрактна машина.                                                                                                                                                                              |
| **list** | Масив зі структурами, де кожна структура містить вказівник на ім'я власної функції та вказівник на функцію. Список необов'язково завершується структурою, що містить два NULL-покажчики. |
| **number** | Кількість структур у масиві list, або -1, якщо список закінчується структурою, що містить два вказівники NULL.                                                                                      |

**Примітки:** У разі успіху ця функція повертає 0 (AMX_ERR_NONE). Якщо ця функція повертає код помилки AMX_ERR_NOTFOUND, це означає, що у наданому списку не знайдено одну або декілька власних функцій, які використовуються ломбардною програмою. Ви можете повторно викликати amx_Register для реєстрації додаткових списків функцій.

Щоб перевірити, чи всі нативні функції, що використовуються у скомпільованому скрипті, було зареєстровано, викличте amx_Register зі списком параметрів, встановленим у NULL. Цей виклик не зареєструє жодних нових власних функцій, але все одно поверне AMX_ERR_NOTFOUND, якщо будь-яку власну функцію не буде зареєстровано.

**Дивіться також:** amx_NativeInfo+

## amx_Release

\- Звільнити місце у купі в абстрактній машині

### Синтаксис

```cpp
int amx Release(AMX *amx,комірка amx_addr);
```

| Параметр | Опис
| ------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Абстрактна машина.                                                                                                                                                     |
| **amx_addr** | Адреса виділеної комірки, як її бачить програма-пішак (яка працює в абстрактній машині). Це значення повертається функціями amx_Allot, amx_PushArray та amx_PushString. |

**Примітки:** amx_Allot виділяє пам'ять у купі у порядку зростання (купа росте вгору). amx_Release звільняє всю пам'ять вище значення вхідного параметра amx_addr. Тобто, один виклик amx_Release може звільнити декілька викликів amx_Allot, якщо передати значення amx_addr першого виділення. amx_PushArray та amx_PushString використовують amx_Allot внутрішньо, тому та сама процедура застосовується і до цих функцій.

**Дивіться також:** [amx_Allot](#amx_allot), [amx_PushArray](#amx_pusharray), [amx_PushString](#amx_pushstring)

## amx_SetString

\- Зберегти рядок в абстрактній машині

### Синтаксис

```cpp
int amx SetString(cell *dest, char *source, int pack, int use_wchar, size_t size);
```

| Параметр | Опис
| ------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
**dest** | Вказівник на масив символів у amx, де зберігається перетворений рядок. Використовуйте amx_GetAddr для перетворення адреси рядка в amx у фізичну адресу.                                     |
| **source** | Вказівник на вихідний рядок.                                                                                                                                                                     |
**pack** | Ненульове значення для перетворення вихідного рядка у запакований рядок в абстрактній машині, нульове значення для перетворення вихідного рядка у рядок комірок.                                                               |
| Рядок** | Рядок для передачі у загальнодоступну функцію.                                                                                                                                                          |
| Ненульове значення інтерпретує аргумент рядка як вказівник на «широкі символи», тобто wchar_t, незалежно від його типу char. Це дозволяє функції приймати рядки у кодуванні Unicode.                    |
| **size** | Максимальна кількість комірок для зберігання у dest, включаючи завершальний нульовий байт або комірку. Якщо рядок у джерелі довший за кількість комірок у dest, він буде усічений. |

**Примітки:** Якщо ви передаєте рядок у кодуванні Unicode і запитуєте упакований формат в абстрактній машині (тобто і pack, і use_wchar мають значення true), символи буде урізано до 8 біт.

**Дивіться також:** [amx_GetString](#amx_getstring)

## amx_StrLen

\- Отримати довжину рядка у символах

### Синтаксис

```cpp
int amx_StrLen(const cell *cstring, int *length);
```

| Параметр | Опис
| ----------- | ------------------------------------------------------- |
| **cstring** | Рядок в абстрактній машині.                     |
| **length** | Цей параметр буде містити довжину рядка після повернення. |

**Примітки:** Ця функція визначає довжину рядка у символах, не враховуючи нульовий символ (або комірку). Упакований рядок займає менше комірок, ніж його кількість символів. Якщо параметр cstring дорівнює NULL, параметр length дорівнює нулю (0) і функція повертає код помилки. Для перетворення розпакованих рядків до UTF-8 може бути зручнішою функція amx_UTF8Len.

**Дивіться також:** [amx_GetAddr](#amx_getaddr), [amx_GetString](#amx_getstring), [amx_SetString](#amx_setstring), [amx_StrParam](#amx_strparam), amx_UTF8Len+

## amx_StrParam

\- Отримати рядковий параметр з абстрактної машини

### Синтаксис

```cpp
amx_StrParam([AMX*] amx, int] param, [char*] result);
```

| Параметр | Опис
| ---------- | ----------------------------------------------- |
| Абстрактна машина.                           |
| Номер параметра.                           |
| Результат - змінна, яка буде містити результат при поверненні. |

**Примітки:** Цей макрос виділяє блок пам'яті (за допомогою alloca) і копіює у цей блок рядковий параметр (у власну функцію). Приклад використання цього макросу наведено на сторінці 56.

**Дивіться також:** [amx_GetAddr](#amx_getaddr), [amx_GetString](#amx_getstring), [amx_StrLen](#amx_strlen)

## Приклади функцій amx

Намагаючись уникнути величезних текстових стін, я вирішив додати коментарі до коду, які пояснюють, що я роблю, замість того, щоб писати це в темі. Можливо, це гарна ідея, щоб вікі-стаття була відкрита як довідник під час читання прикладів.

### Реєстрація нативних користувачів

Кожна функція, яку ми надаємо PAWN, має бути зареєстрована, щоб абстрактна машина знала про її існування. Тому я вважаю, що це, мабуть, гарна ідея почати з amx_Regester! На щастя, ми вже використовували приклад реєстрації нативної функції у попередніх розділах, тому я використаю його знову і додам деякі коментарі.

```cpp
//Масив функцій, які ми хочемо зареєструвати в абстрактній машині.
AMX_NATIVE_INFO PluginNatives[] =
{
    //Тут ми вказуємо інформацію про наші нативні функції і завершуємо масив двома нульовими значеннями.
    {«HelloWorld», HelloWorld},
    {0, 0}
};

PLUGIN_EXPORT int PLUGIN_CALL AmxLoad( AMX *amx )
{
    //Тут ми реєструємо наші нативні дані на абстрактній машині. Зверніть увагу, як ми використовуємо -1. Зазвичай це має бути кількість
    //функцій, які ми реєструємо, але оскільки ми завершили масив двома нульовими значеннями, ми можемо вказати -1.
    return amx_Register(amx, PluginNatives, -1);
}
```

- ### Отримання рядка та його довжини

```cpp
//Ця функція демонструє: як отримати рядок (та його довжину) з PAWN.
//PAWN native: native PrintPawnString(const str[]);
cell AMX_NATIVE_CALL PrintPawnString(AMX* amx, cell* params)
{
    int
        len = NULL
        ret = NULL;

    cell *addr = NULL;

    //Отримуємо адресу нашого рядка param (str) і потім отримуємо його довжину
    amx_GetAddr(amx, params[1], &addr);
    amx_StrLen(addr, &len);

    //якщо довжина вхідних даних не рівна 0
    if(len)
    {
        //Ми збільшуємо len, тому що хочемо звільнити місце для завершального нульового символу при виділенні пам'яті.
        //Також, оскільки параметр розміру GetString враховує нульовий символ, ми повинні вказати довжину
        //рядка + 1; інакше наш рядок буде урізано, щоб звільнити місце для нульового символу (ми втратимо 1 символ).
        len++;

        //Виділяємо пам'ять для зберігання рядка, який ми передаємо (str), а потім «отримуємо» рядок, використовуючи виділену пам'ять для його зберігання.
        char* text = new char[ len ];
        amx_GetString(text, addr, 0, len);

        //Вивести рядок (text) за допомогою logprintf. Ми не використовуємо std::cout, тому що вона не пише в лог сервера (тільки в консоль).
        logprintf(text);

        //Звільняємо пам'ять...
        delete[] text;
    }
    повернути 1;
}
```

### Альтернативний спосіб отримання рядка

Я вирішив додати цей розділ, тому що знаю, що люди можуть спокуситися простотою цього способу, і вважаю, що вони повинні знати про ризики і проблеми, які можуть виникнути у зв'язку з ним.

```cpp
//Ця функція демонструє: альтернативний метод отримання рядків з pawn- і можливі ризики, які з ним пов'язані.
//PAWN native: native PrintPawnString2(const str[]);
cell AMX_NATIVE_CALL PrintPawnString2(AMX* amx, cell* params)
{
    //Цей метод НЕ рекомендується використовувати, оскільки макрос amx_StrParam використовує функцію alloca, яка не є стандартом ні в C, ні в C++.
    //Використання цього методу пов'язане з ризиком переповнення стеку (якщо виділяється великий об'єм пам'яті), а також
    //дає вам ризик помилок (ця функція залежить від машини та компілятора - деякі реалізації вважаються багнутими).

    char* text = NULL;
    amx_StrParam(amx, params[1], text);

    //Перевірити, чи текст рівний нулю
    if(text != NULL)
    {
        //Вивести рядок (text) за допомогою logprintf. Ми не використовуємо std::cout, тому що вона не пише в лог сервера (тільки в консоль).
        logprintf(text);
    }
    повернути 1;

```

### Як задати рядок

```cpp
//Данна функція демонструє: як модифікувати рядок PAWN.
//PAWN native: native SetPawnString(str[], len = sizeof(str));
cell AMX_NATIVE_CALL SetPawnString(AMX* amx, cell* params)
{
    const string message = «Це рядок з мови C/++!!!»;
    cell* addr = NULL;

    //Отримуємо адресу нашого рядкового параметру (str) і зберігаємо наше повідомлення
    amx_GetAddr(amx, params[1], &addr);
    amx_SetString(addr, message.c_str(), 0, 0, params[2]);
    return 1;
}
```

### Приведення та повернення чисел з плаваючою комою

```cpp
//Данна функція демонструє: приведення плаваючого типу до типу PAWN та його повернення.
//PAWN native: native Float:ReturnPawnFloatVal();
cell AMX_NATIVE_CALL ReturnPawnFloatVal(AMX* amx, cell* params)
{
    //Оскільки PAWN є безтиповою мовою, вона зберігає все як 32-бітне ціле число і покладається на теги для обробки спеціальних даних.
    //Число з плаваючою комою не є винятком; це все ще 32-бітний int, але він має тег Float, який показує, що його не слід
    //поводитися з ним як зі звичайним цілим числом. Отже, як перетворити число з плаваючою комою у 32-бітне ціле (для PAWN) без втрати даних?
    //Відповідь - макрос amx_ftoc!

    //Макрос з типом amx_ftoc приводить плаваючу комірку до комірки зі збереженням її бітової структури (amx_ctof робить зворотній процес).
    const float f = 22.624f;
    return amx_ftoc(f);
}
```

### Передача параметрів за посиланням

```cpp
//Ця функція демонструє: Як передавати параметри за посиланням.
//PAWN native: native SetPawnReferenceVars(&value1, &Float:value2);
cell AMX_NATIVE_CALL SetPawnReferenceVars(AMX* amx, cell* params)
{
    const int val = 65;
    const float val2 = 84.54f;

    cell* addr[2] = {NULL, NULL};

    //Отримати адреси «value1» та «value2»
    amx_GetAddr(amx, params[1], &addr[0]);
    amx_GetAddr(amx, params[2], &addr[1]);

    //Роздиференціюємо наші вказівники і присвоюємо їм наші значення. Не забувайте ЗАВЖДИ використовувати макрос «amx_ftoc» для перетворення чисел з плаваючою комою у
    //комірку (відповідний формат для PAWN)!
    *addr[0] = val;
    *addr[1] = amx_ftoc(val2);

    повернути 1;
}
```

### Отримання та модифікація значень масивів

```cpp
//Дана функція демонструє: отримання та модифікацію значень масиву.
//PAWN native: native PrintPawnArray(arr[], size = sizeof(arr));
cell AMX_NATIVE_CALL PrintPawnArray(AMX* amx, cell* params)
{
    //Переконатись, що є що друкувати...
    if(params[2] > 0)
    {
        cell* addr = NULL;

        //Здобуваємо адресу першого значення у нашому масиві PAWN.
        amx_GetAddr(amx, params[1], &addr);

        for(int i = 0, l = params[2]; i < l; i++)
        {
            //Це досить просто: Ми розіменовуємо вказівник addr, щоб отримати наше значення для друку.
            //Ви вже повинні це знати, але масиви і вказівники - це майже одне і те ж, тому ми можемо використовувати вказівник
            //арифметику для додавання зсуву АБО просто використовуємо оператор підстановки (зрештою *(addr+1) і addr[1] - це одне й те саме).
            logprintf(«arr[%d] = %d», i, *(addr + i));

            //Якби ви хотіли змінити масив, ви б просто змінили його значення, розіменявши addr і присвоївши йому нове значення.
            //Ви маєте це знати, я просто додаю це для повноти картини. Тут ми змінюємо перше значення нашого масиву
            //на 5 (Примітка: оскільки це перше значення, зміщення не використовується).

            // *(addr) = 5;
        }
    }
    return 1;
}
```

### Викликати зворотний виклик

```cpp
//Ця функція демонструє: Як викликати зворотній виклик, що знаходиться у скрипті PAWN.
//PAWN native: native EmitPawnCallback();
cell AMX_NATIVE_CALL EmitPawnCallback(AMX* amx, cell* params)
{
    int idx;

    const cell var = 3;
    const cell arr[] = {100, 4, 33};
    const string str = «Якесь випадкове повідомлення з C++.»;


    //Пішаковий колбек: переслати OnPawnCallbackEmitted(var, arr[], str[]);
    //Знаходимо наш колбек і записуємо його місце в таблиці публічних функцій (його індекс) в наш idx var.
    if(!amx_FindPublic(amx, «OnPawnCallbackEmitted», &idx))
    {
        комірка
            ret,
            addr;

        //Тут ми передаємо аргументи у нашу функцію. Зверніть увагу, що якщо функція має декілька аргументів, ви повинні передавати свої
        //значення у зворотному порядку! Ось чому ми передаємо спочатку рядок, потім масив, і, нарешті, наше ціле число.

        amx_PushString(amx, &addr, NULL, str.c_str(), NULL, NULL);
        //amx_PushArray(amx, NULL, NULL, arr, sizeof(arr) / sizeof(cell));

        комірка
            amx_addr,
            *phys_addr;

        //З деяких причин amx_PushArray призводить до падіння сервера, і я не маю жодного уявлення чому. Моє використання повинно бути повністю
        //правильним, судячи з керівництва для реалізаторів та самого коду. Оскільки функція не працює, нам доведеться
        //використовувати старий метод і виділяти пам'ять, встановлювати і запускати все самостійно. Це досить просто. Виділяємо пам'ять
        //виділяємо пам'ять на купі за допомогою amx_Allot (повертає 2 адреси - одна з них на абстрактній машині
        //(amx_addr), а іншу - відносно реального адресного простору сервера (phsy_addr - яку ми можемо використати у C++)). Після того, як
        //пам'ять виділено, ми використовуємо memcpy для копіювання пам'яті з нашого масиву до адресної області phys_addr.
        amx_Allot(amx, sizeof(arr) / sizeof(cell), &amx_addr, &phys_addr);
        memcpy(phys_addr, arr, sizeof(arr));
        amx_Push(amx, amx_addr);

        //Виштовхуємо наше цілочисельне значення
        amx_Push(amx, var);

        //Виконуємо нашу функцію, використовуючи отриманий раніше ідентифікатор idx var.
        //Примітка: Другий параметр цієї функції - це те, що повернув зворотній виклик (може бути NULL, якщо вас не цікавлять значення, що повертаються).
        amx_Exec(amx, &ret, idx);

        //Звільняємо пам'ять, яку ми виділили. Функція amx_Alloc виділяє пам'ять на кучі в абстрактній машині.
        //Функції amx_PushString та amx_PushArray використовують цю функцію внутрішньо, тому вам доведеться звільняти пам'ять кожного разу
        //якщо ви використовуєте одну з цих функцій. Зауваження: Ми використали обидві функції amx_PushString та amx_PushArray, але маємо лише ОДИН виклик звільнення.
        //Це тому, що пам'ять на купі виділяється у порядку зростання! amx_Release звільняє всю пам'ять вище певної точки
        //(другий параметр, amx_addr - це наша змінна addr). Оскільки вона це робить, ми зберігаємо ЛИШЕ адресу з виклику amx_PushString
        //виклику, оскільки з цієї точки все буде видалено.
        amx_Release(amx, addr);

        //Виводимо значення, що повертається (для повноти картини).
        logprintf(«EmitPawnCallback NOTE: OnPawnCallbackEmitted callback повернув %d!», ret);

    }
    return 1;
```

## Виклик нативів та перехоплення зворотних викликів

Перш ніж я перейду до під'єднання зворотного виклику або виклику нативних функцій SA-MP, я подумав, що спочатку я повинен пролити світло на деякі моменти. Дехто вважає, що плагіни є заміною PAWN, але це не так. Плагіни було розроблено для надання функціональності PAWN, а не для заміни його. Бувають випадки, коли розробка чогось як плагіна, а не скрипта PAWN, не має сенсу - важливо запитати себе, чи дійсно ви повинні кодувати щось як плагін, а не як скрипт PAWN.

Існує багато різних методів, які ви можете використовувати як для зворотного виклику, так і для власного виклику sa-mp. Але зараз я зосереджуся лише на одному методі з кожного з них.

### Invoke (Викликати)

Invoke - це метод виклику власних функцій SA-MP, який було створено інкогніто. Ви можете знайти його [тут](https://github.com/Dystans/SA-MP_Invoke_2.0). Зверніть увагу, що там є текстовий файл, який містить функцію з безліччю викликів власних функцій SA-MP. Це життєво важливо для виклику і має бути додано до включаємого файлу вашого плагіна. Invoke не працюватиме, якщо у вас немає публічної функції PAWN, яка використовує усі власні функції SA-MP, що потрібні вашому плагіну. Ця функція потрібна лише для того, щоб invoke міг знайти адреси нативних модулів, і її не слід **ніколи** використовувати.

#### Початок роботи

Перш ніж ми зможемо почати викликати SA-MP нативну бібліотеку, нам потрібно налаштувати Invoke. Перше, що нам потрібно зробити, це включити його до нашого проєкту, ви повинні пам'ятати, як це зробити з попереднього розділу «Початок роботи». Після того, як ви додали файли до вашого проєкту, є лише кілька простих кроків, щоб змусити Invoke працювати:

- Додайте заголовок виклику.
- Виділіть пам'ять для екземпляра invoke у розділі Load.
- Відсувайте змінну-член amx_list щоразу, коли завантажується новий екземпляр AMX в AmxLoad.
- Кожного разу, коли скрипт вивантажується, перебирати amx_list Invoke, знаходити вивантажений екземпляр AMX і видаляти його за допомогою AmxUnload.
- Створіть нативний код, який викликає функцію-член Invoke «getAddresses» для PAWN, щоб використовувати його, коли завантажується скрипт фільтрів або ігровий режим, який використовує наш плагін.

Це все, що потрібно зробити для налаштування invoke для вашого плагіна. Єдине, що залишилося зробити, це додати публічну функцію PAWN, знайдену в пакеті invoke (txt-файл, про який ми говорили раніше), до включення вашого плагіна, і використовувати власну функцію з останнього кроку налаштування при завантаженні скрипту. Всім, хто буде створювати плагіни для публічного релізу, я рекомендую ознайомитися з цією статтею. Він дозволяє створити чистий безшовний «гачок» зворотних викликів OnGameModeInit/OnFilterScriptInit, щоб ви могли зареєструвати рідні адреси SA-MP, не змушуючи кінцевого користувача додавати функцію у ці виклики самостійно.

**Примітка:** Я усвідомлюю, що пояснення цього у текстовій формі, можливо, не є ідеальним для більшості користувачів-початківців; однак це все стандартні завдання C/++, з якими ви вже маєте бути знайомі, а ті, що не є такими (тобто, створення нативних функцій), вже було пояснено! Якщо у вас виникають проблеми з розумінням, я пропоную трохи більше ознайомитися з C/++. З огляду на це, пізніше в цій статті буде оновлено файл вихідного коду (разом з фактичним включенням нашого плагіна) з коментарями про все, що ми дізналися до цього часу. Якщо у вас виникнуть проблеми, зверніться до цього оновленого файлу коду.

#### Додавання нативних SA-MP-файлів

На жаль, виклик invoke не є магією, і потребує обслуговування для додавання нових або вилучення застарілих нативних програм. Версія з попереднього розділу містить усі нативні компоненти з версії 0.2.2 SA-MP, тому у ній не вистачає нових функцій. З цих двох причин я вирішив додати цей розділ! Якщо хтось буде достатньо добрим, щоб додати всі відсутні функції, я оновлю пакунок invoke і додам їх до титрів - якщо ні, я пропоную додавати функції за потребою.

Всередині заголовка invoke ви побачите великий масив імен функцій (масив відповідно називається «name») і багато статичних оголошень «нативних» структур. Щоб додати нативну функцію, ви просто додаєте її ім'я до масиву імен і оголошуєте нативну структуру з відповідною інформацією - ім'ям і специфікаторами параметрів. Існує багато доступних специфікаторів параметрів, які можна використовувати:

```cpp
i = ціле число
f = значення з плаваючою комою
s = рядок
v = змінна-посилання (GetPlayerPos, GetPlayerKeys тощо)
p = string var (GetPlayerName і т.д.)
```

**Не забудьте оновити публічну функцію PAWN, яка викликає всі нативні компоненти.** Щоразу, коли ви додаєте нативний компонент, ви також повинні додати його до згаданої публічної функції.

#### Виклик нативних функцій

Для виклику нативів Invoke використовує варіадну функцію-член з відповідною назвою «callNative». Параметрами цієї функції є вказівник на структуру Native (див. попередній розділ), що містить інформацію про нативну функцію, та еліпсис для всіх параметрів цієї нативної функції. Функція повертає значення нативної функції, яка викликається. Ось приклад функції, яка викликає декілька нативних функцій з різними типами параметрів (int, посилання та рядок var).

```cpp
//Ця функція демонструє: як використовувати invoke для виклику нативів SA-MP.
//PAWN native: native WhereIsPlayer(playerid);
cell AMX_NATIVE_CALL WhereIsPlayer(AMX* amx, cell* params)
{
    з плаваючою комою
        x = NULL
        y = NULL
        z = NULL;

    //Отримаємо позицію гравця (і перевіримо, чи він взагалі підключений).
    if(g_Invoke->callNative(&PAWN::GetPlayerPos, params[1], &x, &y, &z))
    {
        char name[24];

        //Здобуваємо решту інформації про гравця (ім'я, інтер'єр та віртуальний світ) та виводимо її на екран.
        g_Invoke->callNative(&PAWN::GetPlayerName, params[1], name);
        int interior = g_Invoke->callNative(&PAWN::GetPlayerInterior, params[1]);
        int virtualworld = g_Invoke->callNative(&PAWN::GetPlayerVirtualWorld, params[1]);

        logprintf(«%s знаходиться за адресою X: %.2f, Y: %.2f, Z: %.2f (Віртуальний світ: %d, Інтер'єр %d).», name, x, y, z, virtualworld, interior);
        return 1;

    }
    return 0;
}
```

### Підключення функцій зворотного виклику

Використання методу invoke не є на 100% прозорим методом підключення, коли мова йде про зворотні виклики. Плагіни, які хочуть підключати функції зворотного виклику, що використовують invoke, повинні робити це через PAWN. Ви можете створити власну функцію, яку можна викликати всередині зворотного виклику PAWN, який ви хочете підчепити, і використовувати її як псевдо-зворотний виклик. Ви можете зробити це у спосіб, який не вимагає від кінцевого користувача ніякої роботи, використовуючи метод ALS-перехоплення.

Першим кроком, очевидно, є створення нативної функції (не забудьте додати її до нашого списку нативних функцій для реєстрації, а також додати її до вашого include пізніше). Функція зворотного виклику, яку я вирішив підчепити, називається OnPlayerConnect, тому я напишу нативну функцію з тими самими аргументами, що й функція зворотного виклику, а потім додам код, який викликає зворотний виклик (в даному випадку це буде невеликий жарт).

```cpp
//Ця функція демонструє: як написати нативну функцію для роботи в якості колбеку.
//PAWN native: native TEST_Hook_OnPlayerConnnect(playerid);
cell AMX_NATIVE_CALL TEST_Hook_OnPlayerConnnect(AMX* amx, cell* params)
{
    //Отримати ім'я гравця
    char name[24];
    g_Invoke->callNative(&PAWN::GetPlayerName, params[1], name);

    //Перевірити, чи його ім'я «Mario».
    if(string(«Mario») == name)
    {
        //Якщо це так, то відправляємо наше кумедне повідомлення і копаємо його ногою.
        g_Invoke->callNative(&PAWN::SendClientMessage, params[1], 0xFFFFFFFF, «Вибач {FF0000}Маріо, {FFFFFF}але твоя принцеса на іншому сервері.»);
        g_Invoke->callNative(&PAWN::Kick, params[1]);
    }
    return 1;
}
```

TEST_Hook_OnPlayerConnnect тепер діятиме як функція зворотного виклику OnPlayerConnect нашого плагіна. Оскільки ім'я нашого плагіна «Test» і воно досить коротке, я вирішив використати його як префікс для підключення. Зазвичай вам потрібно щось унікальне для ваших префіксів, щоб не стикатися з чужими плагінами/інклюдами. **Примітка:** Нам все одно доведеться викликати цю функцію з PAWN за допомогою методу ALS, про який ми говорили раніше, для зручності користувача. Оскільки Y_Less чудово пояснює метод ALS, мені немає сенсу вдаватися в подробиці, я просто надам приклад підключення хука для нашого зворотного виклику TEST_Hook_OnPlayerConnect. Його слід помістити у файл включення вашого плагіна.

```cpp
public OnPlayerConnect(playerid)
{
    TEST_Hook_OnPlayerConnect(playerid);
    //..

    if(funcidx(«TEST_OnPlayerConnect») != -1)
    {
        return CallLocalFunction(«TEST_OnPlayerConnect», «d», playerid);
    }
    return 1;
}

#if визначено _ALS_OnPlayerConnect
    #undef OnPlayerConnect
#else
    #визначити _ALS_OnPlayerConnect
#endif
#define OnPlayerConnect TEST_OnPlayerConnect

forward TEST_OnPlayerConnect(playerid);
```

## Закриття

Деякі з вас, досвідчені розробники плагінів, можуть здивуватися, чому я не включив GDK до розділу «Виклик нативів та під'єднання зворотних викликів». Я вирішив не включати його з двох причин. Перша з них полягає в тому, що я просто не маю більше вільного часу, і не можу витрачати його на звикання до цієї нової системи. Друга причина полягає в тому, що GDK є дуже експериментальною і наразі бореться зі збоями серед інших проблем. Я цілком усвідомлюю різницю у швидкості між Invoke та GDK, і, безумовно, додам її колись у майбутньому, якщо ніхто інший цього не зробить (пам'ятайте, що це має бути справа рук спільноти). Я думаю, що поки що краще зачекати, поки деякі проблеми буде вирішено (zeex - чудовий програміст, і я впевнений, що він все виправить).

Також, як я і обіцяв, ось оновлений включаючий/вихідний файл з коментарями про все, що ми, сподіваюсь, дізналися:

### Плагін include

```cpp
//Все з префіксом «TEST» має бути змінено, якщо ви назвали свій плагін якось
//іншим. Це стосується і коду плагіна (зокрема, TEST_Hook_OnPlayerConnect).
#if визначено _TEST_INCLUDED
    #endinput
#endif
#визначити _TEST_INCLUDED
#бібліотека прагматики Test

#include <samp>

//Приклади нативів
native PrintPawnString(const str[]);
native PrintPawnString2(const str[]);
native SetPawnString(str[], len = sizeof(str));
native Float:ReturnPawnFloatVal();
native SetPawnReferenceVars(&value1, &Float:value2);
native PrintPawnArray(arr[], size = sizeof(arr));
native EmitPawnCallback();
native WhereIsPlayer(playerid);
native TEST_Hook_OnPlayerConnnect(playerid);

//Викликати native
native Invoke_GetAddresses();


//Хуки зворотного виклику
public OnPlayerConnect(playerid)
{
    TEST_Hook_OnPlayerConnect(playerid);
    //..

    if(funcidx(«TEST_OnPlayerConnect») != -1)
    {
        return CallLocalFunction(«TEST_OnPlayerConnect», «d», playerid);
    }
    return 1;
}

#if визначено _ALS_OnPlayerConnect
    #undef OnPlayerConnect
#else
    #визначити _ALS_OnPlayerConnect
#endif
#define OnPlayerConnect TEST_OnPlayerConnect

forward TEST_OnPlayerConnect(playerid);

public OnGameModeInit()
{
    Invoke_GetAddresses();
    //..

    if(funcidx(«TEST_OnGameModeInit») != -1)
    {
        return CallLocalFunction(«TEST_OnGameModeInit», «»);
    }
    return 1;
}

#if визначено _ALS_OnGameModeInit
    #undef OnGameModeInit
#else
    #визначити _ALS_OnGameModeInit
#endif
#define OnGameModeInit TEST_OnGameModeInit

переслати TEST_OnGameModeInit();


public OnFilterScriptInit()
{
    Invoke_GetAddresses();
    //..

    if(funcidx(«TEST_OnFilterScriptInit») != -1)
    {
        return CallLocalFunction(«TEST_OnFilterScriptInit», «»);
    }
    return 1;
}

#if визначено _ALS_OnFilterScriptInit
    #undef OnFilterScriptInit
#else
    #визначити _ALS_OnFilterScriptInit
#endif
#define OnFilterScriptInit TEST_OnFilterScriptInit

forward TEST_OnFilterScriptInit();


//Публічна функція для виклику
forward InvokeFunction();
public InvokeFunction()
{
    new Float:fVar;
    new Var[ 256 ];
    new iVar;

    // a_samp.inc
    SendClientMessage(0, 0, «»);
    SendClientMessageToAll(0, «»);
    SendDeathMessage(0, 0, 0);
    GameTextForAll(«», 0, 0);
    GameTextForPlayer(0, «», 0, 0);
    GetTickCount();
    GetMaxPlayers();
    SetGameModeText(«»);
    SetTeamCount(0);
    AddPlayerClass(0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    AddPlayerClassEx(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    AddStaticVehicle(0, 0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0);
    AddStaticVehicleEx(0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0, 0);
    AddStaticPickup(0, 0, 0, 0.0, 0.0, 0.0, 0.0);
    ShowNameTags(0);
    ShowPlayerMarkers(0);
    GameModeExit();
    SetWorldTime(0);
    GetWeaponName(0, Var, sizeof( Var ) );
    EnableTirePopping(0);
    Дозволити внутрішню зброю(0);
    SetWeather(0);
    SetGravity(0.0);
    Дозволити адмін-телепорт(0);
    SetDeathDropAmount(0);
    CreateExplosion(0.0, 0.0, 0.0, 0.0, 0, 0.0);
    //ВстановитиВідключенуЗброю();
    EnableZoneNames(0);
    IsPlayerAdmin(0);
    Kick(0);
    Ban(0);
    SendRconCommand(«»);
    ShowPlayerDialog(0,0,0, «lol», «lol», «lol», «lol», «lol»);

    // a_players.inc
    SetSpawnInfo(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0);
    SpawnPlayer(0);
    SetPlayerPos(0, 0.0, 0.0, 0.0, 0.0);
// SetPlayerPosFindZ(0, 0.0, 0.0, 0.0, 0.0);
    GetPlayerPos(0, fVar, fVar, fVar);
    SetPlayerFacingAngle(0,0.0);
    GetPlayerFacingAngle(0,fVar);
    SetPlayerInterior(0,0);
    GetPlayerInterior(0);
    SetPlayerHealth(0, 0.0);
    GetPlayerHealth(0, fVar);
    SetPlayerArmour(0, 0.0);
    GetPlayerArmour(0, fVar);
    SetPlayerAmmo(0, 0,0);
    GetPlayerAmmo(0);
    SetPlayerTeam(0,0);
    GetPlayerTeam(0);
    SetPlayerScore(0,0);
    GetPlayerScore(0);
    SetPlayerColor(0,0);
    GetPlayerColor(0);
    SetPlayerSkin(0,0);
    GivePlayerWeapon(0, 0,0);
    ResetPlayerWeapons(0);
    GetPlayerWeaponData(0, 0, iVar, iVar );
    GivePlayerMoney(0,0);
    ResetPlayerMoney(0);
    SetPlayerName(0, «»);
    GetPlayerMoney(0);
    GetPlayerState(0);
    GetPlayerIp(0, Var, sizeof( Var ));
    GetPlayerPing(0);
    GetPlayerWeapon(0);
    GetPlayerKeys(0,iVar,iVar,iVar);
    GetPlayerName(0, Var, sizeof( Var ));
    PutPlayerInVehicle(0, 0,0);
    GetPlayerVehicleID(0);
    RemovePlayerFromVehicle(0);
    TogglePlayerControlable(0,0);
    PlayerPlaySound(0, 0, 0, 0.0, 0.0,0.0);
    SetPlayerCheckpoint(0, 0.0, 0.0, 0.0, 0.0,0.0);
    DisablePlayerCheckpoint(0);
    SetPlayerRaceCheckpoint(0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0);
    DisablePlayerRaceCheckpoint(0);
    SetPlayerWorldBounds(0,0.0,0.0,0.0,0.0,0.0);
    SetPlayerMarkerForPlayer(0, 0, 0);
    ShowPlayerNameTagForPlayer(0, 0,0);
    SetPlayerMapIcon(0, 0, 0, 0,0, 0,0, 0,0, 0,0, 0,0);
    RemovePlayerMapIcon(0,0);
    SetPlayerCameraPos(0,0.0, 0.0, 0.0, 0.0);
    SetPlayerCameraLookAt(0, 0.0, 0.0, 0.0, 0.0);
    SetCameraBehindPlayer(0);
    AllowPlayerTeleport(0,0);
    IsPlayerConnected(0);
    IsPlayerInVehicle(0,0);
    IsPlayerInAnyVehicle(0);
    IsPlayerInCheckpoint(0);
    IsPlayerInRaceCheckpoint(0);
    SetPlayerTime(0, 0,0);
    TogglePlayerClock(0,0);
    SetPlayerWeather(0,0);
    GetPlayerTime(0,iVar,iVar);
    SetPlayerVirtualWorld(0,0);
    GetPlayerVirtualWorld(0);

    // a_vehicle.inc
    CreateVehicle(0,0.0,0.0,0.0,0.0,0,0,0);
    DestroyVehicle(0);
    GetVehiclePos(0,fVar,fVar,fVar);
    SetVehiclePos(0,0.0,0.0,0.0,0.0);
    GetVehicleZAngle(0,fVar);
    SetVehicleZAngle(0,0.0);
    SetVehicleParamsForPlayer(0,0,0,0,0);
    SetVehicleToRespawn(0);
    LinkVehicleToInterior(0,0);
    AddVehicleComponent(0,0);
    ChangeVehicleColor(0,0,0);
    ChangeVehiclePaintjob(0,0);
    SetVehicleHealth(0,0.0);
    GetVehicleHealth(0,fVar);
    AttachTrailerToVehicle(0, 0);
    DetachTrailerFromVehicle(0);
    IsTrailerAttachedToVehicle(0);
    GetVehicleModel(0);
    SetVehicleNumberPlate(0,«»);
    SetVehicleVirtualWorld(0,0);
    GetVehicleVirtualWorld(0);

    ApplyAnimation(0,«»,«»,1.0,0,0,0,0,0);

    // a_objects.inc
    CreateObject(0,0.0,0.0,0.0,0.0,0.0,0.0);
    SetObjectPos(0,0.0,0.0,0.0,0.0);
    GetObjectPos(0,fVar,fVar,fVar);
    SetObjectRot(0,0.0,0.0,0.0,0.0);
    GetObjectRot(0,fVar,fVar,fVar);
    IsValidObject(0);
    DestroyObject(0);
    MoveObject(0,0.0,0.0,0.0,0.0);
    StopObject(0);
    CreatePlayerObject(0,0,0.0,0.0,0.0,0.0,0.0,0.0);
    SetPlayerObjectPos(0,0,0,0,0,0,0,0,0);
    GetPlayerObjectPos(0,0,fVar,fVar,fVar);
    GetPlayerObjectRot(0,0,fVar,fVar,fVar);
    SetPlayerObjectRot(0,0,0.0,0.0,0.0,0.0);
    IsValidPlayerObject(0,0);
    DestroyPlayerObject(0,0);
    MovePlayerObject(0,0,0,0,0,0,0,0,0,0,0);
    StopPlayerObject(0,0);

    // Меню
    CreateMenu(«», 0, 0.0, 0.0, 0.0, 0.0, 0.0);
    DestroyMenu(Menu:0);
    AddMenuItem(Menu:0, 0, «»);
    SetMenuColumnHeader(Menu:0, 0, «»);
    ShowMenuForPlayer(Menu:0, 0);
    HideMenuForPlayer(Menu:0, 0);
    IsValidMenu(Menu:0);
    DisableMenu(Menu:0);
    DisableMenuRow(Menu:0,0);

    // Намалювати текст
    TextDrawCreate(0.0,0.0,«»);
    TextDrawDestroy(Text:0);
    TextDrawLetterSize(Text:0, 0.0,0.0);
    TextDrawTextSize(Text:0, 0.0,0.0);
    TextDrawAlignment(Text:0, 0);
    TextDrawColor(Text:0,0);
    TextDrawUseBox(Text:0, 0);
    TextDrawBoxColor(Text:0, 0);
    TextDrawSetShadow(Text:0, 0);
    TextDrawSetOutline(Text:0, 0);
    TextDrawBackgroundColor(Text:0,0);
    TextDrawFont(Text:0, 0);
    TextDrawSetProportional(Text:0, 0);
    TextDrawShowForPlayer(0, Text:0);
    TextDrawHideForPlayer(0, Text:0);
    TextDrawShowForAll(Text:0);
    TextDrawHideForAll(Text:0);

    // Інші
    funcidx(«»);
    gettime(iVar,iVar,iVar);
    getdate(iVar,iVar,iVar);
    tickcount(iVar);

    return 1;
}
```

### Вихідний код плагіна

```cpp
#include «SDK\amx\amx.h»
#include «SDK\plugincommon.h»

#include «Invoke.h»

#include <string>
#include <vector>

#include <cstdlib>
#include <ctime>


typedef void (*logprintf_t)(char* format, ...);

logprintf_t logprintf;
extern void *pAMXFunctions;


з використанням простору імен std;


//Ця функція демонструє: як отримати рядок (та його довжину) з PAWN.
//PAWN native: native PrintPawnString(const str[]);
cell AMX_NATIVE_CALL PrintPawnString(AMX* amx, cell* params)
{
    int
        len = NULL
        ret = NULL;

    cell *addr = NULL;

    //Отримуємо адресу нашого рядка param (str) і потім отримуємо його довжину
    amx_GetAddr(amx, params[1], &addr);
    amx_StrLen(addr, &len);

    //якщо довжина вхідних даних не рівна 0
    if(len)
    {
        //Ми збільшуємо len, тому що хочемо звільнити місце для завершального нульового символу при виділенні пам'яті.
        //Також, оскільки параметр розміру GetString враховує нульовий символ, ми повинні вказати довжину
        //рядка + 1; інакше наш рядок буде урізано, щоб звільнити місце для нульового символу (ми втратимо 1 символ).
        len++;

        //Виділяємо пам'ять для зберігання рядка, який ми передаємо (str), а потім «отримуємо» рядок, використовуючи виділену пам'ять для його зберігання.
        char* text = new char[ len ];
        amx_GetString(text, addr, 0, len);

        //Вивести рядок (text) за допомогою logprintf. Ми не використовуємо std::cout, тому що вона не пише в лог сервера (тільки у вікно).
        logprintf(text);

        //Звільняємо пам'ять...
        delete[] text;
    }
    повернути 1;
}

//Ця функція демонструє: Як викликати функцію зворотного виклику, яка знаходиться у скрипті PAWN.
//PAWN native: native EmitPawnCallback();
cell AMX_NATIVE_CALL EmitPawnCallback(AMX* amx, cell* params)
{
    int idx;

    const cell var = 3;
    const cell arr[] = {100, 4, 33};
    const string str = «Якесь випадкове повідомлення з C++.»;


    //Пішаковий колбек: переслати OnPawnCallbackEmitted(var, arr[], str[]);
    //Знаходимо наш колбек і записуємо його місце в таблиці публічних функцій (його індекс) в наш idx var.
    if(!amx_FindPublic(amx, «OnPawnCallbackEmitted», &idx))
    {
        комірка
            ret,
            addr;

        //Тут ми передаємо аргументи у нашу функцію. Зверніть увагу, що якщо функція має декілька аргументів, ви повинні передавати свої
        //значення у зворотному порядку! Ось чому ми передаємо спочатку рядок, потім масив, і, нарешті, наше ціле число.

        amx_PushString(amx, &addr, NULL, str.c_str(), NULL, NULL);
        //amx_PushArray(amx, NULL, NULL, arr, sizeof(arr) / sizeof(cell));

        комірка
            amx_addr,
            *phys_addr;

        //З деяких причин amx_PushArray призводить до падіння сервера, і я не маю жодного уявлення чому. Моє використання повинно бути повністю
        //правильним, судячи з керівництва для реалізаторів та самого коду. Оскільки функція не працює, нам доведеться
        //використовувати старий метод і виділяти пам'ять, встановлювати і запускати все самостійно. Це досить просто. Виділяємо пам'ять
        //виділяємо пам'ять на купі за допомогою amx_Allot (повертає 2 адреси - одна з них на абстрактній машині
        //(amx_addr), а іншу - відносно реального адресного простору сервера (phsy_addr - яку ми можемо використати у C++)). Після того, як
        //пам'ять виділено, ми використовуємо memcpy для копіювання пам'яті з нашого масиву до адресної області phys_addr.
        amx_Allot(amx, sizeof(arr) / sizeof(cell), &amx_addr, &phys_addr);
        memcpy(phys_addr, arr, sizeof(arr));
        amx_Push(amx, amx_addr);

        //Виштовхуємо наше цілочисельне значення
        amx_Push(amx, var);

        //Виконуємо нашу функцію, використовуючи отриманий раніше ідентифікатор idx var.
        //Примітка: Другий параметр цієї функції - це те, що повернув зворотній виклик (може бути NULL, якщо вас не цікавлять значення, що повертаються).
        amx_Exec(amx, &ret, idx);

        //Звільняємо пам'ять, яку ми виділили. Функція amx_Alloc виділяє пам'ять на кучі в абстрактній машині.
        //Функції amx_PushString та amx_PushArray використовують цю функцію внутрішньо, тому вам доведеться звільняти пам'ять кожного разу
        //якщо ви використовуєте одну з цих функцій. Зауваження: Ми використали обидві функції amx_PushString та amx_PushArray, але маємо лише ОДИН виклик звільнення.
        //Це тому, що пам'ять на купі виділяється у порядку зростання! amx_Release звільняє всю пам'ять вище певної точки
        //(другий параметр, amx_addr - це наша змінна addr). Оскільки вона це робить, ми зберігаємо ЛИШЕ адресу з виклику amx_PushString
        //виклику, оскільки з цієї точки все буде видалено.
        amx_Release(amx, addr);

        //Виводимо значення, що повертається (для повноти картини).
        logprintf(«EmitPawnCallback NOTE: OnPawnCallbackEmitted callback повернув %d!», ret);

    }
    return 1;
}


//Ця функція демонструє: альтернативний метод отримання рядків з pawn- і можливі ризики, які з ним пов'язані.
//PAWN native: native PrintPawnString2(const str[]);
cell AMX_NATIVE_CALL PrintPawnString2(AMX* amx, cell* params)
{
    //Цей метод НЕ рекомендується використовувати, оскільки макрос amx_StrParam використовує функцію alloca, яка не є стандартом ні в мові C, ні в мові C++.
    //Використання цього методу пов'язане з ризиком переповнення стеку (якщо виділяється великий об'єм пам'яті), а також
    //дає вам ризик помилок (ця функція залежить від машини та компілятора - деякі реалізації вважаються багнутими).

    char* text = NULL;
    amx_StrParam(amx, params[1], text);

    //Перевірити, чи текст рівний нулю
    if(text != NULL)
    {
        //Вивести рядок (text) за допомогою logprintf. Ми не використовуємо std::cout, тому що вона не пише в лог сервера (тільки у вікно).
        logprintf(text);
    }
    return 1;
}

//Ця функція демонструє: як модифікувати рядок PAWN.
//PAWN native: native SetPawnString(str[], len = sizeof(str));
cell AMX_NATIVE_CALL SetPawnString(AMX* amx, cell* params)
{
    const string message = «Це рядок з мови C/++!!!»;
    cell* addr = NULL;

    //Отримуємо адресу нашого рядкового параметру (str) і зберігаємо наше повідомлення
    amx_GetAddr(amx, params[1], &addr);
    amx_SetString(addr, message.c_str(), 0, 0, params[2]);
    return 1;
}

//Ця функція демонструє: як приводити плаваюче число до плаваючого типу PAWN.
//PAWN native: native Float:ReturnPawnFloatVal();
cell AMX_NATIVE_CALL ReturnPawnFloatVal(AMX* amx, cell* params)
{
    //Оскільки PAWN є безтиповою мовою, вона зберігає все як 32-бітне ціле число і покладається на теги для обробки спеціальних даних.
    //Число з плаваючою комою не є винятком; це все ще 32-бітний int, але він має тег Float, який показує, що його не слід
    //поводитися з ним як зі звичайним цілим числом. Отже, як перетворити число з плаваючою комою у 32-бітне ціле (для PAWN) без втрати даних?
    //Відповідь - макрос amx_ftoc!

    //Макрос з типом amx_ftoc приводить плаваючу комірку до комірки зі збереженням її бітової структури (amx_ctof робить зворотній процес).
    const float f = 22.624f;
    return amx_ftoc(f);
}

//Ця функція демонструє: Як передавати параметри за посиланням.
//PAWN native: native SetPawnReferenceVars(&value1, &Float:value2);
cell AMX_NATIVE_CALL SetPawnReferenceVars(AMX* amx, cell* params)
{
    const int val = 65;
    const float val2 = 84.54f;

    cell* addr[2] = {NULL, NULL};

    //Отримати адреси «value1» та «value2»
    amx_GetAddr(amx, params[1], &addr[0]);
    amx_GetAddr(amx, params[2], &addr[1]);

    //Роздиференціюємо наші вказівники і присвоюємо їм наші значення. Не забувайте ЗАВЖДИ використовувати макрос «amx_ftoc» для перетворення чисел з плаваючою комою у
    //комірку (відповідний формат для PAWN)!
    *addr[0] = val;
    *addr[1] = amx_ftoc(val2);

    повернути 1;
}

//Ця функція демонструє: як отримувати та модифікувати значення масиву.
//PAWN native: native PrintPawnArray(arr[], size = sizeof(arr));
cell AMX_NATIVE_CALL PrintPawnArray(AMX* amx, cell* params)
{
    //Переконатись, що є що друкувати...
    if(params[2] > 0)
    {
        cell* addr = NULL;

        //Здобуваємо адресу першого значення у нашому масиві PAWN.
        amx_GetAddr(amx, params[1], &addr);

        for(int i = 0, l = params[2]; i < l; i++)
        {
            //Це досить просто: Ми розіменовуємо вказівник addr, щоб отримати наше значення для друку.
            //Ви вже повинні це знати, але масиви і вказівники - це майже одне і те ж, тому ми можемо використовувати вказівник
            //арифметику для додавання зсуву АБО просто використовуємо оператор підстановки (зрештою *(addr+1) і addr[1] - це одне й те саме).
            logprintf(«arr[%d] = %d», i, *(addr + i));

            //Якби ви хотіли змінити масив, ви б просто змінили його значення, розіменявши addr і присвоївши йому нове значення.
            //Ви маєте це знати, я просто додаю це для повноти картини. Тут ми змінюємо перше значення нашого масиву
            //на 5 (Примітка: оскільки це перше значення, зміщення не використовується).

            // *(addr) = 5;
        }
    }
    return 1;
}

//Ця функція демонструє: налаштування invoke (отримання адрес наших нативів).
//PAWN native: native Invoke_GetAddresses();
cell AMX_NATIVE_CALL Invoke_GetAddresses(AMX* amx, cell* params)
{
    return g_Invoke->getAddresses();
}

//Ця функція демонструє: як використовувати invoke для виклику SA-MP нативів.
//PAWN native: native WhereIsPlayer(playerid);
cell AMX_NATIVE_CALL WhereIsPlayer(AMX* amx, cell* params)
{
    з плаваючою комою
        x = NULL
        y = NULL
        z = NULL;

    //Отримаємо позицію гравця (і перевіримо, чи він взагалі підключений).
    if(g_Invoke->callNative(&PAWN::GetPlayerPos, params[1], &x, &y, &z))
    {
        char name[24];

        //Здобуваємо решту інформації про гравця (ім'я, інтер'єр та віртуальний світ) та виводимо її на екран.
        g_Invoke->callNative(&PAWN::GetPlayerName, params[1], name);
        int interior = g_Invoke->callNative(&PAWN::GetPlayerInterior, params[1]);
        int virtualworld = g_Invoke->callNative(&PAWN::GetPlayerVirtualWorld, params[1]);

        logprintf(«%s знаходиться за адресою X: %.2f, Y: %.2f, Z: %.2f (Віртуальний світ: %d, Інтер'єр %d).», name, x, y, z, virtualworld, interior);
        return 1;

    }
    return 0;
}

//Ця функція демонструє: як написати native для роботи в якості зворотного виклику.
//PAWN native: native TEST_Hook_OnPlayerConnnect(playerid);
cell AMX_NATIVE_CALL TEST_Hook_OnPlayerConnnect(AMX* amx, cell* params)
{
    //Отримати ім'я гравця
    char name[24];
    g_Invoke->callNative(&PAWN::GetPlayerName, params[1], name);

    //Перевірити, чи його ім'я «Mario».
    if(string(«Mario») == name)
    {
        //Якщо це так, то відправляємо наше кумедне повідомлення і копаємо його ногою.
        g_Invoke->callNative(&PAWN::SendClientMessage, params[1], 0xFFFFFFFF, «Вибач {FF0000}Маріо, {FFFFFF}але твоя принцеса на іншому сервері.»);
        g_Invoke->callNative(&PAWN::Kick, params[1]);
    }
    return 1;
}


//Ця функція повідомляє серверу, які можливості матиме наш плагін, виходячи з того, що вона повертає. Зазвичай ми використовуємо лише 3 прапори підтримки
//в плагінах: SUPPORTS_VERSION, SUPPORTS_AMX_NATIVES та SUPPORTS_PROCESS_TICK.
PLUGIN_EXPORT unsigned int PLUGIN_CALL Supports()
{
    //Примітка: Якщо ви використовуєте функцію ProcessTick, не забудьте експортувати її у файлі .def!
    return SUPPORTS_VERSION | SUPPORTS_AMX_NATIVES | SUPPORTS_PROCESS_TICK;
}

//Функція Load досить проста. Вона викликається при завантаженні плагіна і отримує масив адрес, які плагін
//буде використовувати для роботи. Зазвичай ми використовуємо два індекси: PLUGIN_DATA_AMX_EXPORTS та PLUGIN_DATA_LOGPRINTF.
PLUGIN_EXPORT bool PLUGIN_CALL Load(void **ppData)
{
    //виділити пам'ять для зовнішнього екземпляру g_Invoke
    g_Invoke = new Invoke;

    //Присвоюємо адреси нашої таблиці AMX-функцій та функції logprintf відповідним вказівникам.
    pAMXFunctions = ppData[PLUGIN_DATA_AMX_EXPORTS];
    logprintf = (logprintf_t) ppData[PLUGIN_DATA_LOGPRINTF];

    logprintf(«* Тестовий плагін було завантажено.»);
    return true;
}

//Unload викликається при вивантаженні плагіна (завершенні роботи сервера).
PLUGIN_EXPORT void PLUGIN_CALL Unload()
{
    logprintf(«* Тестовий плагін було вивантажено.»);
}

//Наш масив нативної інформації для amx_Register (назва та адреса функції).
AMX_NATIVE_INFO PluginNatives[] =
{
    {«PrintPawnString», PrintPawnString},
    {«PrintPawnString2», PrintPawnString2},
    {«SetPawnString», SetPawnString},
    {«Повернути значення пішака», ReturnPawnFloatVal},
    {«SetPawnReferenceVars», SetPawnReferenceVars},
    {«Роздрукувати масив пішаків», PrintPawnArray},
    {«EmitPawnCallback», EmitPawnCallback},
    {«Де гравець», WhereIsPlayer},
    {«Викликати_GetAddresses», Invoke_GetAddresses},
    {«TEST_Hook_OnPlayerConnnect», TEST_Hook_OnPlayerConnnect},
    {0, 0}
};

//Ця функція викликається, коли на сервер завантажується новий екземпляр AMX. Вона буде викликана для кожного скрипту/режиму гри! Через це не варто
//не варто зберігати один екземпляр AMX для всього плагіна, натомість використовуйте чергу/список/вектор. У цій функції ми також реєструємо наші кастомні
//нативні функції, які ми хочемо надати PAWN.
PLUGIN_EXPORT int PLUGIN_CALL AmxLoad( AMX *amx )
{
    //Щоразу, коли завантажується скрипт, ми хочемо додати його до AMX-списку invoke, тому ми відсуваємо список назад разом з екземпляром.
    g_Invoke->amx_list.push_back(amx);
    return amx_Register(amx, PluginNatives, -1);
}

//Ця функція викликається при вивантаженні кожного екземпляра AMX. Якщо ви зберігаєте екземпляри AMX, обов'язково видаліть їх. Інакше ви матимете екземпляри для
//неіснуючих ігрових режимів/скриптів фільтрів.
PLUGIN_EXPORT int PLUGIN_CALL AmxUnload( AMX *amx )
{
    //Кожен скрипт, який вивантажується, має бути видалений з нашого списку екземплярів AMX. Отже, ми перебираємо наш список і знаходимо екземпляр, який вивантажується
    //вивантажується, і видаляємо його зі списку.
    for(list<AMX *>::iterator i = g_Invoke->amx_list.begin(); i != g_Invoke->amx_list.end(); ++i)
    {
        if(*i == amx)
        {
            g_Invoke->amx_list.erase(i);
            break;
        }
    }
    return AMX_ERR_NONE;
}

//ProcessTick - це функція, яка викликається на кожній ітерації циклу сервера. Зазвичай люди використовують цю функцію як метод управління часом шляхом
//відстежуючи кількість пройдених тиків. Вважається, що сервер SA-MP має час сну 5 мс, тому, якщо пройшло 50 тиків, ви маєте уявлення про
// про час, що минув (5 * 50 = 250 мс). Зауваження: Усім, хто використовує потоки у своїх плагінах і потребує взаємодії з PAWN, слід використовувати цю функцію, щоб переконатися, що
//що PAWN не зайнятий виконанням іншого завдання!
PLUGIN_EXPORT void PLUGIN_CALL ProcessTick()
{
    static int tick = 0;
    const int NYAN_COUNT = 100;

    tick++;

    //Використовуємо оператор по модулю, щоб перевірити, чи пройшли тики NYAN_COUNT (100 тиків. 5 мс часу сну * 100 тиків = 500 мс).
    if(!(tick % NYAN_COUNT))
    {
        //Якщо пройшло 100 тиків, відправляємо наше кумедне маленьке повідомлення всім.
        const char nyan[] = «{FF0000}NYAN {FFA500}NYAN {FFFF00}NYAN {00FF00}NYAN {0000FF}NYAN {551A8B}NYAN»;
        g_Invoke->callNative(&PAWN::SendClientMessageToAll, 0, nyan);
    }
}
```

## Особлива подяка

**RyDeR`** - за надання зображень з його підручника з плагіна.

**Incognito** - за Invoke, інформацію про ProcessTick та за всю допомогу під час вивчення C++.

**Zeex/0x5A656578** - за GDK (буде включено колись) і за те, що зголосився відповісти на запитання про GDK.

**Y_Less** - За те, що він взагалі чудовий і постійно допомагає мені, коли я зовсім заплутався.

**Techboy123** - за безліч продуктивних чатів, допомогу та вислуховування моїх скарг.
