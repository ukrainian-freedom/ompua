---
заголовок: Маніпуляція з рядками
description: Підручник для початківців про всі маніпуляції з рядками.
---

## Вступ

### Опис підручника

Привіт усім, це, безумовно, гарна тиха ніч, або, принаймні, вона є такою під час написання цього підручника. Тож, привіт, як щодо того, щоб приєднатися до нас, щоб збагатити та/або долучитися до основної теми цієї статті, яка, як випливає з назви, буде зосереджена на «_Маніпуляції з рядками_» у пішаку, ми пройдемо від абсолютного проміжного матеріалу, про який кожен повинен знати, до якихось просунутих, розумних та ефективних порад.

### Що таке форматування рядків?

Загалом, форматування тексту - це маніпуляції з текстом для візуального покращення його читабельності, будь то зміна сімейства шрифтів, кольору, накреслення, ваги тощо.

Рядки, що являють собою масив символів (_літер, цифр, знаків_), які ми не називаємо текстом, але при відображенні називаємо саме так, можуть бути оброблені таким же підходом, але, на жаль, інтерпретація пішака у SA-MP не дозволяє багато чого (_поки що? Можливо, ніколи_), загалом, зміна кольору - це все, що ми можемо зробити, так, ви все ще можете змінювати/налаштовувати шрифт, але це лише на стороні клієнта, і так, [GTA San Andreas](<https://www>. rockstargames.com/sanandreas/) (_батьківська гра_) надає деякі додаткові шрифти, але це працює лише у [textdraws](../scripting/resources/textdraws) та [gametext](../scripting/functions/GameTextForPlayer), це спричиняє обмеження щодо представлення тексту, але ж минуло вже більше десяти років, і ми чудово пережили це.

### Оголошення рядків

Як я вже казав раніше, рядки - це, по суті, масиви символів, тому вони використовуються так само, як і масиви, і так само, як ми створюємо масив, ми створюємо рядок у такому форматі; `ім'я_рядка[розмір_рядка]`.

:::info

**назва_рядка**: назва масиву символів (_наприклад, string, str, message, text...тощо, якщо це допустима назва змінної (починається з символу або символу підкреслення)_).

**розмір_рядка**: максимальна кількість символів у цьому рядку.

:::

```cpp
// оголошення рядка з 5 символів
new str_1[5];

// оголошення рядка зі 100 символів
new str_2[100];
```

Ви також можете попередньо визначити константні значення, щоб використовувати їх багато разів як розміри рядків.

```cpp
// оголошення константи
#define STRING_SIZE 20

// оголошення рядка з розміром, рівним значенню STRING_SIZE
new str_3[STRING_SIZE];
```

:::примітка

Під час компіляції компілятор замінить всі входження `STRING_SIZE` на значення `20`, цей спосіб економить час і є більш читабельним у більшості випадків, майте на увазі, що значення, яке ви присвоюєте константі `STRING_SIZE` має бути цілим числом, інакше це призведе до помилки компіляції.

:::

На додаток до попередньо визначених констант, ви можете виконувати базові операції, однак оператор по модулю (`%`) призведе до помилок компіляції при використанні, ви все ще можете уникнути обчислень ділення (`/`), але майте на увазі, що ділення на `0` призведе до помилок, бонусом тут є те, що всі плаваючі результати будуть автоматично округлюватися для вас.

```cpp
// оголошення константи
#define STRING_SIZE 26

// оголошення рядків з використанням константи STRING_SIZE та деякі обчислення
new
  str_4[STRING_SIZE + 4],
  str_5[STRING_SIZE - 6],
  str_6[STRING_SIZE * 2],
  str_7[9 / 3];
```

Теоретично, ви можете створювати до смішного величезні масиви, але SA-MP накладає деякі обмеження на довжину рядків, з якими ви можете працювати, в залежності від того, над чим ви працюєте, вона обмежує кількість символів, які ви можете нормально виводити.

#### Обмеження довжини

SA-MP обмежує кількість символів, які можна зберігати в одному рядку, і не дає скриптерам перегинати палицю при роботі з текстом, на щастя, все не так погано, як може здатися, у списку нижче наведено деякі з цих обмежень;

| | | |
| ------------------- | ---------------------------------------------------------------------------------------------------------------------- | ---- |
Введення тексту | | Текст, який ви вводите в чаті.                                                                                        | 128 |
| Текст, який виводиться на екран клієнта.                                                                               | 144 |
| Ім'я. Нікнейм гравця / Ім'я користувача.                                                                                            | 24 |
| Текстовий рядок, що виводиться на екран.                                                                                               | 1024 |
**Діалогова інформація** | Текст, що відображається у всіх діалогах типу `DIALOG_STYLE_MSGBOX`, `DIALOG_STYLE_INPUT` та `DIALOG_STYLE_PASSWORD`. | 4096 |
| Підпис діалогового вікна ** Підпис/назва у верхній частині діалогового вікна.                                                                                | 64 |
| Введення діалогу** | Поле вводу для параметрів `DIALOG_STYLE_INPUT` та `DIALOG_STYLE_PASSWORD`.                                                     | 128 |
| Стовпчик діалогу** | Символи у кожному стовпчику `DIALOG_STYLE_TABLIST_HEADER` та `DIALOG_STYLE_TABLIST`.                             | 128 |
| Рядок діалогу** | Символи у кожному стовпчику `DIALOG_STYLE_TABLIST_HEADER`, `DIALOG_STYLE_TABLIST` та `DIALOG_STYLE_LIST`.        | 256 |
| Бульбашка чату ** Бульбашка чату, яка відображається над міткою імені гравця.                                                             | 144 |
| Заголовок меню** | Заголовок рідного меню GTA San Andreas (_здебільшого використовується для магазинів_).                                                      | 31 |
| Пункт меню** Пункт/рядок рідного меню GTA San Andreas (_здебільшого використовується для магазинів_).                                                    | 31 |

Якщо ці обмеження буде перевищено, це може спричинити певні незручності, у деяких випадках навіть призвести до аварійного завершення роботи сервера (_наприклад, довгі рядки_), у деяких інших випадках текст просто обрізатиметься, як-от заголовок меню (_якщо він сягає 32 символів, він обрізається до 30_) та пункти.

Окрім суворих обмежень, накладених на рядки, існує багато інших, що стосуються різних речей, ви можете переглянути повний список [тут](../scripting/resources/limits).

#### Присвоєння значень

Присвоєння значень рядкам може бути виконано багатьма методами, деякі присвоюють їх при створенні, інші - після, є люди, які використовують цикли, інші - функції, і так, є ті, хто виконує цей процес вручну, слот за слотом, не існує точного правильного чи неправильного способу, деякі методи часто є більш ефективними у деяких випадках, ніж інші, деякі - ні, в кінці кінців, все, що має значення - це продуктивність, оптимізація і читабельність.

У більшості випадків ви хочете надати рядку значення за замовчуванням при його створенні, це можна зробити наступним чином;

```cpp
новий
  message_1[6] = «Привіт»,
  message_2[] = «Це ще одне повідомлення»;
```

Переконайтеся, що розмір рядка більший за кількість символів, для яких ви їх виділили, менший або рівний розмір рядка призведе до помилок компіляції, залишення слоту між двома дужками порожнім (як у прикладі `message_2`), автоматично надасть масиву розмір тексту, для якого ви його виділили, плюс `1`, у цьому випадку `23 + 1 = 24`, чому? Він резервує місце для нульового символу (_так званого нуль-термінатора_), про це пізніше, слово «_Привіт_» має 5 символів, тому для того, щоб зберегти його у рядку, потрібно відвести 6 комірок, 5 комірок для кількості символів слова, і одну для **нульового символу**.

Давайте подивимось, як виконати той самий процес слот за слотом вручну, спочатку ми визначимо новий масив, ви можете визначити його розмір або залишити його порожнім, щоб компілятор заповнив його, обидва варіанти працюватимуть чудово, ми заповнимо масив символами, щоб створити рядок «_Hello_».

```cpp
// Включення розміру рядка при його оголошенні, інакше він не буде працювати
new message_3[6];

message_3[0] = 'H';
message_3[1] = 'e';
message_3[2] = 'l';
message_3[3] = 'l';
message_3[4] = 'o';
message_3[5] = '\0';
```

Тут ми призначили кожному слоту масиву `message_3` символ, це не спрацює, якщо ви оголосите sting без визначеного розміру, зверніть увагу, що для представлення одного символу, він повинен бути записаний між двома одинарними лапками (`'`), також зверніть увагу, що ми почали зі слоту 0, і це цілком природно, враховуючи, що я наголошував на тому, що рядок - це масив символів, тобто перший слот завжди дорівнює 0, а останній - його розмір мінус 1 (_нульовий символ не враховується_), що у нашому випадку дорівнює 4, рахуючи від 0 до 4, тобто 5 символів, а шостим є нульовий символ-термінатор, про який ми поговоримо згодом.

Ви також можете присвоювати рядкам номери, які будуть сприйматися як **ASCII** (_система числового представлення символів, охоплює 128 символів від 0 до 127, детальніше про це [тут](https://en.wikipedia.org/wiki/ASCII)_) код символу, те саме повідомлення «_Привіт_» може бути присвоєно за допомогою _ASCII_ коду ось так;

```cpp
new message_4[6];

message_4[0] = 72; // ASCII представлення великої літери h, «H»
message_4[1] = 101; // ASCII представлення «e»
message_4[2] = 108; // ASCII подання літери «l»
message_4[3] = 108; // ASCII представлення літери «l»
message_4[4] = 111; // ASCII представлення літери «o»
message_4[5] = 0; // ASCII представлення нульового термінатора
```

І так, ви можете виконувати числові операції з цими кодами так само, як і зі звичайними числами, адже машина сприймає символи як звичайні числа.

```cpp
new message_5[1];
message_5[0] = 65 + 1;
```

Якщо ви виведете `message_5[0]`, то отримаєте **B**, дивно, правда? Ну, ні, не зовсім, ви можете виконувати інші базові операції (_віднімання, множення, ділення і навіть модуль_), плаваючі числа будуть автоматично округлені, давайте подивимось, як це працює.

У вас є `65 + 1`, яка повертає `66`, перевіривши таблицю _ASCII_, ви побачите, що `66` - це числове представлення символу «_B_» (_з великої літери_). Отже, наведений вище фрагмент, по суті, те ж саме, що і виконати: `message_5[0] = 'B'`;

Для довідки використовуйте [цю таблицю ASCII](http://www.asciitable.com/).

Ви також можете виконати ту саму операцію між кількома символами або їх поєднанням, як символами, так і цифрами, ось декілька прикладів;

```cpp
new message_6[3];

message_6[0] = 'B' - 1; // Що дорівнює 66 - 1, повертає 65, числове представлення «A»
message_6[1] = 'z' - '&'; // Що дорівнює 122 - 38, повертає 84, числове представлення «T»
message_6[2] = '0' + '1'; // Що дорівнює 48 + 49, повертає числове представлення «a», зверніть увагу, що '0' і '1' - це не числа 0 і 1, а символи
```

Якщо ви ніколи не знали про систему _ASCII_, це може заплутати вас, але все, що вам потрібно - це трохи практики, тому що розуміння того, як вона працює, є дуже зручним.  
Код _ASCII_ не обмежується лише десятковими числами, ви також можете використовувати шістнадцяткові або двійкові числа у такий самий спосіб.

```cpp
new numString[4];

numString[0] = 0x50; // Десяткове число 80 у шістнадцятковій системі числення, з великої літери p, «P»
numString[1] = 0b1000001; // Десяткове число 65 у двійковій системі числення з великої літери a, «A»
numString[2] = 0b1010111; // Десяткове число 87 у двійковому записі з великої літери w, «W»
numString[3] = 0x4E; // Десяткове число 78 у шістнадцятковому форматі з великої літери n, «N»
```

Тепер давайте подивимось дещо інше, присвоювання значень через цикли, це буквально те ж саме, що і заповнення масиву через цикли, ви також можете використовувати всілякі методи циклів, виглядає наступним чином;

```cpp
// Заповнимо цей рядок великими літерами
new message_7[26];

// Цикл for
for (new i = 0; i < 26; i++)
  message_7[i] = 'A' + i;

// Цикл while
while (i++ < 'Z')
  message_7[i - 'A'] = i;

// Цикл do-while
new j = 'A';

do {
  message_7[j - 'A'] = j;
}
while (j++ < 'Z');

 // Ви навіть можете використовувати goto для імітації циклу, але це не рекомендується.
```

Всі три цикли виведуть один і той самий рядок, _ABCDEFGHIJKLMNOPQRSTUVWXYZ_.

Якщо наведені вище цикли здалися вам незрозумілими, можливо, ви захочете глибше ознайомитися з тим, як працюють цикли, докладніше про це можна прочитати [тут](../scripting/language/ControlStructures#loops) і [тут](https://wiki.alliedmods.net/Pawn_Tutorial#Looping). Зверніть увагу, як я використовував символи в деяких логічних умовах, наприклад, `j++ < 'Z'`, що легко перетворюється на `j++ < 90`, знову ж таки, символи розглядаються як числа, не дивуйтеся, ви можете перевірити таблицю _ASCII_, коли захочете.

Скажімо, ви хочете заповнити рядок числом з одного конкретного символу, (наприклад «_AAAAAA_», “_TTTTTT_”, “_vvvvvv_”, “_666_” (_ні, це не збіг_)), типова ідея, яка може спасти на думку більшості скриптерів, це жорстке кодування, але як щодо довгих рядків, ну, як щодо використання циклу, це теж добре, але що, якщо я скажу вам, що є ще більш ефективний спосіб, так само як ви заповнюєте масив одним і тим же значенням, ви можете зробити те ж саме для рядків.

```cpp
new message_8[100] = {'J', ...};
```

Вищенаведений код оголошує новий рядок `message_8` зі 100 комірками (_в діапазоні від 0 до 99_) і присвоює кожному слоту значення `'J'`, яке, звичайно, можна використовувати як символ **J**, так і число **74** за системою _ASCII_.

Ще одна річ, яку ви можете зробити з цим - заповнити рядок символами, значення яких базуються на інтервалах, див. приклад з великими літерами від _A_ до _Z_ вище? Давайте створимо такий самий рядок за допомогою цього методу.

```cpp
new message_9[26] = {'A', 'B', ...};
```

Наскільки це просто?! Це і більш оптимізовано, і легко читається, і дає ті ж результати, що і 3 приклади, зроблені з використанням методів циклу вище, так як же це працює? Ну, ми дали рядку початкові значення, `'A'` і `'B'`, а це відповідно _65_ і _66_, компілятор обчислює інтервал між цими двома значеннями, який у даному випадку дорівнює _1_, і завершує заповнення порожніх комірок значеннями на основі цього інтервалу, поки не заповнить весь масив, ви можете поставити стільки початкових значень, скільки хочете, але він буде враховувати тільки інтервал між двома останніми значеннями, і працюватиме на його основі, майте на увазі, що початкові значення розглядаються як _ASCII_ код, тому спроба вивести числові інтервали цим методом в рядок призведе до чогось незручного, скажімо, ви оголосили якийсь випадковий рядок ось так;

```cpp
new rand_str[5] = {'1', '5', ...};
```

В ідеалі, він мав би вивести **151520** (_точніше «1 5 15 20»_), але замість цього він виведе; **159=A**, що насправді є правильним виводом, чому? Тому що пам'ятайте, це _ASCII_ код, '_1_' - це _49_, а '_5_' - це _53_, інтервал між ними _4 (53 - 49)_, рядок приймає 5 символів, ми вже зайняли дві комірки, коли додали початковий каталог, тому залишилося 3 порожні комірки, які потрібно заповнити з дотриманням інтервалу у 4, ось як це виглядає **[ 49 | 53 | 57 | 61 | 65 ]**, замінимо кожне числове значення на відповідний йому _ASCII_ код. **[ '1' | '5' | '9' | '=' | 'A']**, має більше сенсу, га?!

## Нульовий термінатор

Я вже згадував про це у перших розділах цього підручника, сподіваюся, що спочатку це було не надто заплутано, але навіть якщо так, давайте розберемося з цим, не хвилюйтеся, в цьому немає нічого складного або навіть просунутого, просто базовий факт, про який ви повинні знати, я постараюся бути якомога коротшим, але якщо ви хочете дізнатися про це глибше, ви можете відвідати [цю статтю](https://en.wikipedia.org/wiki/Null_character).

Отже, нульовий термінатор (_так званий нульовий символ_) - це символ, присутній у всіх рядках, його роль полягає в тому, щоб вказати, що рядок закінчився, ви можете думати про нього як про крапку (.), все, що йде після цього символу, не враховується і повністю ігнорується. Ви не можете ввести його з клавіатури, але можете посилатися на його значення під час кодування, він присутній у таблиці _ASCII_, але називається _NUL_ і позначається цифрою 0.

У _pawn_ ви можете ввести його як числове значення, або як символ '_\0_'. Зворотна коса риска тут діє як екрануючий символ, вона вказує машині, що цей символ є нульовим символом зі значенням 0 і **НЕ** символом `'0'`, який має значення `48`.

У _pawn_ використовується символ **EOS**, скорочено від **E**nd **O**f **S**tring, це попередньо визначений макрос для нульового термінатора, ви можете встановити нульовий термінатор багатьма різними способами;

```cpp
message_9[0] = 0;
message_9[0] = '\0';
message_9[0] = 0b; // Десяткове число 0 у двійковій системі числення
message_9[0] = 0x00; // Десяткове число 0 у шістнадцятковій системі числення
message_9[0] = _:0.0; // Число з плаваючою комою 0.0, щоб уникнути помилок компіляції, перед ним потрібно поставити детекст '_'
message_9[0] = false;
message_9[0] = EOS;
```

Як я вже говорив раніше, ви можете проігнорувати присвоєння нульового символу, але він завжди присутній у порожніх комірках, коли ви оголошуєте новий рядок, всі його комірки автоматично заповнюються нульовим термінатором, тому, наприклад, якщо я оголошу цей рядок `text[3]`, всі його комірки за замовчуванням отримають значення `0`, ось просте візуальне представлення вмісту рядка;

| | | | |
| ---------- | ---- | ---- | ---- |
| Клітинки 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 25 26 27 28 29
| ASCII код 0 0 0 0 0 0
| Символи | '\0' | '\0' | '\0' | '\0'

Ось ще один приклад попередньо заповненого рядка.

```cpp
new text_1[8] = «Привіт»;
```

Ось вміст рядка в кожній комірці;

| | | | | | | | | |
| ---------- | --- | --- | --- | --- | --- | ---- | ---- | ---- |
| Клітинки 0, 1, 2, 3, 4, 5, 6, 7
| ASCII код 72, 101, 108, 108, 111, 0, 0, 0, 0
| Символи | 'H' | 'e' | 'l' | 'l' | 'o' | '\0' | '\0' | '\0' | '\0'

Якщо ви, наприклад, хочете видалити вміст цього рядка, ви можете просто зробити це за допомогою одного з трьох наведених нижче прикладів;

```cpp
text_1[0] = 0;
text_1[0] = EOS;
text_1[0] = '\0';
```

Пропуск рядка через рентгенівське сканування виведе наступне;

| ---------- | ---- | --- | --- | --- | --- | ---- | ---- | ---- |
| Клітинки 0, 1, 2, 3, 4, 5, 6, 7
ASCII код | 0 | 101 | 108 | 108 | 108 | 111 | 0 | 0 | 0 | 0 | 0
Символи | '\0' | 'e' | 'l' | 'l' | 'o' | '\0' | '\0' | '\0' | '\0' | '\0'

Якщо ви спробуєте вивести цей рядок, то все, що знаходиться за номером слоту 0, буде проігноровано і позначено як порожній рядок, навіть функція `strlen` поверне 0, оскільки вона залежить від розміщення нульового символу для отримання довжини рядка.

## Функції маніпулювання рядками

Коли справа доходить до роботи з кількома фрагментами тексту, _pawn_ має все необхідне, він надає деякі базові функції, які ефективно виконують роботу, немає необхідності створювати власні, коли є вбудована підтримка, яка забезпечує швидкість та оптимізацію.

Ось деякі функції з вбудованою підтримкою (_взято з string.inc_);

```cpp
native strlen(const string[]);
native strpack(dest[], const source[], maxlength=sizeof dest);
native strunpack(dest[], const source[], maxlength=sizeof dest);
native strcat(dest[], const source[], maxlength=sizeof dest);
native strmid(dest[], const source[], start, end, maxlength=sizeof dest);
native bool: strins(string[], const substr[], pos, maxlength=sizeof string);
native bool: strdel(string[], start, end);
native strcmp(const string1[], const string2[], bool:ignorecase=false, length=cellmax);
native strfind(const string[], const sub[], bool:ignorecase=false, pos=0);
native strval(const string[]);
native valstr(dest[], value, bool:pack=false);
native bool: ispacked(const string[]);
native uudecode(dest[], const source[], maxlength=sizeof dest);
native uuencode(dest[], const source[], numbytes, maxlength=sizeof dest);
native memcpy(dest[], const source[], index=0, numbytes, maxlength=sizeof dest);
```

Ми розглянемо лише деякі з них, ті, що використовуються найчастіше.

- Функція `strlen` (це і `sizeof` - абсолютно різні речі), яка приймає рядок як параметр, повертає довжину цього рядка (кількість символів у ньому), але будьте уважні, оскільки це трохи складно, як вона працює, я говорив про це раніше в підручнику, ця функція залежить від позиції нульового символу для визначення довжини рядка, тому будь-який інший допустимий не нульовий символ, який йде після, не буде враховано, як тільки досягається перший нульовий символ, функція повертає кількість комірок від початку до цього нульового символу.

- Функція `strcat` об'єднує рядки один з одним, приймає 3 параметри.

  ```cpp
  new str_dest[12] = «Hello», str_source[7] = « World»;
  strcat(str_dest,str_source);
  ```

  Якщо ми виведемо `str_dest`, то побачимо **Hello World**, два рядки були додані один до одного, і результат був збережений в `str_dest`, _«Hello» + « World» = «Hello World»_, зверніть увагу, як ми включили пробіл у другий рядок, так, пробіли самі по собі є символами, згідно з таблицею _ASCII_, їх значення `32`, якби ми не додали пробіл, то отриманий рядок був би **HelloWorld**.

- Функція `strval` перетворить рядок у число, наприклад, наступний рядок `«2017»` буде перетворено у число `2017`, вона працює зі знаковими та беззнаковими числами, якщо рядок не містить цифрових символів, функція поверне `0`, те саме відбувається, якщо рядок містить цифрові символи, але починається з нецифрових, якщо рядок починається з цифрових символів, але містить і нецифрові символи, цифрові символи все одно буде знайдено та перетворено, ось кілька прикладів використання;

  ```cpp
  strval(«2018»); // Повертає «2018».
  strval(«-56»); // Повертає «-56».
  strval(«17.39»); // Повертає «17», плаваюче число 17.39 отримано автоматично.
  strval(«no number here»); // Повертає «0».
  strval(«6 починається»); // Повертає «6».
  strval(«ось і 2018 рік»); // Повертає «0».
  strval(«2017 рік закінчився, вітаємо 2018»); // Повертає «2017».
  ```

:::підказка

Існує багато бібліотек, створених спільнотою, які можна завантажити для роботи з рядками, і я не можу придумати кращої, ніж [strlib](https://github.com/oscar-broman/strlib).

:::

### Функція форматування

Це, мабуть, найпоширеніша функція, пов'язана з рядками у спільноті, дуже проста і зручна, все, що вона робить, це форматує фрагменти тексту і об'єднує їх разом, її можна застосовувати у різних ситуаціях, наприклад, для зв'язування змінних і рядків, вбудовування кольорів, додавання розривів рядків... і т.д.

```cpp
format(output[], len, const format[], {Float, _}:...)
```

Функція format приймає як параметри масив виводу, його розмір (_кількість комірок_), рядок форматування (_він може бути попередньо збережений в іншому масиві, або безпосередньо присвоєний зсередини функції_), і, нарешті, деякі необов'язкові параметри, які можуть бути змінними різних типів. Давайте використаємо цю функцію для присвоєння значення порожньому рядку.

```cpp
new formatMsg[6];
format(formatMsg, 6, «Hello»);
```

На виході `formatMsg` виводить **Hello**, майте на увазі, що це поганий спосіб присвоєння значень рядкам, в основному через його швидкість, для цього існують кращі методи, ми вже обговорювали деякі з них на ранніх етапах цього підручника.

Не забувайте завжди вказувати правильний розмір масиву, інакше він працюватиме, але це призведе до небажаної поведінки, функція форматування переповнить розмір вашого масиву, а повірте мені, ви не хочете, щоб це сталося, якщо ви не хочете турбуватися про встановлення правильного розміру рядка кожного разу, коли ви хочете працювати з цією функцією, ви можете просто використовувати функцію `sizeof` (_це не функція як така, а скоріше директива компілятора_), ми бачили раніше функцію під назвою `strlen`, яка повертає кількість символів у рядку (_виключаючи нульовий символ_), але ця функція повертає розмір масиву, іншими словами, кількість комірок у масиві, незалежно від того, заповнені вони дійсними символами чи ні, у цьому випадку 6.

```cpp
new formatMsg[6];
format(formatMsg, sizeof(formatMsg), «Hello»);
```

Текст завжди слід брати у подвійні лапки, проте існує незвичайний спосіб введення тексту, який рідко використовується, він використовує символ знаку числа `#` і працює наступним чином:

```cpp
new formatMsg[6];
format(formatMsg, sizeof(formatMsg), #Hello);
```

Він підтримує пробіли, екрановані символи, і ви навіть можете використовувати комбінацію подвійних лапок і знака числа;

```cpp
new formatMsg[6];
format(formatMsg, sizeof(formatMsg), «Hello »#World);
```

Вищенаведений код введе **Hello World**, такий спосіб введення рядків більш відомий як використання з попередньо визначеними константами. Давайте розглянемо приклад використання двох різних констант, одна з яких є цілим числом `2017`, а інша - рядком `«2018»`.

```cpp
#define THIS_YEAR 2018 // Ця константа має значення ціле число
#define NEW_YEAR «2019» // Ця константа має значення рядок

new formatMsg[23];
format(formatMsg, sizeof(formatMsg), «Це “#THIS_YEAR”, а не »NEW_YEAR);
```

Це виведе **Це 2018 рік, а не 2019**, причина, чому я наголосив на двох константах різних типів - це використання знаку числа `#`, якщо значення **НЕ** рядок, то ви повинні додати до нього знак числа `#THIS_YEAR`, щоб він сприймався як `«2018»`, інакше ви отримаєте помилки компіляції, що стосується рядкового значення, то ви можете додати або опустити знак числа, тому що він буде працювати в будь-якому випадку (`NEW_YEAR` - це те ж саме, що і `#NEW_YEAR`). Ви можете використовувати цю команду лише для отримання значень з попередньо визначених констант, вона не працюватиме зі звичайними змінними або масивами/рядками, оскільки з ними можна працювати за допомогою заповнювачів, докладніше про це буде сказано пізніше.

Ви також можете вишикувати скільки завгодно подвійних лапок одна біля одної, хоча це не має сенсу, оскільки природніше просто записати речення в одній парі подвійних лапок, ось приклад того самого речення, записаного в обох концепціях;

```cpp
new formatMsg[29];

// Одна єдина пара подвійних лапок
format(formatMsg, sizeof(formatMsg), «Це реальність...чи ні?!»);

// Кілька пар подвійних лапок
format(formatMsg, sizeof(formatMsg), «Це реальність»«...»«чи ні?!»);
```

Обидва варіанти виведуть одне і те ж речення, **Це реальність... чи ні?!**.

## Поради щодо оптимізації

Тепер, коли ми розглянули деякі базові речі про оголошення рядків, маніпуляції ... і т.д., дехто з нас просто порине у практику, не звертаючи уваги на деякі загальні рекомендації, яких дотримується спільнота, якби більше людей дбали про читабельність, оптимізацію та продуктивність, світ був би кращим місцем. код, який добре компілюється, не означає, що він добре працює, більшість помилок виникають через ті дрібниці, які ми проґавили або створили таким чином, що вони не будуть дружелюбно взаємодіяти з іншими системами. добре написаний код переживе випробування часом, але яким чином? Ви завжди зможете повернутися до нього, налагодити, виправити, переглянути його з легкістю, оптимізація також відобразиться на продуктивності, завжди намагайтеся отримати найкраще від вашої машини, і оптимізований код - це шлях до успіху.

Перше, про що слід згадати, і що особисто мене викликає занепокоєння, це те, як створюються великі рядки, коли навіть половина оголошених комірок не використовується, оголошуйте рядки тільки того розміру, який ви будете використовувати, зайві комірки тільки забиратимуть більше пам'яті, давайте подивимось на нібито неоптимізований спосіб оголошення рядка.

```cpp
new badString[100];
badString =«Hello :)»;
```

Ми оголосили рядок з _100_ комірками_, _1 комірка_ займає _4 байти_, давайте порахуємо, _100 \* 4 = 400_ байт, це приблизно _0.0004 мегабайта_, нічого за сьогоднішніми мірками, я знаю, але на величезному скрипті, очевидно, доведеться використовувати більше одного рядка, _60_, _70_, чорт забирай _100_ більше рядків? (_можливо більше_), ці крихітні числа накладатимуться одне на одне, що призведе до набагато більшого числа, і спричинить вам серйозні проблеми пізніше, і повірте мені, коли я скажу вам, що рядок, який ми оголосили, навіть близько не буде виглядати безглуздо у порівнянні з тими, що мають розмір у п'ять разів більший або більше.

Що я зустрічаю частіше, що є стереотипно невизначеним, так це використання загадкового розміру струни -256-, але чому саме люди? Чому?

Пам'ятайте про обмеження, які SA-MP накладає на роботу з рядками, де тут з'являється _256-довгий_ рядок? Що ви збираєтеся робити з рядком такої довжини (_крім форматування діалогового вікна/рядка виведення тексту_)? Максимальний вхідний рядок має довжину _128è символів, це половина розміру, \_512 байт_ просто зникає, скажіть, що? Ви збиралися використовувати його для виводу, а не вводу? Це все одно занадто багато, вихідні рядки не повинні передавати _144_ символів, розумієте, до чого я веду? Давайте спробуємо виправити нашу помилку, у нас є речення «Хороший рядок», воно містить _11_ символів (_пробіл теж вважається символом_) + _1_ для нульового термінатора (_треба завжди мати цього чувака на увазі_), разом виходить _12_ символів.

```cpp
new goodString[12];
goodString=«Хороший рядок»;
```

Бачите, як ми зекономили пам'ять? Лише **48** байт, і ніякої зайвої ваги, яка може спричинити проблеми у майбутньому, відчувається набагато краще.

Але що, якщо я скажу вам, що ви можете отримати ще більш оптимізований код, так, ви коли-небудь чули про **упаковані рядки**? Рядок зазвичай формується з декількох комірок, і, як ми вже говорили раніше, кожна комірка представляє 4 байти, тому рядки складаються з декількох наборів по _4 байти_. Один символ займає 1 байт, і кожна комірка дозволяє зберігати лише один символ, тобто на кожну комірку витрачається 3 байти,

```cpp
new upkString[5];
upkString = «pawn»;
```

Наведений вище рядок, що займає 5 комірок (_приблизно 20 байт_), можна звузити до 8 байт, тобто до 2 комірок.

```cpp
new pkString_1[5 char];

pkString_1 = !«pawn»;
// або
pkString_1 = !#пішак;
```

Ось як це працює, ви оголошуєте рядок з розміром, який він зазвичай займає (_враховуючи нуль-термінатор звичайно_), потім додаєте до нього ключове слово with `char`, кожен символ буде зберігатися в байтах, а не в комірках, це означає, що в кожній комірці буде зберігатися 4 символи, пам'ятайте, що при присвоюванні значень упакованим рядкам, додавайте до них знак оклику `!`, це, втім, не стосується окремого символу.

Це приблизне візуальне представлення вмісту `upkString`;

| | | | | | |
| ---------- | -------------------- | -------------------- | -------------------- | -------------------- | ----------------- |
| Клітинка 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 25 26 27 27 28 29
| Байт | 0 . 1 . 2 . 3 | 0 . 1 . 2 . 3 | 0 . 1 . 2 . 3 | 0 . 1 . 2 . 3 | 0 . 1 . 2 . 3 |
| Символи \0 . \0 . \0 . **p** | \0 . \0 . \0 . **a** | \0 . \0 . \0 . **w** | \0 . \0 . \0 . **n** | \0 . \0 . \0 . \0 |

А ось як виглядатиме `pkString_1` у другому прикладі;

| | | |
| ---------- | ----------------------------- | ----------------- |
| Комірка 0 1
| Байт | 0 . 1 . 2 . 3 | 0 . 1 . 2 . 3 |
| Символи **p** . **a** . **w** . **n** | \0 . \0 . \0 . \0 |

Ви також можете отримати доступ до індексаторів упакованого рядка наступним чином;

```cpp
new pkString_2[5 char];

pkString_2{0} = 'p';
pkString_2{1} = 97; // ASCII код символу «a».
pkString_2{2} = 0b1110111; // Десяткове число 199 у двійковому вигляді, переводиться у символ «w».
pkString_2{3} = 0x6E; // Десяткове число 110 у шістнадцятковій системі числення, переводиться у символ «n».
pkString_2{4} = EOS; // EOS (End Of String), має значення 0, що є ASCII кодом \0 (NUL), нульового символу.
```

Результат буде таким же, як і `pkString_1`, в цьому випадку, як бачите, _ASCII_ код все ще враховується, зверніть увагу, що при зверненні до індексаторів на упакованих рядках ми використовуємо **фігурні дужки** замість **дужок**. Це означає, що ми індексуємо самі байти, а не комірки.

:::info

Незважаючи на свою ефективність у збереженні пам'яті, реалізація pawn у SA-MP не підтримує упаковані рядки на 100%, але ви все одно можете використовувати їх у рідковживаних рядках/масивах.

:::

## Виведення рядка

#### Консоль

##### `print`

Наступна функція є, мабуть, найпростішою функцією не тільки в pawn, але й у багатьох інших мовах програмування, вона просто приймає один параметр і виводить його на консоль.

```cpp
print(«Hello world»);
```

```
Привіт, світе
```

Ви також можете передавати заздалегідь оголошені рядки або заздалегідь визначені константи, а також об'єднувати декілька з них разом, або використовувати знак числа `#`, як ми звикли робити з функцією format, але майте на увазі, що це не включає декілька параметрів, ми можемо передавати лише один параметр.

```cpp
#define HAPPY_STRING «Я сьогодні щасливий» // Рядкова константа.
#define NEW_YEAR 2019 // Цілочисельна константа.
new stylishMsg[12] = «Я стильний»;

print(HAPPY_STRING);
print(stylishMsg);
print(#2019 рік за обрієм);
print(«Я з нетерпінням чекаю на #NEW_YEAR»); print("Я з нетерпінням чекаю на #NEW_YEAR);
print(«Що “про” тебе?»);
```

```
Я сьогодні щаслива
Я стильна
2019 рік вже за обрієм
Я з нетерпінням чекаю на 2019 рік
А ти?
```

Зверніть увагу, що ми використали тут символ числа так само, як і у функції format, якщо значення є цілим числом, ви додаєте до нього префікс `#`, щоб воно сприймалося як рядок.

Також майте на увазі, що функція `print` підтримує упаковані рядки, однак приймає тільки змінні рядкового типу (_масив символів_), передача чогось, що не є масивом, рядком (_чи то між подвійними лапками, чи з префіксом символу числа_) призведе до помилок компіляції, тому жодне з наведених нижче дій не працюватиме;

```cpp
// Випадок 1
new _charA = 'A';
print(_charA);

// Випадок 2
new _charB = 66;
print(_charB);

// Випадок 3
print('A');

// Випадок 4
print(66);
```

Давайте подивимось, як це можна виправити;

```cpp
// Випадок 1
new _charA[2] = «A»;
print(_charA);
```

Ми змінюємо одинарні лапки на подвійні і даємо масиву дві комірки, одна з яких містить символ A, а друга - нульовий термінатор, оскільки все, що знаходиться між подвійними лапками, є рядком, виводимо **A**.

```cpp
// Випадок 2
new _charB[2] = 66;
print(_charB);
```

Змінюємо `_charB` на масив з однією коміркою і встановлюємо комірці з міткою 0 значення `66`, що відповідно до таблиці _ASCII_ переводиться в **B**, виводимо **B**, зберігаємо додаткову комірку для нуль-термінатора (_скільком там треба, щоб вже не було смішно?_).

```cpp
// Випадок 3
print(«A»);
```

Тут мало що можна сказати, все, що потрібно було зробити, це перейти від одинарних лапок до пари подвійних лапок.

Що стосується четвертого випадку, то тут ми мало що можемо зробити, працюючи з функцією `print`, але його можна просто вирішити за допомогою іншої схожої функції, яка викликається...

##### `printf`

Скорочено від «_друк з форматуванням_», можна сказати, що це більш різноманітна версія попередньої функції `print`, точніше, це щось середнє між функцією `format` і функцією `print`, тобто вона також виводить символи на консоль сервера, але з перевагою форматування виведеного тексту.

На відміну від `print`, `printf` приймає декілька параметрів, до того ж різних типів, але не підтримує упаковані рядки, для розширення функціональності ми використовуємо послідовності, які називаються «специфікаторами формату», про них пізніше, виведення більш ніж **1024** символів призведе до <u>краху сервера</u>, тому зверніть увагу на це.

```cpp
#define RANDOM_STRING «Vsauce»
#define RANDOM_NUMBER 2018

printf(«Привіт, “RANDOM_STRING”, це Майкл! #»#RANDOM_NUMBER);
```

Зверніть увагу, як ми, подібно до функцій `print` і `format`, вклали ці рядки в один, який виводить наступне;

```
Привіт, Соус, це Майкл! #2018
```

Функція `printf`, як я вже казав, дійсно блищить, коли використовуються **специфікатори формату**, це те, що відрізняє її і виділяє, ви можете приєднати стільки змінних, скільки хочете, і виводити прості і складні рядки з легкістю, ми розглянемо це набагато глибше, коли познайомимося з цими специфікаторами пізніше.

#### Повідомлення клієнта

Окрім інших текстів ляльок, які ви можете надрукувати на консолі сервера, і які в основному використовуються для налагодження, є повідомлення, які друкуються на екрані клієнта, у розділі чату, їх можна форматувати так само, але вони також підтримують вбудовування кольорів, що забезпечує чудову презентацію текстів (_якщо їх правильно використовувати, звісно_).

Майте на увазі, що обмеження SA-MP на відображення рядків поширюються і на цей тип повідомлень, вони, як і попередні, обмежені довжиною до _144 символів_, інакше повідомлення не буде надіслано, а іноді вони навіть призводять до аварійного завершення деяких команд.

Існує дві функції, які виводять текст на екран клієнта, різниця між ними лише в черпаку, перша приймає три параметри, ідентифікатор гравця, на екрані якого ви хочете надрукувати текст, колір тексту і сам текст.

```cpp
SendClientMessage(playerid, color, const message[])
```

Скажімо, ви хочете надіслати гравцеві з ідентифікатором 1 повідомлення «Привіт!»;

```cpp
SendClientMessage(1, -1, «Привіт!»);
```

Все просто, гравцеві з ідентифікатором 1 буде надіслано повідомлення «Привіт!», `-1` - це параметр кольору, в даному випадку це колір **white**, про кольори поговоримо пізніше.

Очевидно, що ви також можете передати масив символів, відформатовані рядки...тощо. І, як ми бачили з іншою функцією, ви можете використовувати знак числа `#`.

```cpp
#define STRING_MSG «today»
new mornMsg[] = «Привіт!»;

SendClientMessage(0, -1, mornMsg);
SendClientMessage(0, -1, «How are you »,STRING_MSG#?);
```

Як ви можете бачити на прикладі вище, це надішле гравцеві з ідентифікатором _0_ два повідомлення, забарвлених у білий колір, перше повідомлення буде «_Привіт!_», а друге - «_Як справи сьогодні?_», досить схоже на те, як працюють інші функції. Пам'ятайте, що перед визначеними константними цілими числами слід ставити символ `#`.

```cpp
#define NMB_MSG 3
SendClientMessage(3, -1, «Це “#NMB_MSG” PM»);
```

Зрозуміло, що текст буде надіслано гравцеві з ідентифікатором _3_, виділеним білим кольором, з текстом «_Зараз 3 години дня_».

Тепер, коли ви знаєте, як відправити комусь повідомлення, ви можете використовувати той самий підхід, щоб відправити те саме повідомлення всім, насправді це дитяча гра, ви можете просто помістити функцію в цикл, який проходить через всіх підключених гравців, і ризикнути показати свій код публічно і закінчити на цьому, але ж вже є нативна функція, яка робить те саме, застосовуються ті самі правила, єдине, чим вони відрізняються - це невелика зміна в синтаксисі.

```cpp
SendClientMessageToAll(color, const message[]);
```

теж досить зрозумілий, що випливає з його назви, тепер давайте надішлемо всім на сервері вітальне повідомлення.

```cpp
SendClientMessageToAll(-1, «Всім привіт!»);
```

Ось так, ви можете грати з ним так само, як і з іншим його братом, дві іграшки від одного бренду, просто намагайтеся не перевищувати ліміт у 144 символи.

#### Textdraws

Одна з найпотужніших функціональних можливостей SA-MP, просто дайте волю своїй уяві, текстові малюнки - це графічні фігури/тексти/спрайти/моделі попереднього перегляду... і т.д., які можна відображати на екранах клієнтів, вони роблять інтерфейс користувача набагато більш живим та інтерактивним (_до певної міри_). Але і тут є обмеження, наприклад, ви не можете відобразити рядок довжиною більше 1024 символів, чесно кажучи, цього більш ніж достатньо. Нічого особливого тут сказати не можна, навіть попри широкі функціональні можливості, рядки, які можна виводити, погано форматуються, ви не можете зробити так багато, як могли б за допомогою інших функцій виводу, це відчувається трохи вузько, коли справа доходить до цього, але це, безумовно, компенсується відсутністю форматування іншими цікавими речами, більше про textdraws [тут](../scripting/resources/textdraws).

#### Діалоги

Діалоги можна уявити як «_скриньки повідомлень_», вони, звісно, бувають різних типів, приймають небагато різних вхідних даних і, що важливіше, приймають усі типи форматування, які підтримує звичайний рядок, що робить їх набагато простішими у використанні, ніж textdraw. Щодо них також існують певні обмеження, такі як розмір рядків та можливість лише синхронного відображення їх на екрані клієнта, SA-MP надає лише одну власну функцію для роботи з діалогами, і, чесно кажучи, це буде однією з ваших останніх проблем, оскільки ця функція виконує свою роботу, і робить це ефективно, більше про діалоги [тут] (../scripting/functions/ShowPlayerDialog).

### Інтерпретація кольорів

#### Клієнтські повідомлення та діалоги

##### RGBA

**RGBA** (_скорочення від red green blue alpha_), є простим використанням моделі **RGB** з додатковим каналом, альфа-каналом, по суті, формою представлення кольорів у цифровому вигляді, шляхом змішування варіацій червоного, зеленого, синього та альфа (_непрозорості_), більше про це [тут](https://en.wikipedia.org/wiki/RGBA_color_space).

У реалізації пішака SA-MP ми використовуємо шістнадцяткові числа для представлення цих колірних просторів, червоний, зелений, синій і альфа відводиться по 2 біти, в результаті чого виходить 8-бітове шістнадцяткове число, наприклад; (_FF0000FF = червоний_), (_00FF00FF = зелений_), (_0000FFFF = синій_), (_000000FF = чорний_), (_FFFFFFFF = білий_), ось більш наочна візуалізація цієї нотації:

> <span style={{ color: 'red' }}>FF</span><span style={{ color: 'green' }}>FF</span><span style={{ color: 'blue' }}>FF</span><span style={{ color: 'grey' }}>FF</span>

У багатьох мовах програмування/скриптів до шістнадцяткових чисел додається знак `#`, у пішаку, однак, ми додаємо до них `0x`, тому наступне шістнадцяткове число _8060C1FF_, стає _0x8060C1FF_.

Звичайно, ми можемо використовувати десяткові числа для представлення кольорів, але набагато зрозуміліше використовувати шістнадцяткову систему числення, оскільки вона є більш читабельною між ними, давайте розглянемо наступний приклад;

```cpp
// Представлення білого кольору десятковими числами
SendClientMessageToAll(-1, «Привіт усім!»);

// Представлення білого кольору шістнадцятковими числами
SendClientMessageToAll(0xFFFFFFFFFF, «Hello everyone!»);

// Клієнтське повідомлення, пофарбоване в білий колір, буде надіслано всім
```

Майте на увазі, що присвоєння всім бітам однакового значення призведе до варіацій відтінків сірого (_без каламбуру_), а присвоєння альфа-каналу значення 0 зробить текст невидимим.

:::підказка

Можна одночасно форматувати тексти з декількома кольорами, але для цього ми вбудовуємо простішу нотацію **RGB**.

:::

##### RGB

Це такий самий кольоровий простір, як і **RGBA**, але без альфа-каналу, лише суміш червоного, зеленого та синього кольорів, позначена шістнадцятковим числом з 6 біт, в пішаку ця нотація використовується переважно для вбудовування кольорів у тексти, просто оберніть ваше 6-бітове шістнадцяткове число між парою фігурних дужок, і все готово, наприклад, для роботи з текстом; (**{FF0000} = червоний**), (**{00FF00} = зелений**), (**{0000FF} = синій**), (**{000000} = чорний**), (**{FFFFFF} = білий**), ось більш наочна візуалізація цієї нотації: `{FFFFFF}`. Давайте подивимось на цей короткий приклад тут;

```cpp
SendClientMessageToAll(0x00FF00FF, «Я зелений{000000}, а {FF0000} я червоний»);
```

Це надішле наступне повідомлення всім (_і я не італієць_):

> <span style={{color: '#00ff00ff'}}>Я зелений</span><span style={{color: '#ffffff'}}>, і </span><span style={{color: '#ff0000'}}>Я червоний</span>

Майте на увазі, що шістнадцяткова система числення не чутлива до регістру, тому `0xFFC0E1FF` - це те саме, що `0xfFC0e1Ff`, те саме стосується вбудованих кольорів, `{401C15}` - це те саме, що `{401c15}`.

Іноді робота з кольорами може виявитися досить важкою, не так просто запам'ятовувати всі ці довгі шістнадцяткові числа, це не так вже й складно, ви завжди повинні мати посилання, до якого можна повернутися, є багато онлайн пікаперів кольорів, якими ви можете скористатися, ви можете просто загуглити «_колірний пікапер_» і вибрати з тисяч, дозвольте мені зробити це за вас, якщо ви не заперечуєте, [ось простий інструмент] (<https://www.webpagefx.com/web-design/color-picker/>), яким я рекомендую користуватися при роботі з кольорами.

Однією з проблем, з якою стикаються люди, є управління робочим процесом, яке, якщо все зроблено правильно, полегшує темп роботи і робить роботу над проєктами менш болісною, хоча інструменти для вибору кольорів дуже допомагають, ви все одно можете витратити багато часу, повертаючись до них кожного разу, коли вам потрібно вибрати колір, розчарування від цього може бути таким же дратівливим, як піца з ананасами, на щастя, ви можете скористатися перевагами попередньо визначених констант і визначити кольори, які ви найчастіше використовуєте, для подальшого використання, ось вам простий приклад;

```cpp
#define COLOR_RED 0xFF0000FF
#define COLOR_GREEN 0xFF0000FF
#define COLOR_BLUE 0xFF0000FF

SendClientMessageToAll(COLOR_RED, «Я - червоний текст»);
SendClientMessageToAll(COLOR_GREEN, «Я - зелений текст»);
SendClientMessageToAll(COLOR_BLUE, «Я - синій текст»);
```

Останнє можна зробити і для вбудованих кольорів;

```cpp
#define COL_RED «{FF0000}»
#define COL_GREEN {FF0000}
#define COL_BLUE «{FF0000}»

SendClientMessageToAll(-1, «»COL_RED «Я - червоний текст»);
SendClientMessageToAll(-1, «{»COL_GREEN}«Я зелений» «COL_BLUE “і синій”);
ShowPlayerDialog(playerid, 0, DIALOG_STYLE_MSGBOX, «Notice», «{»COL_GREEN"}Привіт! «COL_RED«}що сталося?», «Закрити», «»);
```

Під час компіляції всі попередньо визначені константи будуть замінені їх значеннями, і таким чином, цей `«COL_RED “Я червоний текст” стане таким`»{FF0000}«Я червоний текст», зверніть увагу, що ми використали два методи для визначення цих кольорів, `RRGGBB` і `{RRGGBB}`, це залежить від особистих уподобань, яким методом користуватися, особисто я вважаю, що визначення їх як `RRGGBB` набагато зрозуміліше, оскільки використовуються фігурні дужки, і таким чином стає помітно, що ми вбудовуємо колір.

Таким був загальний підхід до вбудовування кольорів у рядки діалогів та клієнтських повідомлень, можна використовувати кольори у тексті клієнтських повідомлень, діалогів, 3D-текстових міток, текстів матеріалів об'єктів та номерних знаків транспортних засобів, але, до речі, у SA-MP також є функції малювання текстів та геймтекстів, однак вони не підтримують нотацію RGB, а отже, додавання кольорів відбувається по-іншому.

#### Текстові малюнки та ігрові тексти

Як згадувалося вище, нотація **RGB** не підтримується, але, на щастя, у нас є інші способи обійти цю проблему, для текстових малюнків ви можете використовувати власну функцію [TextDrawColor](...). /scripting/functions/TextDrawColor) для зміни кольору текстового малюнка, але вона відноситься до текстових малюнків так само, як **RGBA** колірні простори відносяться до клієнтських повідомлень і діалогів, їх не можна вбудовувати, для цього ми використовуємо спеціальну комбінацію символів для позначення кольорів і деяких інших символів, ви можете побачити їх [тут](../scripting/resources/gametextstyles).

| -------------- | ------ |
| Червоний - червоний.
| Зелений.
| Синій.
| або білий.
| Фіолетовий.
| Чорний.
| Жовтий.

Отже, вбудовування кольорів може виглядати наступним чином: **\~w\~Привіт, це \~b\~синій \~w\~а це \~r\~червоний**

Ви можете використовувати іншу комбінацію символів для гри з поєднанням кольорів, **\~h\~**, вона робить певний колір світлішим, ось кілька прикладів:

| | |
| ------------------------------ | -------------- |
| Світло-червоний.
| Червоно-рожевий.
| Темно-червоний.
| Світло-червоно-рожевий.
| Рожевий.
| g\~g\~\~h\~ | Світло-зелений

Докладнішу інформацію про це можна знайти [тут](../scripting/resources/colorslist).

### Ескейп-символ

#### Опис

Екранний символ - це символ, який при додаванні до якогось символу або числа створює власний константний символ, у більшості мов програмування/скриптів, таких як pawn, як екранний символ використовується зворотна коса риска (`\`), комбінація цього символу з іншим символом/числом утворює [екранну послідовність](https://en.wikipedia.org/wiki/Escape_sequence), яка має певне значення, детальніше про екранні символи ви можете дізнатися [тут](https://en.wikipedia.org/wiki/Escape_character).

#### Послідовності екранування

Екранні послідовності полегшують вираження певних символів у вихідному коді вашого скрипта, ось таблиця, що містить екранні послідовності, які використовуються в pawn:

| -------------------------------------------- | ------------ |
Звуковий сигнал (на серверних машинах) | `\a` або `\7` | | | Пробіл | `\b
| Backspace (пробіл)
| Escape.
| Переведення форми.
| Новий рядок.
| Повернення каретки.
| Горизонтальний табулятор.
| Вертикальна табуляція |`\v``.
| Зворотний слеш.
| Одинарні лапки.
| Подвійні лапки
Код символу з десятковими значеннями «ddd» | `\ddd;` | | Код символу з десятковими значеннями «ddd» | `\ddd;` | | Код символу
Шістнадцяткові коди символів «hhh» | `\xhhh;` | | Коди символів з шістнадцятковими значеннями «hhh

Давайте розглянемо кожен з них, адже найкращий спосіб вивчити такі речі - це практикувати їх.

- Послідовність екранування «Звуковий сигнал» - `\a`**

Звуковий сигнал або код дзвінка (_іноді символ дзвінка_) - це код керування пристроєм, який спочатку надсилається для дзвінка маленького електромеханічного дзвіночка на біжучих рядках та інших телепринтерах і телетайпах, щоб попередити операторів на іншому кінці лінії, часто про вхідне повідомлення.

Використання цієї функції на комп'ютері призведе до надсилання звуку дзвоника/сповіщення у фоновому режимі, її можна використовувати у творчий спосіб для сповіщення та/або попередження користувачів про певні дії, послідовність екранування, яка її представляє, є `\a` (або `\7`, позначена десятковим кодом), запустіть ваш пішаковий текстовий редактор і напишіть наступний текстовий код;

```cpp
print(«\a»);
```

Після виконання samp-server.exe ви почуєте звуковий сигнал, ви також можете використовувати десятковий код;

```cpp
print(«Це звуковий сигнал \7»);
```

- **Екранна послідовність «Backspace» - `\b`**

Ця послідовність екранування позначається як `\b`, вона просто переміщує ваш курсор назад, більшість людей очікують, що вона буде діяти як кнопка пробілу на звичайній клавіатурі, але не зовсім, вона лише переміщує каретку на одну позицію назад, не стираючи те, що там записано.

Ця кнопка не дуже зручна у використанні, якщо тільки ви не будете достатньо розумними, щоб видоїти з неї щось корисне, ось як вона працює.

```cpp
print(«Привіт 2018»);
```

Це надрукує **Hello 2018** у консолі, курсор залишиться на позиції нульового символу, більш наочно, ось так:

```
Привіт 2018
          ^
```

Як бачите, курсор зупиняється після останнього видимого символу рядка, що є нормальним, тепер давайте додамо екранну послідовність backspace;

```cpp
print(«Hello 2018\b»);
```

Це призведе до

```
Привіт 2018
         ^
```

Як бачите, курсор знаходиться точно в позиції останнього видимого символу рядка, а це _8_, це те ж саме, що увімкнути режим вставки на клавіатурі, тепер давайте додамо до цього трохи чаклунства.

```cpp
print(«Hello 2018\b9»);
```

Якщо ви правильно здогадалися, так, це виведе **Hello 2019**, тож, давайте подивимося, як це працює, машина буде обробляти рядок символ за символом, поки не досягне послідовності переходу на пробіл, тоді вона пересуне каретку на одну позицію назад, що вибере будь-який символ, який там є, в даному випадку 8, а потім вставить на його місце 9.

```
Привіт, 2019
         ^
```

Каретка буде рухатися назад до тих пір, поки у вашому рядку є екрануюча послідовність backspace.

```cpp
print(«Привіт 2018\b9\b\b\b»);
```

```
Привіт 2019
       ^
```

Курсор зупиниться на позиції першого символу, якщо кількість пропусків перевищує кількість символів між позицією першого символу (так, масиви починаються з 0, перейдіть на [r/programmerhumor](https://www.reddit.com/r/ProgrammerHumor/) за гарними мемами) та початковою позицією курсору.

```cpp
print(«Hi\b\b\b\b\b\b\b\b\b\b\b\b\b\b»);
```

Завжди призведе до цього;

```
Привіт
^
```

- Екранна послідовність «Escape» - `\e`**

З шістнадцятковим значенням 1B в _ASCII_, використовується для звичайного нестандартного коду, давайте розглянемо деякі мови програмування, такі як C, як приклад; послідовність, така як `\z` не є допустимою послідовністю екранування відповідно до стандарту C. Стандарт C вимагає, щоб такі неприпустимі екрановані послідовності діагностувалися (компілятор повинен вивести повідомлення про помилку). Незважаючи на це, деякі компілятори можуть визначати додаткові екрануючі послідовності з семантикою, що визначається реалізацією. Прикладом може слугувати екрануюча послідовність `\e`, яка представляє собою символ екранування. Однак її не було додано до стандартного репертуару мови C, оскільки вона не має відповідника у деяких наборах символів.

- Екранна послідовність «Переведення форми» - `\f`**

Послідовність подачі форми - це сторінка, що розриває _ASCII_ код. Вона змушує принтер виштовхувати поточну сторінку і продовжувати друк з початку іншої. Часто це також спричиняє повернення каретки, що не призводить до помітних змін у налагоджувальній консолі _SA-MP_.

- Послідовність переходу на новий рядок - `\n`**

Послідовність переходу на новий рядок (також відома як кінець рядка, кінець рядка (_EOL_), переведення рядка або розрив рядка) - це код _ASCII_, який записується як `/n` з десятковим значенням 10, це те, що зазвичай використовується, текстові редактори вставляють цей символ кожного разу, коли ми натискаємо кнопку Enter на нашій клавіатурі. Ось просте повідомлення з переведенням рядка:

```cpp
print(«Привіт, це рядок 1, а це рядок 2»);
```

Це буде просто виведено:

```
Привіт, це рядок 1
А це рядок 2
```

Звісно, гальмування декількох рядків можливе;

```cpp
print(«H\n\n\ne\n\n\nl\nl\n\no»);
```

```
H


e


l
l

o
```

Це працює по-іншому при роботі з файлами, однак, залежно від вашої операційної системи, наприклад, у Windows, переведення рядка зазвичай є **CR** (_повернення_ каретки_) + **LF** (_переведення_ рядка_), ви можете дізнатись більше про відмінності [тут](https://en.wikipedia.org/wiki/Newline).

- Екранна послідовність «Повернення каретки» - `\r`**

Повернення каретки - це _ASCII_ код, який часто асоціюється з переведенням рядка, але він може слугувати самостійною функцією, він просто переміщує каретку на початок поточного рядка, що еквівалентно конкретному випадку, який ми обговорювали, використовуючи декілька пробілів (`\b`), давайте подивимось на наступний приклад, без використання цієї послідовності ми б отримали нормальний вивід:

```cpp
print(«Hello»);
```

```
Привіт
     ^
```

Стрілка показує позицію курсору, яка знаходиться після останнього видимого символу рядка, знову ж таки, це нормальна очікувана поведінка, тепер давайте додамо до цього повернення каретки:

```cpp
print(«Hello\r»);
```

```
Привіт
^
```

Курсор переміщено на початок рядка, виділено перший символ **"H “**, тепер вставка будь-чого змінить **”H »** на те, що ми введемо, а потім перейдемо до наступного символу, залишаючись у режимі вставки:

```cpp
print(«Hello\rBo»);
```

```
Привіт
^
```

Як ми бачили у розділі про переведення рядка, переведення рядка працює по-різному у різних операційних системах, наприклад, у Windows для переведення рядка використовується повернення каретки, а потім переведення рядка, як і у класичних друкарських машинках.

- Послідовність екранування «Горизонтальна табуляція» - `\t`**

Табуляція - це те, що ми використовуємо щодня, від відступів тексту/коду до відображення таблиць, клавіша табуляції, яка знаходиться на самому краю клавіатури, дійсно заощаджує час, надмірне використання великої кількості пробілів забирало багато часу, але ця клавіша не лише легко розрізає пиріг, але й є корисною на практиці, він дійсно сильно присутній у сфері програмування, він позначається як `\t`, люди сперечаються про те, скільки пробілів коштує табуляція, більшість скаже, що 4 пробіли, але є й такі, хто скаже, що 8 пробілів, хтось демонічна істота навіть надасть перевагу пробілам перед табуляціями, але це вже інша розмова, давайте подивимось на цей простий приклад:

```cpp
print(«Hello\tWorld»);
```

```
Hello World
```

Ось ще один приклад з декількома таблицями:

```cpp
print(«Hello\t\t\t\t\tWorld»);
```

```
Hello World
```

- **Послідовність екранування «Вертикальний табулятор» - `\v`**

За часів старих друкарських машинок вона була більш популярною і використовувалася для переходу на наступний рядок по вертикалі, але зараз це вже не так, вона не має помітного застосування, і це стосується сучасних принтерів і навіть мов програмування, і pawn не є виключенням.

- **\_Екранна послідовність «Backslash» - `\*`**

Як ми бачили, зворотна коса риска вважається символом екранування, тому коли програма зустрічає її, вона сприймає її як початок деякої екрануючої послідовності, а не як самостійний символ, і, відповідно, або видасть помилку компіляції (_якщо за нею не слідує допустимий символ_), або не надрукує її, у випадку з пішаком, компілятор видасть помилку (_помилка 027: недопустима символьна константа_). На щастя, ми можемо вирішити цю проблему за допомогою екранування зворотної косої риски, додавши до неї ще одну зворотну косу риску:

```cpp
print(«Hello \\ World»);
```

```
Hello \ World
```

:::попередження Попередження

У виведенні буде проігноровано першу зворотну косу риску і виведено другу, оскільки перша риска екранує другу і обманом змушує програму сприймати її як необроблений символ. Зворотний слеш може екранувати лише один символ за раз, тому наступні дії призведуть до помилки компіляції.

:::

```cpp
print(«Hello \\\ World»);
```

Подумайте про це як про пари зворотних косих рисок, кожна з яких екранує наступну за нею, і, таким чином, завжди має виводитись парна кількість зворотних рисок;

```cpp
print(«Hello \\\\\\ \\ World»);
```

```
Hello \\\ \ World
```

Як ви напевно помітили, екрановані послідовності ніколи не виводяться, вони служать лише інструкціями, які виражають певні події, якщо ми хочемо змусити їх виводитися, ми можемо уникнути їх екрануючого символу (`\`), тоді програма не буде розглядати їх як екрановану послідовність:

```cpp
print(«Це ескейп-послідовність, що відповідає за табуляцію: \\t»);
```

Перша зворотна коса риска екранує другу, після чого вона виводиться, а символ **t** залишається наодинці, і таким чином розглядається як незалежний символ:

```
Ця послідовність екранування відповідає за табуляцію: \t
```

- **Послідовність екранування «Одинарні лапки» - `\'`**

Це навряд чи присутнє при написанні пішакового коду, я сам не використовував це в жодній ситуації кодування, в інших мовах, які розглядають текст між одинарними лапками як рядок, широко використовують це, щоб обмежити плутанину, яка виникає при вкладанні одинарних лапок одна в одну, в пішаку це дійсно не має ніякого значення, ось простий приклад;

```cpp
print(«Одинарні лапки '»);
// або
print(«Одинарні лапки \'»);
```

В обох випадках виведення буде однаковим:

```
Одинарні лапки: '
```

Єдине застосування, яке я можу придумати щодо цього, - це встановлення змінній символу «**'**», тому очевидно, що наведене нижче призведе до помилки компіляції;

```cpp
new chr = ''';
```

Просто тому, що компілятор сприйме першу пару одинарних лапок як один об'єкт, а другу - як незамкнену послідовність лапок, тому, щоб виправити це, нам доведеться екранувати середню лапку;

```cpp
new chr = ''\'';
```

- **Послідовність екранування «Подвійні лапки» - `\"`**

На відміну від одинарних лапок, ця послідовність може викликати проблеми при їх вкладенні, pawn розглядає все, що знаходиться між подвійними лапками, як рядок, так що якщо ви захочете ввести подвійні лапки в рядок, це заплутає програму, вона не буде знати, для чого призначена кожна лапка, давайте розглянемо це на прикладі для прикладу:

```cpp
print("Hello “world”);
```

Як тільки компілятор помітить перші лапки, він буде вважати все, що йде після них, частиною одного рядка, і завершить процес, як тільки натрапить на інші лапки, і таким чином, компілятор сприйме **"Hello “** як рядок, а **World ”** буде вважати безглуздим заповненням дірок у вашому коді. Щоб вирішити цю проблему, нам потрібно екранувати подвійні лапки, які ми хочемо надрукувати:

```cpp
print(«Hello \»world\");
```

Тепер компілятор сприйматиме другу лапку як екрановану послідовність, оскільки перед нею стоїть екранований символ (**\\**):

```
Hello «world
```

Давайте додамо ще одну лапку на всяк випадок:

```cpp
print(«Hello \»world\«»);
```

```
Привіт «світ»
```

Простіше не буває.

У цьому розділі ми бачили, як можна представити екрановані послідовності, додавши до певного символу символ екранування (`\\`), але це лише один із способів позначення цих значень, крім того, ми розглянемо ще два способи;

- **Екранні послідовності з кодом символу (десятковий код) - `\ddd;`**

Це нічого не змінює в екранних послідовностях, це просто інший спосіб їх вираження, з використанням десяткових _ASCII_ кодів, наприклад, якщо ви хочете надрукувати A, але записати його десятковим кодом, ви можете набрати його десятковий _ASCII_ код, як показано нижче:

```cpp
print(«\65;»);
```

Це стосується не лише алфавітно-цифрових символів, але й інших, наприклад, звуковий сигнал (`\a`), що має десяткове значення `7`, може бути подано згідно з цією нотацією як `\7`;

Крапка з комою не є обов'язковою і може бути опущена, але завжди краще дотримуватися оригінального підходу, її мета - надати екрануючій послідовності явний символ завершення, коли вона використовується у рядковій константі.

- Екранні послідовності з символьним кодом (десятковий код) - `\xhhh;`**

Подібно до десяткової _ASCII_ нотації, ми також можемо використовувати шістнадцятковий формат, символ **A**, може бути записаний як `\65`;**або `\x41`;**, _крапка з комою_ може бути опущена, якщо ви хочете, це стосується як тут, так і десяткової нотації.

```cpp
print(«\x41;»);
```

```
A
```

Ви можете знайти всі ці значення, просто загугливши «**ASCII таблиця**», і що найкрутіше - це безкоштовно.

#### Спеціальний символ екранування

Якщо ви помітили, що я неодноразово повторював «**екранний символ**» протягом останнього розділу, де я міг би назвати його просто «**коса риска**», або навіть скорочено (`\`), причиною цього є те, що екранний символ не є абсолютною константою, а скоріше, його можна змінювати, бажано, щоб він був _@, ^, \$_ і т.д. За замовчуванням він є косою рискою, але те, яким він залишиться, визначаєте тільки ви.

Для того, щоб змінити його, ми використовуємо директиву препроцесора `pragma`, ця директива приймає різні параметри, для кожного своє завдання, і є один, який відповідає за встановлення символу екранування, на якому ми будемо зосереджуватися, це `ctrlchar`.

```cpp
#pragma ctrlchar '$'

main()
{
 print(«Hello $n World»);
 print(«Це зворотна коса риска: \\»)
 print(«Це знак долара: $$»);
}
```

```
Привіт.
 Світ
Це зворотна коса риска: \
Це знак долара: $
```

Як ви можете бачити, тепер переведення рядка позначається як `$n` замість `\n`, а зворотна коса риска більше не вважається символом екранування, і, відповідно, знак долара має бути екранований іншим знаком долара.

Однак, ви не можете змінити його на (`-`), але все інше є прийнятною практикою, але це ніколи не буде прийнятним з етичної точки зору, просто наскільки безглуздою є ця `#pragma ctrlchar '6'`, га? Абсолютно божевільний хлопець.

Ця частина не має жодного відношення до евакуаційних послідовностей, але вона використовується для форматування текстових малюнків та ігрового тексту, тому краще розмістити її тут, ніж деінде;

| | |
| ----- | ------------------------------------------------------------------------------------------------------------- |
| u - стрілка вгору (сіра)
| «d» - стрілка вниз (сіра).
| Вліво (сіра).
| Сіра стрілка вправо.
| `]` | Відображає символ `*` (лише у текстових стилях 3, 4 та 5)
| `~k~` | Відображення клавіш клавіатури (наприклад, `~k~~VEHICLE_TURRETLEFT~` і `~k~~PED_FIREWEAPON~`). Список клавіш можна переглянути тут

відображення клавіш клавіатури (наприклад, `~k~~VEHICLE_TURRETLEFT~` і `~k~~PED_FIREWEAPON~`). Список ключів дивіться тут

### Специфікатор формату

#### Опис

Заповнювачі або специфікатори - це символи, закриті знаком відсотка (`%`), що вказують на відносне розташування та тип виведення певних параметрів, вони слугують, як випливає з їхньої назви «_Заповнювачі»_, вони зберігають місце для даних, які згодом замінять їх всередині рядка, існують різні типи специфікаторів, і вони навіть відповідають певній формулі;

```
%[прапори][ширина][.точність]тип
```

Атрибути у дужках є необов'язковими, і користувач може залишити їх чи ні, що насправді визначає специфікатор, так це широко відомий формат **%type**, частина типу замінюється символом для представлення певного вихідного типу; (_integer, float... і т.д._).

Заповнювачі використовуються лише у функціях, які приймають параметри, тому такі функції як print не матимуть жодного ефекту, альтернативою їй є більш просунута `printf`.

Давайте розглянемо різні типи виводу, які можна використовувати:

| ------------- | ----------------------------------------------- |
| Специфікатор****Значення** **Значення** **Значення****Значення
| `%i` | Ціле число (_ціле число_)
Ціле число (_ціле число_) | |%d`| Ціле число (_ціле число_) | |%s` | Рядок
| Рядок
| `%f` | Число з плаваючою комою (`Float: tag`)
| ASCII-символ
| `%x` `Шістнадцяткове число`%x``Шістнадцяткове число `%x` `Шістнадцяткове число`%x
| `%b`` Двійкове число
| Літерал «%».
|`%q` | Екранування тексту для SQLite. (_Добавлено в 0.3.7 R2_)

- Специфікатори цілих чисел - `%i` і `%d`**

Давайте об'єднаємо ці два специфікатори разом, по суті, ці два специфікатори роблять те саме, обидва виводять цілі числа, навіть якщо `%i` означає ціле число, а `%d` - десяткове, вони є синонімами одного й того ж самого поняття.

В інших мовах, однак, різниця полягає не у виведенні, а у введенні за допомогою функцій типу `scanf`, де `%d` сканує ціле число як десяткову систему числення зі знаком, а %i за замовчуванням - як десяткову, але також допускає шістнадцяткову (_if перед `0x`_) і вісімкову систему числення (_if перед `0`_).

Ці два специфікатори використовуються наступним чином:

```cpp
printf(«%d тут», 2018);
printf(«%d + %i = %i», 5, 6, 5 + 6);
```

```
printf(«%d тут», 2018);
printf(«%d + %i = %i», 5, 6, 5 + 6);
```

Виведення також підтримує попередньо визначені константи, змінні та функції.

```cpp
#define CURRENT_YEAR 2018
new age = 19;

printf(«Зараз %d», CURRENT_YEAR);
printf(«Йому %d років», age);
printf(«Секунди з опівночі 1 січня 1970 року: %d», gettime());
```

```
Зараз 2018 рік
Йому 19 років
Секунди з опівночі 1 січня 1970 року: 1518628594
```

Як бачите, будь-яке значення, яке ми передаємо в параметрах функції `printf`, замінюється відповідним заповнювачем, і пам'ятайте, **порядок має значення**, ваші заповнювачі повинні слідувати в тому ж порядку, що і ваші параметри у виклику, і завжди використовуйте правильний тип специфікатора, недотримання цього правила не призведе до помилки, але може вивести деякі небажані результати, але в деяких випадках ці небажані результати є саме тим, що ми хочемо.

Як ви думаєте, що станеться, якщо ми спробуємо вивести число з плаваючою комою або рядок, використовуючи специфікатор цілого типу? Давайте з'ясуємо це;

```cpp
printf(«%d», 1.12);
printf(«%d», «Hello»);
printf(«%d», 'H');
printf(«%d», true);
```

```
1066359849
72
72
1
```

Як дивно, абсолютно несподівано, але не обов'язково марно, саме ця поведінка використовується у багатьох ситуаціях.

Перш за все, давайте подивимося, чому `1.12` вивела _1066359849_, ну, це те, що називається невизначеною поведінкою, ви можете дізнатися більше про це [тут](https://en.wikipedia.org/wiki/Undefined_behavior).

Спроба вивести рядок за допомогою цілочисельного специфікатора дасть _ASCII_ код першого символу, у цьому випадку код символу H, 72, те ж саме відбувається і при виведенні одного символу. І, нарешті, виведення булевого значення дасть 1, якщо воно є істинним, і 0, якщо воно є хибним.

Рядки самі по собі є масивами, тому виведення масиву тут дасть значення першого слоту в цьому масиві, а те, як воно буде виведено, залежить від його типу (_integer, float, character, boolean_).

- Специфікатори рядків - `%s`**

Цей специфікатор, оскільки він розшифровується як string, відповідає за виведення рядків (_очевидно_):

```cpp
printf(«Hello, %s!», «World»);
```

```
Привіт, світе!
```

Давайте також виводити нестрокові значення за допомогою цього методу:

```cpp
printf(«%s», 103);
printf(«%s», true);
printf(«%s», 'H');
printf(«%s», 1.12);
```

```
g

H
)
```

Число `103` було сприйнято як _ASCII_ код для _g_, і тому було виведено _g_, те ж саме стосується дивного символу під ним, було виведено символ зі значенням true, він же _1_, простіше кажучи, символ `'H'` було виведено як є, але що сталося з плаваючим числом `1.12`? Пам'ятаєте про **невизначену поведінку**? Так, `1.12` призвело до величезного цілого числа, яке продовжувало переповнюватися (його значення ділилося на _255_) разів, поки не отримало число між _0_ і _254_, у даному випадку _40_, що є _ASCII_ кодом символу _(_.

Знову ж таки, як і специфікатор цілих чисел, цей специфікатор приймає попередньо визначені константи, змінні та функції:

```cpp
#define NAME «Max»
new message[] = «Привіт!»;

printf(«Його ім'я %s», NAME);
printf(«Привіт, %s», message);
printf(«%s працює», #Great);
```

```
Його звуть Макс.
Привіт, привіт!
Чудова робота.
```

- Специфікатори з плаваючою комою - `%f`**

Цей специфікатор - скорочення від float-, як випливає з його назви, виводить плаваючі числа, у попередніх розділах ми намагалися виводити плаваючі числа за допомогою специфікатора integer, і тоді ми отримали невизначену поведінку, але тепер, коли ми знаємо про цей специфікатор, ми можемо спокійно виводити плаваючі числа без проблем;

```cpp
printf(«%f», 1.235);
printf(«%f», 5);
printf(«%f», 'h');
```

Плаваюче число _1.235_ було виведено чудово, з додаванням деяких пропусків, проте решта чисел виведено _0.000000_, тобто _0_, це тому, що специфікатор `%f` виводить лише плаваючі числа, тобто числа, які не мають фіксованої кількості цифр до і після десяткової крапки; тобто, десяткова крапка може плавати.

Щоб виправити цю проблему, ми просто додаємо дробову частину:

```cpp
printf(«%f», 5.0);
printf(«%f», 'h' + 0.0);
```

```
5.000000
104.000000
```

Хоча `%f` є найпоширенішим плаваючим заповнювачем, специфікатор `%h` робить майже те саме:

```cpp
printf(«%h», 5.0);
```

```
5.000000
```

- Специфікатори символів - `%c`**

Цей специфікатор, скорочено від character, працює подібно до рядкового заповнювача, але виводить лише один символ, розглянемо наступний приклад:

```cpp
printf(«%c», 'A');
printf(«%c», «A»);
printf(«%c», «Hello»);
printf(«%c», 105);
printf(«%c», 1.2);
printf(«%c», true);
```

```
A
A
H
i
s
```

Як ви можете бачити, передача рядка виведе лише перший символ, а передача числа виведе символ, чий _ASCII_ код відповідає цьому числу (_булеві_ перетворюються на 0 і 1 відповідно_).

- Шістнадцяткові специфікатори - `%x`**

Наступний специфікатор виводить значення, яке ми передаємо, як шістнадцяткове число, простіше кажучи, як переведення чисел із заданої системи числення у систему числення з основою 16.

```cpp
printf(«%x», 6);
printf(«%x», 10);
printf(«%x», 255);
```

```
6
A
FF
```

Подібно до випадків, розглянутих у попередніх розділах, передача значень, відмінних від цілих, перетворить їх у відповідні цілі значення і виведе у вигляді шістнадцяткових чисел;

```cpp
printf(«%x», 1.5);
printf(«%x», 'Z');
printf(«%x», «Hello»);
printf(«%x», true);
```

```
3FC00000
5A
48
1
```

Перше значення `1.5`, призведе до невизначеної поведінки при перетворенні у ціле число (_1069547520_), потім отримане ціле число буде виведено у шістнадцятковому вигляді (_3FC00000_), Символ `'Z'` буде перетворено у шістнадцятковому вигляді (5A) зі значенням _ASCII_ (90). Рядок `«Hello»` матиме лише перший символ (H) зі значенням _ASCII_ (72), перетвореним у шістнадцяткову систему числення (48). І `true` виводить (1) як шістнадцяткове число, яке перетворюється на (1), (false виводить 0).

- Двійкові специфікатори - `%b`**

Наступний специфікатор, скорочено від «_binary_» використовується для виведення переданих значень у вигляді двійкових чисел, передані символи перетворять їх _ASCII_ код у двійковий, так само як і у випадку з рядками, де враховується лише перший символ, булеві значення вважаються істинними та хибними відповідно, числа з плаваючою комою підпадають під випадок невизначеної поведінки, що стосується цілих та шістнадцяткових чисел, то вони конвертуються у двійкові та виводяться.

```cpp
printf(«%b», 0b0011);
printf(«%b», 2);
printf(«%b», 2.0);
printf(«%b», 0xE2);
printf(«%b», 'T');
printf(«%b», «Hello»);
printf(«%b», true);
```

```
11
10
1000000000000000000000000000000
11100010
1010100
1001000
1
```

- **Літерал `%`**

Подібно до стандартного екрануючого символу (`\`), компілятор розглядає (`%`) як спеціальний символ, і таким чином трактує послідовність як заповнювач, якщо після (`%`) стоїть символ, він розглядається як специфікатор, навіть якщо він не є дійсним, давайте розглянемо ці два випадки;

```cpp
printf(«%»);
printf(«Hello %»);
printf(«% World»);
printf(«Hello % World»);
```

```
%
Привіт, %
 World
Привіт, світе.
```

Як ви можете бачити, якщо мати (`%`) як окрему послідовність, вона буде виведена, але те ж саме відбувається, коли за нею слідує пробіл або будь-який інший символ, що призводить до виведення символу пробілу. Щоб обійти цю проблему, ми уникнемо її, використовуючи інший знак відсотка наступним чином;

```cpp
printf(«Це знак відсотків %%, ми просто повинні були обійти його!»);
```

```
Це знак відсотка %, ми просто повинні були його уникнути!
```

Звичайно, це стосується лише функцій, які підтримують форматування, таких як `printf` і `format`, наприклад, спроба вивести знак відсотка за допомогою функції `print` не вимагатиме екранування.

- Специфікатор `%q`

Цей специфікатор не має великого значення в нашій основній темі, він широко використовується для екранування чутливих рядків при роботі з _SQLite_, і повірте мені, ніхто не хоче потрапити в ситуацію [Bobby table](http://bobby-tables.com/about).

Коли ми розповідали про плейсхолдери, ми посилалися на спеціальну формулу для них, нагадуємо, ось вона;

```
%[прапорці][ширина][.точність]тип
```

Досі ми говорили лише про знак `%` і тип filed, інші є необов'язковими, але кожен з них ефективний у різних випадках, ви можете включити їх, щоб краще контролювати обробку ваших значень при їх виведенні.

- **Ширина файлу**

Цей параметр відповідає за вказівку мінімальної ширини символів, що виводяться, його можна опустити, якщо потрібно, просто введіть його значення як числове ціле, давайте розглянемо деякі приклади;

```cpp
printf(«%3d», 5555);
printf(«%3d», 555);
printf(«%3d», 55);
printf(«%3d», 5);
```

```
5555
555
 55
  5
```

Ми вказали специфікатору обмежити виведення 3 символами або більше, спочатку виведення 4 і 3 символів довжиною в номер проходило нормально, але символи, коротші за 3 символи, були залишені з пробілами, щоб вирівняти ширину виводу. Існує також можливість мати динамічні значення ширини, для цього ми використовуємо знак зірочки (`*`).

```cpp
printf(«%*d», 5, 55);
```

```
     55
```

Спочатку ми передаємо значення ширини, яке було `5`, потім значення, яке ми хочемо вивести `55`, тому заповнювач виводить мінімум 5 символів, тобто 5 мінус 2, що дає нам 3 пропуски.

- **Поле прапорців**

Це поле дуже добре працює з полем ширини, оскільки ширина визначає мінімальну кількість символів для виводу, а це поле заповнює порожнечу, що залишилася, тим, що ви йому скажете. Якщо після нього залишилися пробіли, то ніякого заповнення не буде.

```cpp
printf(«%3d», 55);
printf(«%5x», 15);
printf(«%2f», 1.5)
```

```
055
0000F
01.500000
```

Першому числу 55 не вистачає одного символу через ширину десяткового параметра, тому його доповнено одним 0. Що стосується числа 15, то його перетворено у відповідне шістнадцяткове значення _F_ і доповнено 4 0 для перевірки ширини заповнювача. Зверніть увагу, що лише число перед десятковою крапкою було розширено. Використання значень динамічної ширини залишається і тут, нам просто потрібно включити зірочку, передати значення і спостерігати, як відбувається магія;

```cpp
printf(«%0*d», 5, 55);
```

```
00055
```

- **Поле точності**

Поле «Точність» зазвичай визначає максимальну межу виведення, залежно від конкретного типу форматування. Для числових типів з плаваючою комою воно визначає кількість цифр праворуч від десяткової крапки, які слід округлити. Для рядкових типів він обмежує кількість символів, які слід виводити, після чого рядок усікається.

```cpp
printf(«%.2f», 1.5);
printf(«%.*f», 10, 1.5);
printf(«%.5s», «Hello world!»);
printf(«%.*s», 7, «Hello world!»);
```

```
1.50
1.5000000000
Привіт.
Привіт.
```

Як ви бачите, динамічні значення точності можна використовувати як з плаваючою точкою, так і з рядковими заповнювачами.

Дійсно крутий трюк, який ми можемо провернути завдяки полю точності - це отримання підрядків, для цього існує безліч методів, і це не враховуючи рідну функцію [strfind](../scripting/functions/strfind), і не забуваймо про дивовижні функції, які ми отримали у **Slice** у [strlib](https://github.com/oscar-broman/strlib) include.

Давайте подивимося, як можна отримати той самий результат, використовуючи лише поле точності.

```cpp
substring(const source[], start = 0, length = -1)
{
 new output[256];

 format(output, sizeof(output), «%.*s», length, source[start]);
 return output;
}
```

Спробуємо розшифрувати цей фрагмент коду, для цього просто передамо вихідний рядок (рядок, з якого ми збираємося витягувати), стартову позицію (слот, з якого ми збираємося почати витягування) і довжину символів, які ми хочемо витягти.

Значення, що повертається, буде відформатовано відповідно до наступного заповнювача `%.*s`, ми включаємо поле точності і використовуємо його для визначення динамічного значення, яке буде довжиною вилучених символів, потім ми вказуємо початкову позицію для вилучення, додавши `source[start]`, який пропускає, починаючи з першого слота, до номера слота `start`, який ми передали у параметрах функції.

Давайте викличемо функцію і подивимося, як вона працює далі:

```cpp
new message1[] = «Привіт!», message2[] = «Я хочу яблуко!»;

print(substring(.source = message1, .start = 1, .length = 3));
print(substring(.source = message2, .start = 7, .length = 8));
```

```
яблуко
яблуко
```

Просто, чи не так? Невеликий бонус: якщо в якості довжини вилучення вказати від'ємне значення, буде виведено всі символи вихідного рядка, починаючи зі слота **start**. З іншого боку, передача 0 як довжини вилучення повертає нульове значення.

Давайте розглянемо ці випадки:

```cpp
new message3[] = «Масиви починаються з 1, каже розробник Lua!»;

print(substring(message3)); // start = 0 за замовчуванням, length = -1 за замовчуванням
print(substring(message3, .length = 6)); // за замовчуванням початок = 0, довжина = 6
print(substring(message3, 7, 10)); // початок = 7, довжина = 10
print(substring(message3, strlen(message3) - 14)); // за замовчуванням start = 28, length = -1
print(substring(message3, strlen(message3) - 14, 3)); // start = 28, length = 3
```

```
Масиви починаються з 1, каже розробник Lua!
Масиви
починаються з 1
Розробник Lua!
Lua
```

#### Використання

Застосовуючи все, що ми бачили до цього часу, ми можемо форматувати наші рядки у будь-якому випадку, досі ми працювали переважно у консолі, використовуючи функції `print` та `printf` для виведення наших даних, ну, переважно `printf`, тобто завдяки її вбудованій підтримці форматування рядків на ходу, звідси і буква f у назві функції.

Але у реальному світі більшість людей не люблять дивитися на термінали, вони занадто страшні і складні для пересічного користувача, а як ви всі знаєте, _клієнтські повідомлення_ виводяться на екран гри, а не на консоль, однак, їх не можна форматувати на ходу, вони більше схожі на функцію друку, так би мовити, щоб обійти це обмеження, ми використовуємо іншу дуже ефективну функцію, яка називається `format`, ми не будемо заглиблюватися у її визначення, оскільки ми вже пояснювали її у попередніх частинах (зверніться до [this](. ./scripting/functions/format)), але нагадаємо її синтаксис;

```cpp
format(output[], len, const format[], {Float,_}: ...}
```

Давайте розглянемо ці приклади;

**Приклад 1**: _Ім'я гравця - Припустимо, що на сервері є гравець з ідентифікатором 9 на ім'я Player1_:

```cpp
// MAX_PLAYER_NAME - визначена константа зі значенням 24, ми додаємо 1, щоб врахувати нульовий термінатор, дякуємо Pottus'у за те, що вказав на це.
new playerName[MAX_PLAYER_NAME + 1], output[128], playerid = 9;

GetPlayerName(playerid, playerName, MAX_PLAYER_NAME);
format(output, sizeof(output), «[Інформація]: гравець з ідентифікатором %d називається {EE11CC}%s.», playerid, playerName);SendClientMessageToAll(0, output);
```

> [Інформація]: гравець з ідентифікатором 9 називається <span style={{color: '#ee11cc'}}>Player1</span>.

Досить просто, ми просто отримуємо ім'я гравця і починаємо форматувати рядок, заповнювач `%d` відповідає за відображення змінної `playerid`, яка має значення `9`, заповнювач `%s` виводить рядок `playerName`, який містить ім'я гравця завдяки функції `GetPlayerName`.

Потім ми покажемо відформатований рядок усім на сервері за допомогою функції `SendClientMessageToAll`, зверніть увагу, що значення `0` у її першому параметрі вказує на чорний колір, який буде кольором повідомлення, а вбудоване шістнадцяткове значення `{FFFF00}` призвело до того, що ім'я гравця буде жовтим.

**Приклад 2**: _Гральний годинник - відображення поточного часу у грі_:

```cpp
new output[128], години, хвилини, секунди;

gettime(години, хвилини, секунди);
format(output, sizeof(output), «Зараз %02d:%02d %s», hours > 12 ? hours - 12 : hours, minutes, hours < 12 ? («AM») : («PM»));
SendClientMessageToAll(0, вивід);
```

Знову ж таки, ми просто використали функцію `gettime` для зберігання годин, хвилин і секунд у відповідних змінних, а потім об'єднали їх у гарно відформатований рядок, скориставшись полем ширини `%02d`, щоб доповнити значення від 0 до 9 ще одним нулем, щоб уникнути виводу на кшталт («_It's 5:9 PM_»), як ви можете бачити.

> It's 06:17 PM

**Приклад 3**: _Повідомлення про смерть - виведення повідомлення про смерть гравця, з іменами гравців, забарвленими у відповідні кольори_:

```cpp
public OnPlayerDeath(playerid, killerid, WEAPON:reason)
{
    // MAX_PLAYER_NAME - попередньо визначена константа зі значенням 24, ми додаємо 1, щоб врахувати нульовий термінатор, дякую Pottus'у за те, що вказав на це.
    new message[144], playerName[MAX_PLAYER_NAME + 1], killerName[MAX_PLAYER_NAME + 1];

    GetPlayerName(playerid, playerName, MAX_PLAYER_NAME);
    GetPlayerName(killerid, killerName, MAX_PLAYER_NAME);

    format(message, sizeof(message), «{%06x}%s {000000}вбито {%06x}%s», GetPlayerColor(killerid) >>> 8, killerName, GetPlayerColor(playerid) >>> 8, playerName);
    SendClientMessageToAll(0, message);

    return 1;
}
```

Дано наступний список підключених гравців:

| | |
| ------ | ----------------------------------------------- |
| Ідентифікатор гравця
| 0 | <span style={{color: 'red'}}>Комптон</span>
| 1 | <span style={{color: 'grey'}}>Dark</span> |
| 5 | <span style={{color: 'red'}}>Player1</span> |
| 6 | <span style={{color: 'blue'}}>Бартоломью</span> |
| 11 | <span style={{color: 'grey'}}>unban_pls</span>>

Скажімо, `playerid` `0` вбив `playerid` `6`, відформатовані повідомлення повинні мати вигляд «**{FF0000}Compton {000000}killed > {0000FF}Bartolomew**», що надішле наступне клієнтське повідомлення усім на сервері:

> <span style={{color: 'red'}}>Комптон</span> <span style={{color: '#000000'}}>вбито</span> <span style={{color: 'blue'}}>Бартоломью</span>

Перепрошую, якщо я заплутав вас, використовуючи [порозрядний логічний зсув](https://en.wikipedia.org/wiki/Logical_shift), він просто використовується для того, щоб перетворити десяткове число, повернуте функцією `GetPlayerColor` у шістнадцяткове число, що представляє колір, сам зсув використовується для того, щоб опустити -альфа- пробіл, для більш детальної інформації про це, я рекомендую ознайомитися з [цим підручником](Двійковий) від **Kyosaur**.

#### Спеціальні специфікатори

Робота зі специфікаторами форматування, яку ми розглянули, є достатньою, ви можете робити буквально все, що завгодно, за допомогою цих чудових інструментів, але ніщо не заважає нам попросити ще, які ми жадібні. Все завдяки **Slice**, який під впливом [sscanf](https://github.com/maddinat0r/sscanf) створив дивовижний модуль [formatex](https://github.com/Southclaws/formatex), який додав декілька нових специфікаторів, що дійсно полегшило багато повсякденної роботи з пішаками. Але це ще не все, ви також можете створювати свої власні специфікатори відповідно до ваших потреб, і як би круто це не звучало, процес дуже простий.

Просто для тестування, давайте зробимо щось дурнувате, щось елементарне, наприклад, передамо на вхід рядок і повернемо його у вигляді посилання (_<https://www.string.com>_);

```cpp
FormatSpecifier<'n'>(output[], const param[]) {
 format(output, sizeof(output), «https://www.%s.com», param);
}
```

Ось так просто і народився могутній специфікатор `%n` (скорочено від Newton, бо це дуже круто і по-ракетному складно 😉), давайте протестуємо цього чемпіона:

```cpp
printf(«%n», «samp»);
```

> <https://www.samp.com>

:::примітка

Не дозволяйте цьому прикладу обмежувати ваші очікування щодо того, чого можна досягти за допомогою користувацьких специфікаторів, є кращі приклади на головній сторінці випуску, [будь ласка, відвідайте її](https://github.com/Southclaws/formatex/blob/master/README.md).

:::

### Зовнішні посилання

#### Схожі підручники

- [Форматування рядків](https://sampforum.blast.hk/showthread.php?tid=265433) від [krogsgaard20](https://sampforum.blast.hk/member.php?action=profile&uid=126724)
- [Розуміння рядків](https://sampforum.blast.hk/showthread.php?tid=284112) від [\[HiC\]TheKiller](https://sampforum.blast.hk/member.php?action=profile&uid=23565)
- [Як користуватися strcmp](https://sampforum.blast.hk/showthread.php?tid=199796) від [Ash.](https://sampforum.blast.hk/member.php?action=profile&uid=78597)
- [Посібник для початківців: одновимірні/двомірні/багатовимірні масиви](https://sampforum.blast.hk/showthread.php?tid=318212) від [iPLEAOMAX](https://sampforum.blast.hk/member.php?action=profile&uid=122705)
- [Поради та рекомендації](https://sampforum.blast.hk/showthread.php?tid=216730) від [Slice](https://github.com/oscar-broman)
- [Оптимізація коду](https://sampforum.blast.hk/showthread.php?tid=571550) від [Misiur](https://sampforum.blast.hk/member.php?action=profile&uid=55934)
- [Упаковані рядки](https://sampforum.blast.hk/showthread.php?tid=480529), автор [Emmet\_](https://github.com/emmet-jones)
- [Форматування рядків IRC](https://github.com/myano/jenni/wiki/IRC-String-Formatting) від [myano](https://github.com/myano)
- [Манупіляція рядків](https://web.archive.org/web/20190424140855/https://www.compuphase.com/pawn/String_Manipulation.pdf) від [CompuPhase](https://web.archive.org/web/20190424140855/http://www.compuphase.com/)
- [Pawn-lang](https://github.com/pawn-lang/compiler/blob/master/doc/pawn-lang.pdf)
- [Поглиблений погляд на двійкові та бінарні оператори](https://sampforum.blast.hk/showthread.php?tid=177523) від [Kyosaur](https://sampforum.blast.hk/member.php?action=profile&uid=23990)

#### Пов'язані включення/плагіни/контрибутори

- [Westie](https://sampforum.blast.hk/member.php?action=profile&uid=56481) [strlib](https://sampforum.blast.hk/showthread.php?tid=85697) від [Westie].
- [strlib](https://github.com/oscar-broman) [Slice](https://github.com/oscar-broman/strlib)
- [Slice](https://github.com/oscar-broman)'s [formatex](https://github.com/Southclaws/formatex)
- [corne](https://sampforum.blast.hk/member.php?action=profile&uid=98345) - [y_stringhash](https://sampforum.blast.hk/showthread.php?tid=571305)
- [Y-Less](https://github.com/Y-Less)'s [sscanf](https://github.com/maddinat0r/sscanf)

#### Посилання

- [GTA San Andreas](https://www.rockstargames.com/sanandreas/)
- [Textdraw](../scripting/resources/textdraws#what-is-a-textdraw)
- [Gametext](../scripting/functions/GameTextForPlayer)
- [Обмеження](../scripting/resources/limits)
- [ASCII](https://en.wikipedia.org/wiki/ASCII)
- [Таблиця ASCII](https://www.asciitable.com/)
- [Підручник з пішаків](https://wiki.alliedmods.net/Pawn_Tutorial)
- [Керуючі структури](../scripting/language/ControlStructures)
- [Нульовий символ](https://en.wikipedia.org/wiki/Null_character)
- [Колірний простір RGBA](https://en.wikipedia.org/wiki/RGBA_color_space)
- [Піпетка кольорів](https://www.webpagefx.com/web-design/color-picker/)
- [TextDrawColor](../scripting/functions/TextDrawColor)
- [Стилі ігрового тексту](../scripting/resources/gametextstyles)
- [Список кольорів](../scripting/resources/colorslist)
- [Послідовність екранування](https://en.wikipedia.org/wiki/Escape_sequence)
- [r/programmerhumor](https://www.reddit.com/r/ProgrammerHumor/)
- [Новий рядок](https://en.wikipedia.org/wiki/Newline)
- [Невизначена поведінка](https://en.wikipedia.org/wiki/Undefined_behavior)
- [Боббі-таблиця](https://bobby-tables.com/about)
- [strfind](../scripting/functions/strfind)
- [format](../scripting/functions/format)
- [Порозрядний логічний зсув](https://en.wikipedia.org/wiki/Logical_shift)
