---
title: «Advanced Structures»
---

## Маніпуляції з масивами

### Правильний пошук порожнього слоту

У цьому прикладі показано, як знайти порожній слот у масиві, використовуючи стандартні практики кодування.

```c
новий
    gMyArray[10];

stock FindEmptySlot()
{
    новий
        i = 0;
    while (i < sizeof (gMyArray) && gMyArray[i])
    {
        i++;
    }
    if (i == sizeof (gMyArray)) return -1;
    return i;
}
```

У цьому базовому прикладі передбачається, що слот масиву порожній, якщо його значення дорівнює 0. Цикл перебирає всі значення у масиві (можна також використовувати константу) до тих пір, поки вони не стануть рівними 0. Коли досягається значення, рівне 0, умова while не виконується, і цикл завершується без використання переривання, що є загальноприйнятою практикою, але не рекомендується у подібних ситуаціях. Ця функція також повертає -1, якщо вільний слот не знайдено, що необхідно перевірити на іншому кінці циклу. Зазвичай ви використовуєте знайдений ідентифікатор одразу:

```c
MyFunction()
{
    новий
        i = 0;
    while (i < sizeof (gMyArray) && gMyArray[i])
    {
        i++;
    }
    if (i == sizeof (gMyArray))
    {
        printf(«Вільного слоту не знайдено»);
        return 0;
    }
    printf(«Слот %d порожній», i);
    // Використовуйте знайдений слот у своєму коді для чого завгодно
    return 1;
}
```

Очевидно, що ви маєте замінити вираз «gMyArray[i]» на свій власний вираз, що вказує на слот, який використовується.

### Список

#### Вступ

Списки є дуже корисним типом структури, це, по суті, масив, де на наступний елемент або відповідні дані вказує попередній елемент.

Приклад:

Скажімо, у вас є наступний масив:

```c
3, 1, 64, 2, 4, 786, 2, 9
```

Якщо ви захочете відсортувати масив, ви отримаєте наступне:

```c
1, 2, 2, 3, 4, 9, 64, 786
```

Якщо ж ви хочете залишити дані у початковому порядку, але з якихось причин все ще знаєте порядок чисел (це лише приклад), то у вас виникне проблема: як ви збираєтесь зберігати числа у двох порядках одночасно? Для цього добре підійдуть списки. Щоб створити список з цих даних, вам потрібно перетворити масив на двовимірний масив, де другий вимір був би розміром у 2 клітинки, перший вимір містив би початкове число, а другий - індекс наступного за величиною числа. Вам також знадобиться окрема змінна для зберігання індексу найменшого числа, і ваш новий масив матиме такий вигляд:

```c
start = 1
3, 1, 64, 2, 4, 786, 2, 9
4, 3, 5, 6, 7, -1, 0, 2
```

Наступний індекс, пов'язаний з 786, дорівнює -1, це невірний індекс масиву і вказує на кінець списку, тобто більше немає чисел. Очевидно, що ці дві 2 можуть бути і навпаки, перше число у масиві також буде першим у списку, оскільки воно з більшою ймовірністю зустрінеться першим.

Іншою перевагою цього методу сортування чисел є те, що додавання нових чисел відбувається набагато швидше. Якщо ви хочете додати ще одне число 3 до відсортованого масиву, вам потрібно буде спочатку зсунути принаймні 4 числа на один слот праворуч, щоб звільнити місце, що не так вже й страшно, але дуже повільно у великих масивах. У версії зі списком ви можете просто додати 3 у кінець масиву і змінити одне значення у списку;

```c
start = 1
3, 1, 64, 2, 4, 786, 2, 9, 3
8, 3, 5, 6, 7, -1, 0, 2, 4
^ змінити це значення ^ наступний за старшинством слот
```

Жодне з інших чисел не перемістилося, тому жоден з інших індексів не потребує оновлення, просто зробіть так, щоб наступне найнижче число вказувало на нове число, а нове число вказувало на число, на яке раніше вказувало наступне найнижче число. Видалити значення ще простіше:

```c
start = 1
3, 1, 64, X, 4, 786, 2, 9, 3
8, 6, 5, 6, 7, -1, 0, 2, 4
   ^ Змінено для переходу через вилучене значення
```

Тут перші 2 було видалено, а число, яке вказувало на це число (1), було оновлено на число, на яке вказувало видалене число. У цьому прикладі не було вилучено ні покажчик вилученого числа, ні саме число, але ви не зможете дістатися до цього слоту за списком, тому це не має значення, його фактично вилучено.

#### Типи

Списки у наведених вище прикладах були простими одинарними списками, ви також можете використовувати подвійні списки, де кожне значення вказує на наступне і останнє значення, такі списки, як правило, також мають вказівник на кінець списку, щоб повернутися назад (наприклад, щоб отримати числа у порядку спадання):

```c
start = 1
end = 5
значення: 3, 1, 64, 2, 4, 786, 2, 9, 3
наступний:  8, 3, 5, 6, 7, -1, 0, 2, 4
last: 6, -1, 7, 1, 8, 2, 3, 4, 0
```

Ви повинні бути обережними з ними, особливо коли у вас більше одного будь-якого значення, щоб останній вказівник вказував на число, на яке наступний вказівник повертається назад, наприклад, це неправильно:

```c
2, 3, 3
1, 2, -1
-1, 2, 0
```

Наступний вказівник 2 вказує на 3 у першому слоті, але останній вказівник 3 не повертається до двох, обидва списки впорядковані самі по собі (оскільки дві трійки можуть бути в обох напрямках), але разом вони неправильні, правильним варіантом був би такий:

```c
2, 3, 3
1, 2, -1
-1, 0, 2
```

Обидва ці списки починаються і закінчуються на двох крайніх числах, зворотний список у неправильному прикладі починається з середнього числа.

Іншим типом списку є зациклений список, у якому останнє значення вказує на перше. Очевидною перевагою є те, що ви можете дістатися до будь-якого значення з будь-якого іншого значення, не знаючи заздалегідь, чи знаходиться ціль до або після початкової точки, вам просто потрібно бути обережним, щоб не потрапити в нескінченний цикл, оскільки немає явної кінцевої точки -1. Ці списки все ще мають початкові точки. Ви також можете створювати подвійні циклічні списки, коли у вас є наступний і попередній список, обидва з яких циклічно повторюються:

```c
start = 1
кінець = 5
3, 1, 64, 2, 4, 786, 2, 9, 3
8, 3, 5, 6, 7, 1, 0, 2, 4
6, 5, 7, 1, 8, 2, 3, 4, 0
```

#### Змішані списки

Змішані списки - це масиви, що містять декілька списків одночасно. Прикладом може бути масив значень, відсортованих за списком, з іншим списком, який пов'язує всі невикористані слоти, щоб ви знали, куди можна додати нове значення. Приклад (X означає невикористаний (вільний) слот):

```c
sortedStart = 3
unusedStart = 1
значення: 34, X, X, 6, 34, 46, X, 54, 23, 25, X, 75, X, 45
sort: 4, 8, 13, 7, 11, 9, 0, -1, 5
вільно:      2, 6, 10, 12, -1
```

Очевидно, що ці два списки ніколи не взаємодіють, тому обидва можуть використовувати той самий слот для наступного значення:

```c
sortedStart = 3
unusedStart = 1
значення: 34, X, X, 6, 34, 46, X, 54, 23, 25, X, 75, X, 45
наступний:  4, 2, 6, 8, 13, 7, 10, 11, 9, 0, 12, -1, -1, 5
```

#### Код

Перш ніж ви почнете писати код, вам потрібно вирішити, який тип списку найкраще підходить для вашої програми, це повністю залежить від програми і не може бути легко висвітлено тут. Всі ці приклади є змішаними списками, один список для необхідних значень, інший для невикористаних слотів.

У цьому прикладі показано, як написати код для списку, відсортованого за зростанням.

```c
#define NUMBER_OF_VALUES (10)

enum E_DATA_LIST
{
    E_DATA_LIST_VALUE
    E_DATA_LIST_NEXT
}

новий
    gListData[КІЛЬКІСТЬ_ЗНАЧЕНЬ][E_DATA_LIST],
    gUnusedStart = 0,
    gListStart = -1; // Початок без списку

// Ця функція ініціалізує список
List_Setup()
{
    новий
        i,
        size = КІЛЬКІСТЬ_ЗНАЧЕНЬ;
    size--;
    for (i = 0; i < size; i++)
    {
        // На початку всі слоти не зайняті
        gListData[i][E_DATA_LIST_NEXT] = i + 1;
    }
    // Кінець списку
    gListData[size][E_DATA_LIST_NEXT] = -1;
}

// Ця функція додає значення до списку (з використанням базового сортування)
List_Add(value)
{
    // Перевірити, чи є вільні слоти в масиві
    if (gUnusedStart == -1) return -1;
    new
        покажчик = gListStart,
        last = -1,
        slot = gUnusedStart;
    // Додати значення в масив
    gListData[slot][E_DATA_LIST_VALUE] = value;
    // Оновити пустий список
    gUnusedStart = gListData[slot][E_DATA_LIST_NEXT];
    // Перебираємо список, доки не дійдемо до більшого/такого ж розміру числа
    while (pointer != -1 && gListData[pointer][E_DATA_LIST_VALUE] < value)
    {
        // Зберегти позицію останнього значення
        last = pointer;
        // Перехід на наступний слот
        pointer = gListData[pointer][E_DATA_LIST_NEXT];
    }
    // Якщо ми дійшли до цього місця, то у нас закінчились значення або ми досягли більшого значення
    // Перевіряємо, чи перевірили якісь числа
    if (last == -1)
    {
        // Перше число було більшим або списку немає
        // У будь-якому випадку додаємо нове значення на початок списку
        gListData[slot][E_DATA_LIST_NEXT] = gListStart;
        gListStart = slot;
    }
    else
    {
        // Помістити нове значення в список
        gListData[slot][E_DATA_LIST_NEXT] = покажчик;
        gListData[last][E_DATA_LIST_NEXT] = slot;
    }
    повернути slot;
}

// Ця функція видаляє значення з заданого слоту в масиві (повертається функцією List_Add)
List_Remove(slot)
{
    // Чи це коректний слот
    if (slot < 0 || slot >= NUMBER_OF_VALUES) return 0;
    // Спочатку знайти слот перед
    new
        покажчик = gListStart,
        last = -1;
    while (pointer != -1 && pointer != slot)
    {
        last = pointer;
        pointer = gListData[pointer][E_DATA_LIST_NEXT];
    }
    // Чи знайшли ми слот у списку
    if (pointer == -1) return 0;
    if (last == -1)
    {
        // Значення є першим у списку
        // Пропустити цей слот у списку
        gListStart = gListData[slot][E_DATA_LIST_NEXT];
    }
    else
    {
        // Значення знаходиться в списку
        // Пропустити цей слот у списку
        gListData[last][E_DATA_LIST_NEXT] = gListData[slot][E_DATA_LIST_NEXT];
    }
    // Додати цей слот до списку невикористаних
    // Невикористаний список не впорядкований, тому це не має значення
    gListData[slot][E_DATA_LIST_NEXT] = gUnusedStart;
    gUnusedStart = slot;
    return 1;
}
```

### Бінарні дерева

#### Вступ

Бінарні дерева - це дуже швидкий метод пошуку даних у масиві за допомогою спеціальної системи списків. Найбільш відомим бінарним деревом є, мабуть, гра «20 запитань», в якій за допомогою 20 запитань з варіантами відповідей «так/ні» можна отримати понад 1048576 елементів. Бінарне дерево, як випливає з його назви, є типом дерева, схожим на генеалогічне дерево, де кожен елемент має 0, 1 або 2 нащадків. Вони використовуються не для впорядкування даних, як список, а для сортування даних для дуже ефективного пошуку. По суті, ви починаєте з елемента десь посередині впорядкованого списку об'єктів (наприклад, з середнього числа у відсортованому масиві) і порівнюєте його зі значенням, яке ви хочете знайти. Якщо вони збігаються, ви знайшли потрібний об'єкт, якщо вони більші, ви переходите до об'єкта праворуч (не відразу праворуч, об'єктом праворуч від середнього об'єкта буде об'єкт на позначці три чверті), якщо вони менші, ви переходите ліворуч, і повторюєте процес.

**Приклад**

```c
1 2 5 6 7 9 12 14 17 19 23 25 28 33 38
```

У вас є попередньо впорядкований масив, і ви хочете знайти в якому слоті знаходиться число 7 (якщо воно взагалі там є), у цьому прикладі, ймовірно, ефективніше було б просто пройтись по масиву, щоб знайти його, але справа не в цьому, цей метод збільшує час лінійно зі збільшенням розміру масиву, час двійкового пошуку збільшується лінійно зі збільшенням масиву в геометричній прогресії. Тобто прямий пошук у масиві 128 big займе вдвічі більше часу, ніж у масиві 64 big, але бінарний пошук у масиві 128 big займе лише на одну перевірку більше, ніж бінарний пошук у масиві 64 big, що зовсім небагато.

Якщо ми побудуємо бінарне дерево з наведених вище даних, то отримаємо ![Бінарне дерево](https://sampwiki.blast.hk/wiki/Image:Binarytree.GIF)

Якщо читати зліва направо, ігноруючи вертикальний аспект, то можна побачити, що числа впорядковані. Тепер ми можемо спробувати знайти 7.

Початкове число 14, 7 менше за 14, тому ми переходимо до гнізда, на яке вказує ліва гілка 14. Це приводить нас до 6, 7 більше 6, тому ми йдемо праворуч до 9, а потім знову ліворуч до 7. Цей метод потребує 4 порівнянь для знаходження числа (включаючи остаточну перевірку, щоб підтвердити, що ми знаходимося на 7), при прямому переборі знадобилося б 5.

Припустимо, що 7 не існує, ми отримаємо таке бінарне дерево: ![Binarytree-7-less](https://sampwiki.blast.hk/wiki/Image:Binarytree-7-less.GIF)

На відміну від наведеного вище прикладу, воно має єдиний дочірній номер (9), а також 2 і 0 дочірні номери. Ви отримаєте повне дерево лише тоді, коли в ньому буде (2^n)-1 число (0, 1, 3, 7, 15, 31 ...), будь-які інші числа дадуть не зовсім повне дерево. У цьому випадку, коли ми дійдемо до 9, де має бути 7, ми побачимо, що лівої гілки немає, тобто 7 не існує (вона не може бути ніде більше в дереві, подумайте про це), тому ми повертаємо -1 за невірний слот.

#### Збалансовані та незбалансовані

Дерева у наведених вище прикладах називаються збалансованими бінарними деревами, це означає, що всі гілки мають однакову довжину (очевидно, що у другому прикладі для цього не вистачає чисел, але це максимально наближено). Побудова збалансованих дерев є непростим завданням, загальноприйнятим методом побудови майже збалансованих дерев є розміщення чисел у випадковому порядку, це може означати, що ви отримаєте щось на кшталт цього: ![Binarytree-uneven](https://sampwiki.blast.hk/wiki/Image:Binarytree-uneven.GIF)

Очевидно, що це дерево все ще працює, але права частина набагато більша за ліву, однак для знаходження 25 потрібно лише 7 порівнянь у цьому дереві порівняно з 12 у прямому списку. Крім того, якщо ви починаєте з досить середнього числа, метод випадкової вставки повинен створити досить збалансоване дерево. Найгірше, що ви можете зробити, це вставити числа по порядку, оскільки тоді взагалі не буде лівих гілок (або правих, якщо зробити навпаки), однак навіть у цьому найгіршому випадку пошук за бінарним деревом займе не більше часу, ніж за прямим списком.

**Модифікація**

#### Додавання

Додавання значення до бінарного дерева є відносно простим: ви просто рухаєтесь по дереву, використовуючи значення, яке ви хочете додати, як посилання, доки не дійдете до порожньої гілки і не додасте число туди. Наприклад, якщо ви хочете додати число 15 до нашого початкового збалансованого дерева, воно опиниться на лівій гілці 17. Якщо ми захочемо додати число 8 до другого збалансованого дерева (без 7), воно опиниться у старому гнізді 7 зліва від 9.

#### Видалення

Видалення числа з бінарного дерева може бути як складним, так і простим. Якщо число знаходиться в кінці гілки (наприклад, 1, 5, 7, 12 і т.д. у вихідному дереві), ви просто видаляєте його. Якщо число має лише одного нащадка (наприклад, 9 у другому прикладі), ви просто переміщуєте цього нащадка (наприклад, 12) на його місце (таким чином, нащадками числа 6 будуть 2 і 12 у новому другому прикладі з видаленим числом 9). Видалення стає цікавим лише тоді, коли вузол має двох нащадків. Існує принаймні чотири способи зробити це:

Перший спосіб є найпростішим з точки зору обчислень. Ви вибираєте одну з гілок (ліву або праву, для цього пояснення припустимо праву) і замінюєте вузол, який ви видаляєте, першим вузлом цієї гілки (тобто правим нащадком видаленого вузла). Потім ви рухаєтеся ліворуч по новій гілці до кінця і розміщуєте там ліву гілку. Наприклад, якщо ви видалили 14 з початкового прикладу, ви отримаєте 25 на вершині дерева і 6 на лівій гілці 17. Цей метод швидкий, але дуже швидко призводить до того, що дерева стають дуже незбалансованими.

Другий спосіб полягає у тому, щоб отримати всі числа, які є нащадками вузла, який ви щойно видалили, і побудувати з них нове бінарне дерево, а потім помістити вершину цього дерева у вузол, який ви щойно видалили. Цей спосіб зберігає дерево досить добре збалансованим, але, очевидно, є повільнішим.

Третій метод полягає в тому, щоб об'єднати два вищеописані методи і перебудувати дерево в лінію, він складніший для кодування, але зберігає дерево збалансованим і працює швидше, ніж другий метод (хоча і близько не так швидко, як перший).

Останній метод, описаний тут, полягає в тому, щоб просто встановити прапорець на значенні, який означає, що воно більше не використовується, це ще швидше, ніж перший метод, і зберігає структуру, але означає, що ви не можете повторно використовувати слоти, якщо не знайдете значення, яким можна замінити його пізніше.


