---
заголовок: «Binary»
description: Поглиблений погляд на бінарні та порозрядні оператори.
---

## Credits

Це з теми Підручник у форумі SA-MP. Автор - **Kyosaur**.

## Що таке двійкова система числення?

Двійкова система числення - це система числення, яка використовує два унікальні символи для представлення чисел. У той час як більш поширена десяткова система числення використовує десять цифр (**основа 10**), двійкова система використовує тільки 0 і 1. Це може здатися марним у повсякденному житті, але двійкова система числення необхідна, коли мова йде про комп'ютери. Комп'ютери на найнижчому рівні виконують всі свої обчислення, маніпулюючи потоком електрики для позначення увімкненого та вимкненого стану. Це саме те, чим є бінарний код, просто тонна перемикачів, які вмикаються і вимикаються. Для більшості людей це дещо чуже поняття, тому давайте розглянемо десяткову та двійкову системи числення поруч.

Десяткова (основа 10)

```c
0
1
2
3
4
5
6
7
8
9
10
11
12
13
```

Двійкова система числення (база 2)

```c
0 //0
1 //1
10 //2
11 //3
100 //4
101 //5
110 //6
111 //7
1000 //8
1001 //9
1010 //10
1011 //11
1100 //12
1101 //13
```

Поглянувши на обидві системи поруч, ви помітите, що вони поводяться абсолютно однаково. Як тільки ви досягаєте останнього доступного числа, ви повинні перейти на інше місце. Ці місця у двійковій системі числення називаються бітами (**b**inary dig**its**) і є просто степенями двійки; так само, як місця у десятковій системі числення є степенями 10. Щоб довести це, давайте подивимось на число 13 у стандартній системі числення.

**У наступних прикладах символ «^» позначає степінь, а не побітове виключення (про яке ми поговоримо пізніше).

Десятковий (основа 10)

```c
13

//що дорівнює

1 * (10^1) + 3 * (10^0)

//що дорівнює

10+3

//що дорівнює

13
```

Двійковий (основа 2)

```c
1101

//що дорівнює

1 * (2^3) + 1 * (2^2) + 0 * (2^1) + 1 * (2^0)

//що дорівнює

8+4+0+1

//що дорівнює

13
```

З попереднього прикладу видно, що якщо якийсь біт встановлено в 0, ми можемо ігнорувати його і рухатися далі; зрештою, все, що помножене на 0, буде 0. Попередній приклад був трохи складним, і я просто намагався бути абсолютно зрозумілим. Коли ви конвертуєте з двійкового типу, все, про що вам потрібно турбуватися, - це додати степені всіх увімкнених бітів.

Ось 12 степенів 2, які я просто пригадав:

```c
4096,2048,1024,512,256,128,64,32,16,8,4,2,1
```

Якщо ви нічого не знаєте про роботу зі степенями, то, ймовірно, це не має для вас жодного сенсу. Степінь - це число, помножене на себе х разів. З урахуванням цієї інформації, попередній список степенів, ймовірно, має більше сенсу; ну, за винятком 1. Вам може бути цікаво, чому 2, піднесене до степеня 0, дає результат 1, все, що я можу сказати на це, це те, що це просто так і є.

```c
2^1 = 2, 2^3 = 4, 2^4 = 8
```

Ми бачимо, що коли ми рухаємось праворуч, наше попереднє значення множиться на 2; тому можна припустити, що коли ми рухаємось ліворуч, наше нове значення буде просто попереднім числом, поділеним на 2. З огляду на це, ви можете побачити, як ми можемо отримати 2 в нульовому степені, що дорівнює 1. Якщо цього недостатньо, я впевнений, що ви можете знайти більше доказів на **\*\***. Враховуючи вищесказане, давайте подивимось на останній приклад, і зробимо його дещо складнішим!

```c
111011001011111000 //242424

//Пам'ятайте, ігноруємо не увімкнені біти.

1 * (2^17) = 131072

1 * (2^16) = 65536

1 * (2^15) = 32768

1 * (2^13) = 8192

1 * (2^12) = 4096

1 * (2^9) = 512

1 * (2^7) = 128

1 * (2^6) = 64

1 * (2^5) = 32

1 * (2^4) = 16

1 * (2^3) = 8


131072+65536+32768+8192+4096+512+128+64+32+16+8
=
242424
```

Пам'ятайте при перетворенні: Перший степінь дорівнює 0, тому не робіть помилки, сприймаючи 18-те місце як 2^18. Насправді існує 18 степенів, але це включаючи степінь 0, тому 17 насправді є нашим найвищим степенем.

### Глибший погляд на біти

Більшість мов програмування допускають різні типи даних, які відрізняються кількістю бітів, що можуть бути використані для зберігання інформації; проте pawn є безтиповою 32-бітною мовою. Це означає, що pawn завжди матиме 32 біти для зберігання інформації. Так що ж станеться, коли у вас буде занадто багато інформації? Відповідь на це питання лежить у площині цілих чисел зі знаком та без знаку.

#### Цілі зі знаком

Ви коли-небудь помічали, що коли ціле число в пішаку досягає високого розряду, воно перетворюється на від'ємне? Це «загортання» відбувається через те, що ви перевищуєте максимальне значення у пішаку, а саме:

```c
2^31 - 1 //Потужність, не є побітовою. Також -1 тому, що ми рахуємо 0 (існує 2,147,483,648 значень, але це з 0, тому технічно 2,147,483,647 є максимумом).

//що дорівнює

2,147,483,647

//що в двійковій системі числення дорівнює

1111111111111111111111111111111 //31 біт - всі увімкнені
```

Вам може бути цікаво, чому саме ЦЕ є максимальним значенням, а не 2^32-1 (4,294,967,295). Саме тут у гру вступають знакові та беззнакові цілі числа. Цілі зі знаком можуть зберігати від'ємні значення, а цілі без знаку - ні. Це може здатися, що я відхиляюся від теми, але запевняю вас, що це не так. Причина, по якій максимальне ціле число не дорівнює 2^32-1, полягає у тому, що 32-й біт використовується як своєрідний перемикач для від'ємних та додатних значень. Він називається MSB (Most significant bit): якщо MSB увімкнено, число буде від'ємним, якщо вимкнено - додатним. Досить просто, чи не так?

Перш ніж я покажу кілька від'ємних значень, я повинен пояснити, як від'ємні значення представлені в pawn. Для представлення від'ємних значень у Pawn використовується система, яка називається доповненням до 2, що означає, що ви перевертаєте кожен біт у вашому числі і додаєте 1 до нового числа, щоб зробити його від'ємним.

Давайте подивимось на кілька від'ємних значень, поки ця ідея все ще у вас в голові:

```c
11111111111111111111111111111111 //увімкнено всі 32 біти

//дорівнює

-1

//і

11111111111111111111111111111110

//equals

-2

//і нарешті

10000000000000000000000000000000

//equals

-2147483648
```

Бачите, всі від'ємні числа - це просто початкове додатне число з усіма його бітами, перевернутими і збільшеними на одиницю. Це дуже добре видно з нашого останнього прикладу, оскільки найбільшим додатнім числом є 2147483647.

Звідси видно, що діапазон чисел у пішаку насправді:

```c
&#8722;2^31 до +2^31 - 1
```

#### Цілі без знаку

У пішаку не існує такого поняття як беззнакові числа, але я додаю це для збалансованості. Єдина відмінність між цілим зі знаком і цілим без знаку полягає в тому, що цілі без знаку не можуть зберігати від'ємні значення; цілі числа все ще згортаються, але вони згортаються назад до 0, а не до від'ємного значення.

## Бінарні оператори

Бінарні оператори дозволяють маніпулювати окремими бітами бітової моделі. Давайте розглянемо список доступних бінарних операторів.

- Порозрядний арифметичний зсув: >> та <<
- Побітове логічне зсув: >>>
- Побітове НЕ (також відоме як доповнення): ~
- Побітове І: &
- Порозрядне АБО: |
- Побітове XOR (також відоме як виключне або): ^

### Побітове І

**ПРИМІТКА:** Не плутайте з оператором логічного І «&&».

Бінарне І просто приймає логічне І бітів у кожній позиції числа у двійковій формі. Це звучить трохи заплутано, тому давайте подивимось на нього в дії!

```c
1100 //12
&
0100 //4
=
0100 //4, оскільки обидва числа містять «100» (тобто 4)
```

Це було трохи легко, давайте подивимось на більш складний приклад:

```c
10111000 //184
&
01001000 //72
=
00001000 //8
```

Поглянувши на приклади, ви зрозумієте, що робить цей оператор. Він порівнює два бітові набори разом, якщо обидва мають спільний біт 1, то в результаті буде увімкнено той самий біт. Якщо вони не мають спільних бітів, то результат дорівнює 0.

### Побітове АБО

**ПРИМІТКА:** Не плутайте з логічним оператором АБО '||'.

Побітове АБО працює майже так само, як і побітове І. Єдина відмінність між ними полягає в тому, що побітове АБО потребує, щоб один з двох бітових шаблонів був увімкнений для того, щоб результат був увімкнений з тим самим бітом. Давайте розглянемо декілька прикладів!

```c
1100 //12
|
0100 //4
=
1100 //12.
```

Розглянемо ще один приклад.

```c
10111000 //184
|
01001000 //72
=
11111000 //248
```

Я думаю, що це досить зрозуміло, якщо одне з чисел має увімкнений біт, то результуюче число також матиме увімкнений біт.

### Побітове XOR

Цей оператор трохи схожий на побітове АБО, але є невелика різниця. Давайте подивимось на той самий приклад, що використовується у розділі побітове АБО, і подивимось, чи зможете ви помітити різницю.

```c
1100 //12
^
0100 //4
=
1000 //8.
```

і нарешті:

```c
10111000 //184
^
01001000 //72
=
11110000 //240
```

### Побітове NOT

Цей оператор перевертає кожен біт у бітовому шаблоні, перетворюючи всі 1 на 0 і навпаки.

```c
~0
=
11111111111111111111111111111111 //-1

//and

~100 //4
=
11111111111111111111111111111011 //-5

//і

~1111111111111111111111111111111 //2147483647 (не плутати з -1, який має 32 біти, а не 31)
=
10000000000000000000000000000000 //-2147483648 (увімкнено 32-й біт)
```

Якщо ви не розумієте, чому від'ємні значення «перевертаються», будь ласка, прочитайте розділ про знакові числа.

### Зсув бітів

Зсув бітів робить саме те, що ви можете собі уявити: він зсуває біти у числі у певному напрямку. Якщо ви пам'ятаєте, раніше у статті я згадував, що PAWN має певний діапазон пам'яті (32 біти, які можна використовувати для зберігання). Що відбувається, коли ви зсуваєте число за межі цього діапазону? Відповідь на це питання залежить від того, який оператор зсуву ви використовуєте і в якому напрямку ви зсуваєте.

**ПРИМІТКА:** У наступних прикладах всі двійкові числа будуть виводитися повністю (всі 32 біти), щоб уникнути плутанини.

#### Арифметичні зсуви

#### Зсув вправо

При використанні цього оператора всі біти в числі зсуваються на x кількість разів вправо. Давайте швидко розглянемо простий приклад.

```c
00000000000000000000000000001000 //8
>>
2

=

00000000000000000000000000000010 //2
```

З попереднього прикладу видно, що кожен біт було зсунуто праворуч на дві позиції, а ліворуч було додано два нулі як проміжок. Ці два нулі насправді є значенням MSB (Most significant bit) і є дуже важливими, коли мова йде про зсув цілих чисел зі знаком. Причина використання MSB як проміжку полягає у тому, що ми зберігаємо знак числа, яке зсувається. Погляньмо на той самий приклад, тільки зробимо його від'ємним.

```c
11111111111111111111111111111000 //-8
>>
2

=

11111111111111111111111111111110 //-2
```

Очевидно, що це поводиться так само, як і у попередньому прикладі, за винятком того, що ліві біти, які використовуються для зсуву, є одиницями; це доводить, що зсув праворуч дорівнює значенню MSB.

#### Зсув вліво

Це повна протилежність оператору правого арифметичного зсуву. Він зсуває всі біти числа вліво на x разів. Давайте розглянемо приклад.

```c
00000000000000000000000000001000 //8
<<
2

=

00000000000000000000000000100000 //32
```

Єдина відмінність між лівим і правим арифметичним зсувом (окрім напрямку зсуву) полягає у способі обробки проміжків. При правому арифметичному зсуві заповненням є значення MSB (молодшого значущого біта), а при лівому арифметичному зсуві - просто 0. Це пов'язано з тим, що немає відповідної інформації, наприклад, знаку числа, яку можна було б відстежувати.

```c
11111111111111111111111111111000 //-8
<<
2

=

11111111111111111111111111100000 //-32
```

Бачите? Незважаючи на те, що пропуск завжди дорівнює 0, знак числа все одно зберігається. Єдине, про що вам варто потурбуватися - це зсув убік. Якщо ви зсунете додатне число за максимально можливе значення, воно стане від'ємним, і навпаки, з від'ємними значеннями (врешті-решт ви досягнете 0).

#### Логічні зсуви

##### Зсув вправо

Це зворотний до арифметичного зсуву вліво. Найкращий спосіб описати його - це гібрид між двома арифметичними зсувами. Давайте подивимось на нього в дії!

```c
00000000000000000000000000001000 //8
>>>
2

=

00000000000000000000000000000010 //2
```

Біти у числі 8 було зсунуто на 2 рази праворуч. Чим це відрізняється від арифметичного зсуву вправо? Відповідь - заповнення. При арифметичному зсуві вправо зсув дорівнює значенню MSB, але при логічному зсуві вправо зсув дорівнює 0 (так само, як і при арифметичному зсуві вліво). Це означає, що він не буде зберігати номер знаку, і наш результат завжди буде додатнім. Щоб довести це, давайте зсунемо від'ємне число!

```c
11111111111111111111111111111000 //-8
>>>
2

=

00111111111111111111111111111110 //1073741822
```

Це доводить, що при використанні логічного зсуву вправо ми не отримаємо від'ємних значень!

##### Зсув вліво

Логічного зсуву вліво не існує, оскільки він робить те ж саме, що і арифметичний зсув вліво. Я просто додав його, щоб уникнути плутанини, а також для того, щоб зберегти збалансованість розділу.


