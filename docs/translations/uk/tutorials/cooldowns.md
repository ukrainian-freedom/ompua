---
заголовок: Cooldowns
description: Підручник з написання коулдаунів для обмеження дій користувача за допомогою підрахунку тиків та уникнення використання таймерів.
---

Цей підручник охоплює написання часто використовуваної ігрової механіки в екшн-іграх: перезавантаження. Перезарядка - це інструмент для обмеження частоти, з якою гравець може щось робити. Це може бути щось на кшталт використання здібностей, таких як зцілення або написання повідомлень у чаті. Він дозволяє сповільнити швидкість, з якою гравці виконують певні дії або з метою збалансування ігрового процесу, або для запобігання спаму.

Спочатку я покажу приклад _поганого_ способу перезавантаження за допомогою `SetTimer` для оновлення стану.

## Використання таймерів

Скажімо, наприклад, у вас є певна дія, яка може бути виконана лише раз на багато секунд, я бачив, як багато людей (включаючи Southclaws, багато років тому) робили щось подібне:

```c
static bool:IsPlayerAllowedToDoThing[MAX_PLAYERS];

OnPlayerInteractWithServer(playerid)
/* Це може бути будь-яка подія введення, яку робить гравець, наприклад
 * Введення команди
 * Підбирання пікапа
 * Вхід на контрольно-пропускний пункт
 * Натискання кнопки
 * Вхід в область
 * Використання діалогового вікна
 */
{
    // Це працює тільки тоді, коли гравцю дозволено
    if (IsPlayerAllowedToDoThing[playerid])
    {
        // Зробити те, що запросив гравець
        DoTheThingThePlayerRequested();

        // Заборонити гравцю
        IsPlayerAllowedToDoThing[playerid] = false;

        // Дозволити гравцю повторити дію через 10 секунд
        SetTimerEx(«AllowPlayer», 10000, false, «d», playerid);

        return 1;
    }
    else
    {
        SendClientMessage(playerid, -1, «Вам ще не дозволено це робити!»);

        return 0;
    }
}

// Викликається через 10 секунд після виконання дії гравцем
public AllowPlayer(playerid)
{
    IsPlayerAllowedToDoThing[playerid] = true;
    SendClientMessage(playerid, -1, «Вам дозволено зробити це знову! :D»);
}
```

Тепер це все добре, це працює, гравець не зможе зробити цю річ знову протягом 10 секунд після того, як він її використає.

Візьмемо інший приклад, це секундомір, який вимірює, скільки часу потрібно гравцеві, щоб зробити простий забіг від точки до точки:

```c
статичний
    StopWatchTimerID[MAX_PLAYERS],
    StopWatchTotalTime[MAX_PLAYERS];

StartPlayerRace(playerid)
{
    // Викликає функцію щосекунди
    StopWatchTimerID[playerid] = SetTimerEx(«StopWatch», 1000, true, «d», playerid);
}

public StopWatch(playerid)
{
    // Збільшити лічильник секунд
    StopWatchTotalTime[playerid]++;
}

OnPlayerFinishRace(playerid)
{
    new str[128];

    format(str, 128, «Ви витратили на це %d секунд», StopWatchTotalTime[playerid]);
    SendClientMessage(playerid, -1, str);

    KillTimer(StopWatchTimerID[playerid]);
}
```

Ці два приклади є поширеними і можуть чудово працювати. Однак, є набагато кращий спосіб досягти обох цих результатів, який є більш точним і може давати таймінг секундоміра з точністю до мілісекунди!

## Використання функцій `GetTickCount()` та `gettime()`

`GetTickCount()` - це функція, яка повертає час у мілісекундах з моменту відкриття серверного процесу. `gettime()` повертає кількість секунд з 1 січня 1970 року, також відому як Unix Timestamp.

Якщо ви викличете будь-яку з цих функцій у два різні моменти часу і віднімете перший час від другого, ви раптом отримаєте інтервал між цими двома подіями у мілісекундах або секундах відповідно! Погляньте на цей приклад:

### A Cooldown

```c
static PlayerAllowedTick[MAX_PLAYERS];

OnPlayerInteractWithServer(playerid)
{
   if (GetTickCount() - PlayerAllowedTick[playerid] > 10000)
   // Це працює тільки тоді, коли поточний тик мінус останній тик більше 10000.
   // Іншими словами, це працює тільки тоді, коли інтервал між діями більше 10 секунд.
   {
       DoTheThingThePlayerRequested();
       PlayerAllowedTick[playerid] = GetTickCount(); // Оновити лічильник тиків останнім часом.

       return 1;
   }
   else
   {
       SendClientMessage(playerid, -1, «Вам ще не дозволено це робити!»);

       return 0;
   }
}
```

Або, як альтернатива, версія `gettime()`:

```c
static PlayerAllowedSeconds[MAX_PLAYERS];

OnPlayerInteractWithServer(playerid)
{
   if (gettime() - PlayerAllowedSeconds[playerid] > 10)
   // Це працює тільки тоді, коли поточні секунди мінус останні секунди більше 10.
   // Іншими словами, це працює тільки тоді, коли інтервал між діями більше 10 секунд.
   {
       DoTheThingThePlayerRequested();
       PlayerAllowedSeconds[playerid] = gettime(); // Оновлюємо лічильник секунд останнім часом.

       return 1;
   }
   else
   {
       SendClientMessage(playerid, -1, «Вам ще не дозволено це робити!»);

       return 0;
   }
}
```

Тут набагато менше коду, немає необхідності в публічній функції або таймері. Якщо ви дійсно хочете, ви можете вивести час, що залишився, у повідомленні про помилку:

(У цьому прикладі я використовую SendFormatMessage)

```c
SendFormatMessage(
    playerid,
    -1,
    «Вам ще не дозволено це робити! Ви зможете знову через %d мс»,
    10000 - (GetTickCount() - PlayerAllowedTick[playerid])
);
```

Це дуже простий приклад, було б краще перетворити значення MS у рядок `хвилини:секунди.мілісекунди`, але я опублікую цей код наприкінці.

### Секундомір

Сподіваюся, ви бачите, наскільки це потужний засіб для отримання інтервалів між подіями, давайте розглянемо ще один приклад

```c
static Stopwatch[MAX_PLAYERS];

StartPlayerRace(playerid)
{
    Stopwatch[playerid] = GetTickCount();
}

OnPlayerFinishRace(playerid)
{
    новий
        інтервал,
        str[128];

    interval = GetTickCount() - Секундомір[playerid];

    format(str, 128, «Ви витратили на це %d мілісекунд», interval);
    SendClientMessage(playerid, -1, str);
}
```

У цьому прикладі кількість тиків зберігається у змінну player, коли гравець починає гонку. Коли він фінішує, від поточного тику віднімається початковий тик (менше значення) і, таким чином, ми отримуємо кількість мілісекунд між початком і кінцем забігу.

#### Розбиття

Тепер давайте трохи розберемо код.

```c
new Секундомір[MAX_PLAYERS];
```

Це глобальна змінна, нам потрібно використовувати її для того, щоб зберегти кількість тиків і отримати значення в інший момент часу (іншими словами, використовувати її в іншій функції, пізніше)

```c
StartPlayerRace(playerid)
{
    Секундомір[playerid] = GetTickCount();
}
```

Це коли гравець починає гонку, записується поточний відлік часу, якщо це відбувається через 1 хвилину після запуску сервера, значення цієї змінної буде 60,000, тому що це 60 секунд, а кожна секунда має тисячу мілісекунд.

Отже, ми встановили змінну цього гравця на 60,000, тепер він закінчить гонку через 1 хвилину 40 секунд:

```c
OnPlayerFinishRace(playerid)
{
    новий
        інтервал,
        str[128];

    interval = GetTickCount() - Секундомір[playerid];

    format(str, 128, «Ви витратили на це %d мілісекунд», interval);
    SendClientMessage(playerid, -1, str);
}
```

Тут відбувається розрахунок інтервалу, ну, я ж кажу розрахунок, це ж просто віднімання двох значень!

GetTickCount() повертає поточний лічильник тиків, тому він буде більшим за початковий лічильник тиків, а це означає, що ви віднімаєте початковий лічильник тиків від поточного, щоб отримати інтервал між двома вимірами.

Отже, як ми вже казали, гравець фінішує через 1 хвилину і 40 секунд (100 секунд, або 100 000 мілісекунд), GetTickCount поверне 160 000. Відніміть початкове значення (яке дорівнює 60,000) від нового значення (яке дорівнює 160,000) і ви отримаєте 100,000 мілісекунд, що дорівнює 1 хвилині 40 секундам, тобто часу, який знадобився гравцеві для проходження забігу!

## Підсумки та примітки

Отже, ми все зрозуміли:

- GetTickCount повертає кількість часу в мілісекундах з моменту запуску комп'ютерної системи, на якій працює сервер.
- І ми можемо використовувати це, викликаючи її з двома інтервалами, зберігаючи перше значення у змінну і порівнюючи ці два значення, щоб отримати точний інтервал у мілісекундах між цими двома подіями.

Нарешті, ви ж не хочете повідомляти гравцям значення часу в мілісекундах! Що, якщо їм знадобиться година, щоб завершити гонку?

Найкраще використовувати функцію, яка приймає мілісекунди і перетворює їх у читабельний формат, наприклад, у попередньому прикладі гравець витратив 100,000 мілісекунд на проходження забігу, якщо ви скажете гравцеві, що він витратив стільки часу, йому знадобиться більше часу, щоб прочитати ці 100,000 і зрозуміти, що вони означають у читабельному для людини часі.

[Цей пакунок](https://github.com/ScavengeSurvive/timeutil) містить функцію для форматування мілісекунд у рядок.

Сподіваюся, це допомогло! Я написав його тому, що нещодавно допоміг кільком людям, які не знали, як використовувати `GetTickCount()` або `gettime()` як альтернативу для таймерів або для отримання інтервалів тощо.


