---
title: "Ключові слова: Initialisers"
---

## `const`

```c
new const
    MY_CONSTANT[] = {1, 2, 3};
```

const не є широко використовуваною, проте вона оголошує змінну, яку не можна змінювати у коді. Для цього є кілька застосувань - функції з параметрами масиву const іноді можуть бути скомпільовані більш ефективно, або вам може знадобитися щось на зразок define, але у вигляді масиву. const - це модифікатор, він повинен йти з new або іншим декларатором змінної. Якщо ви спробуєте модифікувати змінну const, компілятор поскаржиться.

## `enum`

Зчислення є дуже корисною системою для представлення великих груп даних і швидкої модифікації констант. Існує кілька основних способів використання - заміна великих наборів інструкцій define, символічне представлення слотів масивів (це фактично одне і те ж, але виглядає по-різному) і створення нових тегів.

Найпоширеніше використання - це визначення масивів:

```c
enum E_MY_ARRAY
{
    E_MY_ARRAY_MONEY,
    E_MY_ARRAY_GUN
}

new
    gPlayerData[MAX_PLAYERS][E_MY_ARRAY];

public OnPlayerConnect(playerid)
{
    gPlayerData[playerid][E_MY_ARRAY_MONEY] = 0;
    gPlayerData[playerid][E_MY_ARRAY_GUN] = 5
}
```

Це створить масив з двома слотами для кожного гравця. У той, на який посилається E_MY_ARRAY_MONEY, буде записано 0, коли гравець підключиться, а в E_MY_ARRAY_GUN - 5. Без перечислення це виглядало б так:

```c
новий
    gPlayerData[MAX_PLAYERS][2];

public OnPlayerConnect(playerid)
{
    gPlayerData[playerid][0] = 0;
    gPlayerData[playerid][1] = 5
}
```

І ось так компілюється перший файл. Це добре, але він менш читабельний - для чого потрібен слот 0 і для чого потрібен слот 1? І він менш гнучкий, якщо ви хочете додати ще один слот між 0 і 1, вам доведеться перейменувати всі ваші 1 на 2, додати новий слот і сподіватися, що ви нічого не пропустили, в той час як зі зчисленням ви можете це зробити просто:

```c
enum E_MY_ARRAY
{
    E_MY_ARRAY_MONEY,
    E_MY_ARRAY_AMMO,
    E_MY_ARRAY_GUN
}

new
    gPlayerData[MAX_PLAYERS][E_MY_ARRAY];

public OnPlayerConnect(playerid)
{
    gPlayerData[playerid][E_MY_ARRAY_MONEY] = 0;
    gPlayerData[playerid][E_MY_ARRAY_AMMO] = 100
    gPlayerData[playerid][E_MY_ARRAY_GUN] = 5;
}
```

Перекомпілюйте і все оновиться для вас.

Тож як перечислення знає, які значення надавати об'єктам? Повний формат перечислення виглядає наступним чином:

```c
enum NAME (модифікатор)
{
    NAME_ENTRY_1 = value,
    NAME_ENTRY_2 = value,
    ...
    NAME_ENTRY_N = value
}
```

Однак багато чого з цього мається на увазі. За замовчуванням, якщо ви не вказуєте модифікатор, він стає (+= 1), це означає, що кожне значення у зчисленні є останнім значенням у зчисленні + 1, тому for:

```c
enum E_EXAMPLE
{
    E_EXAMPLE_0,
    E_EXAMPLE_1,
    E_EXAMPLE_2
}
```

Перше значення (E_EXAMPLE_0) дорівнює 0 (за замовчуванням, якщо не вказано інше значення), тому друге значення (E_EXAMPLE_1) дорівнює 1 (0 + 1), а третє значення (E_EXAMPLE_2) - 2 (1 + 1). Це робить значення E_EXAMPLE 3 (2 + 1), ім'я зчислення також є останнім значенням у зчисленні. Якщо ми змінимо модифікатор, то отримаємо інші значення:

```c
enum E_EXAMPLE (+= 5)
{
    E_EXAMPLE_0,
    E_EXAMPLE_1,
    E_EXAMPLE_2
}
```

У цьому прикладі кожне значення дорівнює останньому значенню + 5, тому, знову починаючи з 0, ми отримуємо: E_EXAMPLE_0 = 0, E_EXAMPLE_1 = 5, E_EXAMPLE_2 = 10, E_EXAMPLE = 15. Якщо ви оголосите масив of:

```c
новий
    gEnumArray[E_EXAMPLE];
```

Ви отримаєте масив розміром 15 клітинок, але ви зможете отримати доступ лише до клітинок 0, 5 і 10, використовуючи значення перечислення (ви також можете використовувати звичайні числа). Розглянемо інший приклад:

```c
enum E_EXAMPLE (*= 2)
{
    E_EXAMPLE_0,
    E_EXAMPLE_1,
    E_EXAMPLE_2
}
```

У цьому рядку всі значення дорівнюють 0. Чому? Ну, перше значення за замовчуванням дорівнює 0, потім 0 _ 2 = 0, потім 0 _ 2 = 0 і 0 \* 2 = 0. Тож як нам це виправити? Для цього існують користувацькі значення:

```c
enum E_EXAMPLE (*= 2)
{
    E_EXAMPLE_0 = 1,
    E_EXAMPLE_1,
    E_EXAMPLE_2
}
```

Це встановить перше значення на 1, тож ви отримаєте 1, 2, 4 і 8. Якщо ви створите масив з цими значеннями, то отримаєте масив з 8 клітинок з іменованим доступом до клітинок 1, 2 і 4. Ви можете встановити будь-які значення, які вам подобаються, і стільки значень, скільки вам потрібно:

```c
enum E_EXAMPLE (*= 2)
{
    E_EXAMPLE_0,
    E_EXAMPLE_1 = 1,
    E_EXAMPLE_2
}
```

Дає:

```c
0, 1, 2, 4
```

Поки що:

```c
enum E_EXAMPLE (*= 2)
{
    E_EXAMPLE_0 = 1,
    E_EXAMPLE_1 = 1,
    E_EXAMPLE_2 = 1
}
```

Дає:

```c
1, 1, 1, 2
```

Для масивів не рекомендується використовувати нічого, крім += 1.

Ви також можете використовувати масиви у переліках:

```c
enum E_EXAMPLE
{
    E_EXAMPLE_0[10],
    E_EXAMPLE_1,
    E_EXAMPLE_2
}
```

Тоді E_EXAMPLE_0 = 0, E_EXAMPLE_1 = 10, E_EXAMPLE_2 = 11 і E_EXAMPLE = 12, всупереч поширеній думці про 0, 1, 2 і 3.

елементи переліків також можуть мати теги, тому у нашому прикладі:

```c
enum E_MY_ARRAY
{
    E_MY_ARRAY_MONEY,
    E_MY_ARRAY_AMMO,
    Float:E_MY_ARRAY_HEALTH,
    E_MY_ARRAY_GUN
}

new
    gPlayerData[MAX_PLAYERS][E_MY_ARRAY];

public OnPlayerConnect(playerid)
{
    gPlayerData[playerid][E_MY_ARRAY_MONEY] = 0;
    gPlayerData[playerid][E_MY_ARRAY_AMMO] = 100
    gPlayerData[playerid][E_MY_ARRAY_GUN] = 5;
    gPlayerData[playerid][E_MY_ARRAY_HEALTH] = 50.0;
}
```

Це не призведе до невідповідності тегів.

Переліки також можна використовувати як теги:

```c
enum E_MY_TAG (<<= 1)
{
    E_MY_TAG_NONE,
    E_MY_TAG_VAL_1 = 1,
    E_MY_TAG_VAL_2,
    E_MY_TAG_VAL_3,
    E_MY_TAG_VAL_4
}

новий
    E_MY_TAG:gMyTagVar = E_MY_TAG_VAL_2 | E_MY_TAG_VAL_3;
```

Це створить нову змінну і присвоїть їй значення 6 (4 | 2), і вона матиме спеціальний тег:

```c
gMyTagVar = 7;
```

Згенерує попередження про невідповідність тегів, хоча ви можете використати перезапис тегів, щоб обійти його:

```c
gMyTagVar = E_MY_TAG:7;
```

Це може бути дуже корисно для прапорцевих даних (тобто один біт для деяких даних) або навіть комбінованих даних:

```c
enum E_MY_TAG (<<= 1)
{
    E_MY_TAG_NONE,
    E_MY_TAG_MASK = 0xFF,
    E_MY_TAG_VAL_1 = 0x100,
    E_MY_TAG_VAL_2,
    E_MY_TAG_VAL_3,
    E_MY_TAG_VAL_4
}

новий
    E_MY_TAG:gMyTagVar = E_MY_TAG_VAL_2 | E_MY_TAG_VAL_3 | (E_MY_TAG:7 & E_MY_TAG_MASK);
```

Це дасть значення 1543 (0x0607).

Нарешті, як було сказано спочатку, перелічення можна використовувати для заміни визначень, опускаючи їхні імена:

```c
#define TEAM_NONE 0
#define TEAM_COP 1
#define TEAM_ROBBER 2
#define TEAM_CIV 3
#define TEAM_CLERK 4
#define TEAM_DRIVER 5
```

Я впевнений, що багато хто з вас бачив багато подібних речей для визначення команд. Це все добре, але це дуже статично. Це можна легко замінити переліком для автоматичної обробки числових присвоєнь:

```c
enum
{
    TEAM_NONE,
    TEAM_COP,
    TEAM_ROBBER,
    TEAM_CIV,
    TEAM_CLERK,
    TEAM_DRIVER
}
```

Всі вони мають ті ж самі значення, що й раніше, і можуть бути використані в той же самий спосіб:

```c
новий
    gPlayerTeam[MAX_PLAYERS] = {TEAM_NONE, ...};

public OnPlayerConnect(playerid)
{
    gPlayerTeam[playerid] = TEAM_NONE;
}

public OnPlayerRequestSpawn(playerid)
{
    if (gPlayerSkin[playerid] == gCopSkin)
    {
        gPlayerTeam[playerid] = TEAM_COP;
    }
}
```

Якщо вже ми заговорили про це, то є набагато кращий спосіб визначення команд, заснований на цьому методі:

```c
enum (<<= 1)
{
    TEAM_NONE,
    TEAM_COP = 1,
    TEAM_ROBBER,
    TEAM_CIV,
    TEAM_CLERK,
    TEAM_DRIVER
}
```

Тепер TEAM_COP дорівнює 1, TEAM_ROBBER дорівнює 2, TEAM_CIV дорівнює 4 і т.д., що в двійковому вигляді дорівнює 0b00000001, 0b00000010 і 0b00000100. Це означає, що якщо команда гравця дорівнює 3, то він є і в команді копів, і в команді грабіжників. Це може звучати безглуздо, але це відкриває можливості:

```c
enum (<<= 1)
{
    TEAM_NONE,
    TEAM_COP = 1,
    TEAM_ROBBER,
    TEAM_CIV,
    TEAM_CLERK,
    TEAM_DRIVER,
    TEAM_ADMIN
}
```

Використовуючи це, ви можете бути як у звичайній команді, так і в команді адміністратора, використовуючи лише одну змінну. Очевидно, що потрібна невелика модифікація коду, але це нескладно:

Додати гравця до команди:

```c
gPlayerTeam[playerid] |= TEAM_COP;
```

Видалити гравця з команди:

```c
gPlayerTeam[playerid] &= ~TEAM_COP;
```

Перевірити, чи є гравець у команді:

```c
if (gPlayerTeam[playerid] & TEAM_COP)
```

Дуже просто і дуже корисно.

## Вперед.

forward повідомляє компілятору, що функція буде виконана пізніше. Він є обов'язковим для всіх загальнодоступних функцій, проте може використовуватися і в інших місцях. Вона використовується за допомогою команди "forward", за якою слідує повна назва і параметри функції, яку ви хочете переслати, після чого ставиться крапка з комою:

```c
forward MyPublicFunction(playerid, const string[]);

public MyPublicFunction(playerid, const string[])
{
}
```

Крім того, що forward є обов'язковим для всіх пабліків, його можна використовувати для виправлення рідкісного попередження, коли функція, яка повертає результат тегу (наприклад, float), використовується до того, як вона була оголошена.

```c
main()
{
    new
        Float:myVar = MyFloatFunction();
}

Float:MyFloatFunction()
{
    return 5.0;
}
```

Компілятор видасть попередження про помилку, оскільки він не знає, як перетворити результат функції у число з плаваючою комою, оскільки не знає, чи функція повертає звичайне число, чи число з плаваючою комою. Очевидно, що у цьому прикладі функція повертає число з плаваючою комою. Цю проблему можна вирішити, помістивши функцію в певну точку коду перед її використанням:

```c
Float:MyFloatFunction()
{
    return 5.0;
}

main()
{
    new
        Float:myVar = MyFloatFunction();
}
```

Або переадресувавши функцію, щоб компілятор знав, що робити:

```c
forward Float:MyFloatFunction();

main()
{
    new
        Float:myVar = MyFloatFunction();
}

Float:MyFloatFunction()
{
    return 5.0;
}
```

Зверніть увагу, що тег forward також включає в себе тег return.

## "корінний

Нативна функція - це функція, визначена у віртуальній машині (тобто у тому, що запускає скрипт), а не у самому скрипті. Ви можете визначати нативні функції, лише якщо вони закодовані у SA:MP або плагіні, однак ви можете створювати фальшиві нативні функції. Оскільки нативні функції з файлів .inc визначаються pawno і відображаються у вікні праворуч від pawno, може бути корисно використовувати native для додавання туди ваших власних функцій. Звичайне оголошення native може мати такий вигляд:

```c
native printf(const format[], {Float,_}:...);
```

Якщо ви хочете, щоб ваші власні функції відображалися без оголошення native, ви можете це зробити:

```c
/*
native MyFunction(playerid);
*/
```

PAWNO не розпізнає такі коментарі, тому додасть функцію до списку, але компілятор розпізнає такі коментарі, тому проігнорує оголошення.

Інша цікава річ, яку можна зробити з native - це перейменування/перевантаження функцій:

```c
native my_print(const string[]) = print;
```

Тепер функції print фактично не існує. Вона все ще є у SA:MP, і компілятор знає її справжнє ім'я завдяки частині "= print", але якщо ви спробуєте викликати її у PAWN, ви отримаєте помилку, оскільки ви перейменували print внутрішньо на my_print. Оскільки print тепер не існує, ви можете визначити її так само, як і будь-яку іншу функцію:

```c
print(const string[])
{
    my_print("Хтось викликав print()");
    my_print(string);
}
```

Тепер щоразу, коли у скрипті використовується print(), ваша функція буде викликатися замість оригіналу, і ви можете робити все, що вам заманеться. У цьому випадку спочатку буде надруковано інше повідомлення, а потім оригінальне.

## "новий

Це ядро змінних, одне з найважливіших ключових слів about. new оголошує нову змінну:

```c
новий
    myVar = 5;
```

Це створить змінну, назве її myVar і присвоїть їй значення 5. За замовчуванням всі змінні дорівнюють 0, якщо нічого не вказано:

```c
новий
    myVar;

printf("%d", myVar);
```

Дасть "0".

Область видимості змінної - це місце, де її можна використовувати. Область видимості обмежена фігурними дужками (фігурні дужки - {} ), будь-яка змінна, оголошена всередині набору дужок, може бути використана тільки в межах цих дужок.

```c
if (a == 1)
{
    // За дужками починається рядок вище цього
    новий
        myVar = 5;

    // Цей printf знаходиться у тих самих дужках, тому може використовувати myVar.
    printf("%d", myVar);

    // Цей оператор if також знаходиться в дужках, тому він і все, що в ньому, може використовувати myVar
    if (myVar == 1)
    {
        printf("%d", myVar);
    }
    // Дужки завершують рядок нижче цього
}
// Це знаходиться за дужками, тому дасть помилку
printf("%d", myVar);
```

Наведений вище приклад також показує, чому правильний відступ так важливий.

Якщо глобальну змінну (тобто змінну, оголошену поза функцією) оголошено новою, її можна використовувати всюди після оголошення:

File1.pwn:

```c
MyFunc1()
{
    // Помилка, gMyVar ще не існує
    printf("%d", gMyVar);
}

// Тут оголошується gMyVar
new
    gMyVar = 10;

MuFunc2()
{
    // Добре, оскільки gMyVar тепер існує
    printf("%d", gMyVar);
}

// Включіть сюди ще один файл
#include "file2.pwn"
```

file2.pwn:

```c
MyFunc3()
{
    // Це також добре, оскільки цей файл включається в перший файл після оголошення, а new не є файловим обмеженням
    printf("%d", gMyVar);
}
```

## "Оператор

Це дозволяє перевантажувати оператори для кастомних тегів. Наприклад:

```c
stock BigEndian:operator=(b)
{
    return BigEndian:(((b >>> 24) & 0x000000FF) | ((b >>> 8) & 0x0000FF00) | ((b << 8) & 0x00FF0000) | ((b << 24) & 0xFF000000));
}

main()
{
    new
        BigEndian:a = 7;
    printf("%d", _:a);
}
```

Звичайні числа пішаків зберігаються у так званому малому ендіані. Цей оператор дозволяє визначити присвоєння для перетворення звичайного числа у число з великим ендіаном. Різниця між big endian і little endian полягає у порядку байт. 7 у малому ендіані зберігається як:

```c
07 00 00 00
```

7 у великому ендіані зберігається як:

```c
00 00 00 07
```

Тому, якщо ви виводите вміст збереженого числа з великим ендіанським кодом, програма спробує прочитати його як число з малим ендіанським кодом і отримати його у зворотному порядку, таким чином виводячи число 0x07000000, також відоме як 117440512, що і буде виведено, якщо ви виконаєте цей код.

Ви можете перевантажити наступні оператори:

```c
+, -, *, /, %, ++, --, ==, !=, <, >, <=, >=, ! і =
```

Також зауважте, що ви можете змусити їх робити все, що вам заманеться:

```c
stock BigEndian:operator+(BigEndian:a, BigEndian:b)
{
    return BigEndian:42;
}

main()
{
    new
        BigEndian:a = 7,
        BigEndian:b = 199;
    printf("%d", _:(a + b));
```

Просто дасть 42, нічого спільного з додаванням.

## "громадськість

public використовується для того, щоб зробити функцію видимою для віртуальної машини, тобто дозволяє серверу SA:MP викликати функцію безпосередньо, замість того, щоб дозволяти викликати функцію лише зсередини PAWN-скрипту. Ви також можете зробити змінні загальнодоступними, щоб читати і записувати їхні значення з сервера, однак це ніколи не використовується у SA:MP (хоча ви можете використовувати це у плагінах, я ніколи не пробував) (ви також можете комбінувати це з const, щоб створити змінну, яку можна змінювати ЛИШЕ з сервера).

Загальнодоступна функція має текстове ім'я, яке зберігається в amx-файлі, на відміну від звичайних функцій, які зберігають лише свою адресу для переходів, що є ще одним недоліком декомпіляції. Це робиться для того, щоб ви могли викликати функцію за іменем ззовні скрипта, а також для того, щоб ви могли викликати функції за іменем зсередини скрипта, виходячи з нього і входячи знову. Виклик власної функції майже протилежний виклику загальнодоступної функції, він викликає функцію за межами скрипта зсередини скрипта, на відміну від виклику функції всередині скрипта ззовні скрипта. Якщо об'єднати ці два способи, ви отримаєте такі функції, як SetTimer, SetTimerEx, CallRemoteFunction і CallLocalFunction, які викликають функції за іменем, а не за адресою.

Виклик функції за іменем:

```c
переслати MyPublicFunc();

main()
{
    CallLocalFunction("MyPublicFunc", "");
}

public MyPublicFunc()
{
    printf("Hello");
}
```

публічні функції з префіксом "public" або "@" і, як зазначено в розділі пересилання, всі вони потребують пересилання:

```c
forward MyPublicFunc();
переслати @MyOtherPublicFunc(var);

main()
{
    CallLocalFunction("MyPublicFunc", "");
    SetTimerEx("@MyOtherPublicFunc", 5000, 0, "i", 7);
}

public MyPublicFunc()
{
    printf("Hello");
}

@MyOtherPublicFunc(var)
{
    printf("%d", var);
}
```

Очевидно, що у цьому прикладі було введено SetTimerEx для виклику "MyOtherPublicFunc" через 5 секунд і передачі йому цілого значення 7 для друку.

main, що використовується в більшості цих прикладів, схожа на загальнодоступну функцію тим, що її можна викликати ззовні скрипта, однак вона не є загальнодоступною функцією - вона просто має спеціальну відому адресу, щоб сервер знав, куди перейти, щоб її запустити.

Усі зворотні виклики SA:MP є публічними і викликаються ззовні скрипту автоматично:

```c
public OnPlayerConnect(playerid)
{
    printf("%d підключено", playerid);
}
```

Коли хтось приєднується до сервера, він автоматично шукає цю загальнодоступну функцію у всіх скриптах (спочатку в режимі гри, потім у скриптах фільтрів), і якщо знаходить її, викликає.

Якщо ви хочете викликати загальнодоступну функцію зсередини скрипта, але вам не обов'язково називати її по імені, загальнодоступні функції також поводяться як звичайні функції:

```c
переслати MyPublicFunc();

main()
{
    MyPublicFunc();
}

public MyPublicFunc()
{
    printf("Hello");
}
```

Очевидно, що це набагато швидше, ніж використання CallLocalFunction або іншої нативної функції.

## "Статика

Статична змінна схожа на глобальну нову змінну, але з більш обмеженою сферою застосування. Коли статична змінна використовується глобально, створені змінні обмежуються лише розділом, у якому їх було створено (див. #розділ). Отже, візьмемо попередній приклад з "new":

**file1.pwn**.

```c
MyFunc1()
{
    // Помилка, gMyVar ще не існує
    printf("%d", gMyVar);
}

// Тут оголошується gMyVar
new
    gMyVar = 10;

MuFunc2()
{
    // Добре, оскільки gMyVar тепер існує
    printf("%d", gMyVar);
}

// Включіть сюди ще один файл
#include "file2.pwn"
```

file2.pwn

```c
MyFunc3()
{
    // Це також добре, оскільки цей файл включається в перший файл після оголошення, а new не є файловим обмеженням
    printf("%d", gMyVar);
}
```

А модифікація його для статичного режиму дасть:

file1.pwn

```c
MyFunc1()
{
    // Помилка, g_sMyVar ще не існує
    printf("%d", g_sMyVar);
}

// Тут оголошується g_sMyVar
статичний
    g_sMyVar = 10;

MuFunc2()
{
    // Добре, оскільки _sgMyVar тепер існує
    printf("%d", g_sMyVar);
}

// Включіть сюди ще один файл
#include "file2.pwn"
```

file2.pwn

```c
MyFunc3()
{
    // Помилка, g_sMyVar обмежена тільки тим файлом (або розділом), в якому вона була оголошена, а це інший файл
    printf("%d", g_sMyVar);
}
```

Це означає, що ви можете мати дві глобули з однаковими іменами в різних файлах.

Якщо ви використовуєте static локально (тобто у функції), то змінна, як і локальні змінні, створені за допомогою new, може бути використана лише в межах області видимості (на основі фігурних дужок - див. розділ про new), в якій вона була оголошена. Однак, на відміну від "нових" змінних, "статичні" змінні не втрачають свого значення між викликами.

```c
main()
{
    for (new loopVar = 0; loopVar < 4; loopVar++)
    {
        MyFunc();
    }
}

MyFunc()
{
    new
        i = 0;
    printf("%d", i);
    i++;
    printf("%d", i);
}
```

При кожному виклику функції i скидається в 0, тому результуючий вивід буде таким:

```c
0
1
0
1
0
1
0
1
```

Якщо ми замінимо "новий" на "статичний", то отримаємо:

```c
main()
{
    for (new loopVar = 0; loopVar < 4; loopVar++)
    {
        MyFunc();
    }
}

MyFunc()
{
    статичний
        i = 0;
    printf("%d", i);
    i++;
    printf("%d", i);
}
```

І, оскільки статичні локалі зберігають своє значення між викликами, результат виводить його:

```c
0
1
1
2
2
3
3
4
```

Значення, вказане в оголошенні (якщо воно вказане, як у випадку з новими статичними змінними, за замовчуванням дорівнює 0), є значенням, яке присвоюється змінній при першому виклику функції. Отже, якщо замість цього використати "static i = 5;", результат буде таким:

```c
5
6
6
7
7
8
8
9
```

Через те, що статичні змінні зберігаються фактично як глобальні, компілятор перевіряє, чи використовуються вони в правильному місці. В результаті декомпільовані скрипти не можуть відрізнити звичайні глобали, глобальну статику від локальної, і всі вони видаються як звичайні глобали.

Ви також можете мати статичні функції, які можна викликати лише з файлу, в якому вони оголошені. Це корисно для функцій приватного стилю.

## "Запас

stock використовується для оголошення змінних і функцій, які можуть не використовуватися, але для яких ви не хочете генерувати попередження про невикористання. У випадку зі змінними stock схожий на const, оскільки є модифікатором, а не повним оголошенням, тому ви можете використовувати його:

```c
новий запас
    можна використовувати;

статичний запас
    g_sMayBeUsedVar;
```

Якщо змінна або функція використовується, компілятор включить її, якщо не використовується - виключить. Це відрізняється від використання #pragma unused (символ), оскільки воно просто витіснить (тобто приховає) попередження і все одно включить інформацію, а сток повністю проігнорує невикористані дані.

stock найчастіше використовується для користувацьких бібліотек. Якщо ви пишете бібліотеку, ви надаєте цілу низку функцій для використання іншими людьми, але ви не знаєте, чи будуть вони ними користуватися. Якщо ваш код видає безліч попереджень на кожну функцію, якою людина не користується, люди будуть скаржитися (якщо тільки це не зроблено навмисно, оскільки вони МАЮТЬ використовувати цю функцію (наприклад, для ініціалізації змінних). Однак, виходячи з особистого досвіду роботи з YSI, люди будуть скаржитися в будь-якому випадку.

```c
main()
{
    Func1();
}

Func1()
{
    printf("Hello");
}

Func2()
{
    printf("Hi");
}
```

Тут Func2 ніколи не викликається, тому компілятор видасть попередження. Це може бути корисно, оскільки ви могли забути викликати цю функцію, як це зазвичай буває у прямому скрипті, але якщо Func1 і Func2 знаходяться у бібліотеці, користувачеві може просто не знадобитися Func2, тому ви її викликаєте:

```c
main()
{
    Func1();
}

stock Func1()
{
    printf("Hello");
}

stock Func2()
{
    printf("Hi");
}
```

І функція не буде скомпільована, а попередження видалено.


