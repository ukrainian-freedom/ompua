# Підводні камені: відмінності від C

---

- У PAWN відсутній механізм типізації C. PAWN - це "цілочисельний" різновид C; у ній немає структур та об'єднань, а підтримка плаваючої точки має бути реалізована за допомогою визначених користувачем операторів та власних функцій.

- Прийнятий синтаксис для раціональних чисел суворіший, ніж для значень з плаваючою комою у C. Такі значення, як ".5" та "6." є прийнятними у C, але у PAWN потрібно писати "0.5" та "6.0" відповідно. У C десяткова крапка не є обов'язковою, якщо експонента включена, тому можна написати "2E8"; PAWN не приймає верхній регістр "E" (використовуйте нижній регістр "e") і вимагає десяткову крапку: наприклад, "2.0e8". Додаткову інформацію див. на сторінці 98.

- PAWN не надає "вказівників". Для передачі аргументів функції за посиланням у PAWN передбачено аргумент "посилання" (стор. 71). Аргумент "заповнювач" замінює деякі випадки використання вказівника NULL (стор. 75).

- Числа можуть мати шістнадцятковий, десятковий або двійковий радікс. Вісімковий радікс не підтримується. Див. розділ "Константи" на сторінці 98. Шістнадцяткові числа повинні починатися з "0x" (маленької літери "x"), префікс "0X" є неприпустимим.

- Послідовності екранування ("\n", "\t" і т.д.) такі самі, за винятком "\ddd", де "ddd" позначає три десяткові цифри, замість вісімкових цифр, які використовуються у C/C++. Зворотну косу риску ("\") можна замінити іншим символом; див. розділ #pragma ctrlchar на сторінці 120 - зауважте, що у попередніх версіях PAWN як символ екранування використовувався символ каретки ("^").

- Регістри в операторі switch не "пропадають". Після кожної мітки регістру може (і повинна) виконуватися лише одна інструкція. Щоб виконати декілька інструкцій, потрібно використовувати складений оператор. Інструкція за замовчуванням повинна бути останньою інструкцією в операторі switch. Детальніше на сторінці 115. У C/C++ switch - це "умовний перехід", подібний до обчислюваних міток у Fortran. У PAWN switch - це структуроване "if".

- Оператор break виводить тільки з циклів. У C/C⁺⁺ оператор break також завершує випадок в операторі switch. У PAWN оператори switch реалізовано по-іншому (див. сторінку 115).

- PAWN підтримує "присвоювання масивів", з обмеженням, що обидва масиви повинні мати однаковий розмір. Наприклад, якщо "a" і "b" є масивами по 6 комірок, вираз "a = b" є правильним. Крім буквених рядків, PAWN також підтримує буквені масиви, дозволяючи вираз "a = {0,1,2,3,4,5}" (де "a" - це змінна масиву з 6 елементами).

- _char_ - це оператор, а не тип. Див. сторінку 110 та підказки на сторінці 137.

- _defined_ - це оператор, а не директива препроцесора. Оператор defined у PAWN оперує константами (за допомогою const та enum), глобальними змінними, локальними змінними та функціями.

- Оператор _sizeof_ повертає розмір змінної в "елементах", а не в байтах. Елементом може бути комірка або підмасив. Докладні відомості див. на сторінці 109.

- Порожня інструкція є порожнім складеним блоком, а не крапкою з комою (сторінка 112). Ця модифікація дозволяє уникнути поширеної помилки.

- Директиви компілятора відрізняються від команд препроцесора C. Зокрема, директива #define несумісна з директивами C/C⁺⁺, а #ifdef та #ifndef замінено на більш загальну директиву #if (див. розділ "Директиви" на сторінці 117). Про створення числових констант див. також сторінку 101; про створення рядкових констант див. також сторінку 93.

- Текстові заміни (макроси препроцесора; див. директиву #define) не зіставляються між рядками. Тобто, текст, який ви хочете зіставити і замінити макросом #define, повинен знаходитися в одному рядку. Визначення макросу #define також має бути в одному рядку.

- Напрямок усікання для оператора "/" завжди в бік меншого значення, де -2 менше, ніж -1. Оператор "%" завжди дає позитивний результат, незалежно від знаків операндів. Дивіться сторінку 104.

- Немає унарного оператора "+", який у будь-якому випадку є оператором "без дії".

- Три бітові оператори мають інший пріоритет, ніж у C. Рівень пріоритету операторів "&", "^" і | вищий, ніж у операторів відношення (Денніс Рітчі пояснив, що ці оператори отримали низький рівень пріоритету у C тому, що ранні компілятори C ще не мали логічних операторів "&&" і ||, тому замість них використовувалися бітові "&" і |).

- У PAWN не існує ключового слова "extern"; поточна реалізація компілятора не має "фази компонування". Щоб створити програму з декількох вихідних файлів, додайте всі вихідні файли до командного рядка компілятора або створіть один головний файл сценарію проєкту, який "#include" всі інші вихідні файли. Компілятор PAWN може оптимізувати функції та глобальні змінні, які ви не використовуєте. Докладні відомості наведено на сторінках 63 і 84.

- У більшості ситуацій прямі оголошення функцій (тобто прототипи) не є необхідними. PAWN є двопрохідним компілятором, він побачить усі функції на першому проході і використає їх на другому. Однак, оператори, визначені користувачем, повинні бути оголошені перед використанням.

Якщо передбачено, форвардні оголошення повинні точно збігатися з описом функції
імена параметрів не можуть бути відсутніми у прототипі або відрізнятися від
від визначення функції. PAWN піклується про імена параметрів у прототипах завдяки функції "іменовані параметри".
типах завдяки функції "іменовані параметри". Прототипи використовуються
для виклику прямо оголошених функцій. Коли ви робите це з іменованими параметрами, компілятор повинен
компілятор вже повинен знати імена параметрів (і
їх розташування у списку параметрів). Як наслідок, імена параметрів у прототипі
у прототипі повинні збігатися з іменами у визначенні.

---

[Повернутися до змісту](00-Contents.md)
