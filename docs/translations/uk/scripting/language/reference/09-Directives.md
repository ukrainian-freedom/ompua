# Директиви

---

Всі директиви повинні бути першими в рядку (їм може передувати пробіл,
але не будь-які інші символи). Всі директиви починаються з символу # і
повна інструкція не може займати більше одного рядка.

**#assert** _константний вираз_

    Видає помилку під час компіляції, якщо заданий константний вираз дорівнює нулю.
    дорівнює нулю. Директива #assert найбільш корисна для захисту від
    конструкцій, визначених реалізацією, від яких може залежати програма,
    наприклад, розмір комірки у бітах або кількість упакованих символів у комірці.

**#визначити** _заміну шаблону

    Визначає макрос заміни тексту. Шаблон порівнюється з усіма рядками
    прочитаних з вихідних файлів; секції, що збігаються, замінюються
    текстами заміни. Шаблон і текст заміни можуть
    містити параметри від "%0" до "%9". Докладнішу інформацію див. на сторінці 93
    та приклади заміни текстів.

**#emit** _opcode, parameters_

    Директива #emit виконує роль вбудованого асемблера. Наразі вона використовується
    лише для тестування абстрактної машини.

**#endinput & #endscript**

    Закриває поточний файл і тим самим ігнорує
    весь текст нижче директиви #endinput.
    Директива #endscript є синонімом директиви #endinput.

**#Помилка!

    повідомлення: Сигналізує про "помилку користувача" із вказаним повідомленням. Помилки користувача - це фатальні помилки.
    є фатальними помилками і виконують ту саму функцію, що й директива #assert
    директива #assert.

**#файл** _ім'я_.

    Змінює назву для поточного файлу. Ця директива використовується неявно
    текстовим препроцесором; зазвичай немає необхідності задавати ім'я файлу
    явно.

**#if** _константний вираз_, #elseif, #else, #endif

    Частини програми можуть бути проаналізовані або проігноровані залежно від певних умов.
    певних умов. Синтаксичний аналізатор (компілятор або інтерпретатор) генерує
    код лише для тих частин, для яких умова є істинною.

    Після директиви #if повинен слідувати константний вираз. Щоб перевірити
    чи визначена змінна або константа, використовуйте оператор defined.

    Після початкової директиви #if може слідувати нуль або більше директив #elseif.
    Ці блоки пропускаються, якщо будь-який з попередніх блоків #if або #elseif
    були розібрані (тобто не пропущені). Як і у випадку з директивою #if, константний вираз
    повинен слідувати за виразом #elseif.

    Директива #else змушує синтаксичний аналізатор пропустити всі рядки до #endif, якщо попередня директива #if або будь-яка з попередніх директив #elseif
    директива #if або будь-яка з попередніх директив #elseif були "істинними", і
    якщо всі попередні блоки було пропущено, то синтаксичний аналізатор аналізує ці рядки. Директиву #else
    можна опустити; якщо вона присутня, то може бути лише одна #else
    пов'язана з кожним #if.

    Директива #endif завершує частину програми, яка розбирається кон
    умовно. Умовні директиви можуть бути вкладеними і кожна директива #if
    повинна завершуватися директивою #endif.

**#include** _ім'я_ або _< ім'я файлу >_.

    Вставляє вміст вказаного файлу у поточну позицію всередині
    поточного файлу. Ім'я файлу у кутових дужках ("<" і ">")
    вказує на системний файл; синтаксичний аналізатор (компілятор або інтерпретатор)
    шукатиме такі файли лише у визначеному списку каталогів, а не у
    "поточному" каталозі. Назви файлів без лапок або у подвійних лапках
    подвійних лапках, є звичайними файлами, що включаються, для яких синтаксичний аналізатор
    спочатку шукатиме у правильному каталозі.

    Парсер пішаків спочатку намагається відкрити файл з вказаним ім'ям
    ім'ям. Якщо це не вдасться, він спробує додати до файлу розширення ".inc", ".p"
    і ".pawn" до імені файлу (у цьому порядку). Пропоноване розширення за замовчуванням
    розширенням файлів, що включаються, є ".inc".

    Після успішного відкриття файлу, директива #include дефініціює константу з ім'ям
    створює константу з іменем "_inc_" плюс базове ім'я файлу (базове ім'я файлу) і значення 1.
    файлу (ім'я файлу без шляху та розширення) і значення 1. Якщо
    константа вже існує, директива #include пропускає відкриття та
    включення файлу, таким чином запобігаючи подвійному включенню. Щоб примусово виконати подвійне включення, видаліть визначення константи
    включення, видаліть визначення константи за допомогою директиви #undef
    перед другим включенням файлу.

**#рядок** _номер_.

    Номер поточного рядка (у поточному файлі). Ця директива використовується
    неявно використовується текстовим препроцесором; зазвичай немає необхідності задавати
    номер рядка явно.

**#pragma** _додаткова інформація_

    "Прагма" - це гачок для синтаксичного аналізатора, за допомогою якого можна вказати додаткові параметри, такі як
    наприклад, рівні попереджень або додаткові можливості. Найпоширеніші #прагми - це:

    **#pragma** вирівняти

        Вирівнює наступне оголошення за зсувом, заданим параметром вирівнювання
        компілятора. Деякі (власні) функції можуть працювати краще
        з параметрами, які передаються за посиланням, якщо вони знаходяться на
        8, 16 або навіть 32 байти. Вимоги до вирівнювання
        залежать від використовуваної програми.

        Додавання рядка #pragma align перед оголошенням глобальної або статичної змінної
        глобальної або статичної змінної вирівнює цю змінну за заданим компілятором
        ary, заданого компілятором. Зауважте, що ця #pragma
        вирівнює тільки ту змінну, яка безпосередньо слідує за #pragma.
        Вирівнювання наступних змінних залежить від розміру та
        вирівнювання змінних, що передують їй. Наприклад, якщо змінна
        глобальна змінна масиву з 2 комірок вирівняна по межі 16 байт
        а комірка має розмір 4 байти, то наступна глобальна змінна розташовується на 8 байт
        далі.

        Додавання рядка #pragma align перед оголошенням функції
        функції вирівняє рамку стеку цієї функції за вказаною раніше межею
        вказаною раніше, у результаті чого перша локальна,
        не "статична" змінна буде вирівняна до цієї межі. Вирівнювання наступних змінних залежить від
        вирівнювання наступних змінних залежить від розміру та вирівнювання змінних, що передували
        вирівнювання змінних, що їй передують. На практиці, щоб вирівняти локальну нестатичну змінну
        локальну нестатичну змінну, ви повинні вирівняти стек функції
        і оголосити цю змінну перед будь-якими іншими змінними.

    **#pragma** amxlimit *value*

        Задає максимальний розмір у байтах, до якого може зрости скомпільований скрипт
        скомпільований скрипт. Ця прагма корисна для (вбудованих) середовищ
        де максимальний розмір скрипта обмежено жорсткою верхньою межею
        обмеженням.

        Якщо не задано обсяг оперативної пам'яті для стеку даних та
        стеку (див. прагму amxram), це значення відноситься до загальних вимог до пам'яті
        якщо обсяг оперативної пам'яті задано явно, то це значення

        визначає лише обсяг пам'яті, необхідний для коду та
        статичних даних.

    **#pragma** amxram *value*

        Встановлює максимальні вимоги до пам'яті, у байтах, для даних
        та стеку, які може мати скомпільований скрипт. Це значення є
        корисним для (вбудованих) середовищ, де максимальний розмір даних
        де максимальний розмір даних скрипта обмежено жорсткою верхньою межею. Особливо у

        У випадку, коли скрипт пішака запускається з ПЗП, розміри секцій коду та
        секції коду та секції даних потрібно встановити обидва.

    **#pragma** кодова сторінка *ім'я/значення*

        Парсер пішаків може переводити символи у розпакованих рядках
        і символьні константи у "широкі" символи Unicode/UCS-4.
        Ця #pragma вказує кодову сторінку, яка має бути використана для
        перекладу. Див. розділ "Інтернаціоналізація" на сторінці

        139 для отримання детальної інформації та необхідних додаткових ресурсів для перекладу кодової сторінки
        перекладу.

    **#pragma** стиснути *значення*

        Синтаксичний аналізатор може записувати згенерований P-код у компактному
        або у звичайному ("некомпактному") кодуванні. Вибір за замовчуванням залежить від
        конфігурації синтаксичного аналізатора (і, можливо, налаштувань користувача). Цей параметр
        #pragma дозволяє автору сценарію перевизначити значення за замовчуванням і

        примусити компактне кодування (якщо значення ненульове) або примусити
        звичайне кодування (коли значення дорівнює нулю). Особливо корисним є вимкнення кодування ком
        pact-кодування (примусове кодування) є корисним, оскільки

        парсер пішаків не зможе скомпілювати певний скрипт
        у режимі "компактного кодування".

    **#pragma** ctrlchar *символ

        Визначає символ, який слід використовувати для позначення початку "послідовності екранування".
        За замовчуванням, керуючим символом є "\".

        Наприклад

        `#pragma ctrlchar '\$'**`

        Ви можете задати нове значення для керуючого символу як константу char-
        константу актора (в одинарних лапках) або десяткове чи шістнадцяткове значення
        десяткове або шістнадцяткове значення. Якщо ви не вкажете значення нового керуючого символу
        синтаксичний аналізатор повернеться до керуючого символу за замовчуванням.

    **#pragma dynamic** *value*

        Встановлює розмір в комірках блоку пам'яті для динамічних даних
        (стеку та купи) до значення, вказаного у виразі
        виразом. За замовчуванням розмір блоку динамічних даних дорівнює
        визначений реалізацією. Реалізація може також вирішити збільшити
        блок за потребою (див. документацію до програми-хоста, або "Реалізатор").
        документацію до основної програми або "Посібник реалізатора" для отримання детальної інформації).

    **#бібліотека прагматики** *ім'я*

        Задає ім'я (динамічно зв'язаного) модуля розширення
        який містить необхідні нативні функції. Ця #прагма повинна
        з'являтися над оголошеннями власних функцій, які є частиною
        модуля розширення.

        Параметр імені бібліотеки може бути відсутнім, у цьому випадку
        будь-які наступні оголошення власних функцій не пов'язуються
        з будь-яким модулем розширення.

        Область видимості цієї #прагми починається з рядка, на якому вона починається
        до кінця файлу, у якому вона з'являється. У типовому
        використання, рядок бібліотеки #pragma з'являється у верхній частині файлу
        include-файлу, який оголошує власні функції для розширення mod- ule.
        ule, а область видимості бібліотеки "link" закінчується у кінці цього
        include-файлу.

    **#pragma pack** *value*

        Якщо значення дорівнює нулю, упаковані літеральні рядки починаються з "!"" (знак оклику + подвійна лапка), а розпаковані - з "!"" (знак
        (знак оклику + подвійні лапки), а розпаковані літеральні рядки
        лише з подвійних лапок ("""), як описано у цьому посібнику на сторінці 99.
        Якщо значення ненульове, синтаксис упакованих і неупакованих
        буквених рядків міняється місцями: буквені рядки, які починаються з подвійних лапок, пакуються, а буквені рядки, які починаються з подвійних лапок, пакуються
        лапки, пакуються, а літеральні рядки, що починаються з "!""
        розпаковуються.

    **#pragma rational** *tagname(value)* *tagname(value)*

        Вмикає підтримку раціональних чисел. Назва тегу - це
        ім'я тегу, який матимуть раціональні числа; зазвичай
        вибирають назви "Float:" або "Fixed:". Наявність значення
        у дужках після tagname не є обов'язковим: якщо його не вказано, раціональне число
        раціональне число зберігається як значення з "плаваючою комою"
        відповідно до стандарту IEEE 754; якщо воно присутнє, раціональне число є числом фіксованої
        число є числом фіксованої точності ("масштабоване ціле") із
        вказаною кількістю знаків після коми.

    **#прагматична крапка з комою** *значення*

        Якщо значення дорівнює нулю, крапка з комою не ставиться у кінці оператора, якщо
        цей оператор є останнім у рядку. Крапка з комою потрібна для того, щоб
        відокремлення декількох операторів на одному рядку.

        Якщо крапка з комою необов'язкова (за замовчуванням), постфіксний оператор
        (один з "++", "--" і "char") не може бути першою лексемою у
        рядку, оскільки вони будуть інтерпретуватися як префіксні оператори.

    **#pragma tabsize** *value*

        Кількість символів між двома послідовними позиціями табуляції
        табуляції. Значення за замовчуванням дорівнює 8. Вам може знадобитися встановити розмір табуляції
        щоб уникнути попередження 217 (вільний відступ), якщо у вихідному коді
        відступається поперемінно то пробілами, то символами табуляції.
        Крім того, якщо ви встановите "tabsize" #pragma у нуль, парсер
        синтаксичний аналізатор більше не видаватиме попередження 217.

    **#прагма не використовується** *символ,...*

        Позначає названий символ як "використаний". Зазвичай синтаксичний аналізатор pawn
        попереджає про невикористані змінні та невикористані локальні константи.
        константи. У більшості ситуацій ці змінні та константи є
        надлишковими, і їх краще вилучити для оптимізації коду

        ясність. Особливо у випадку локальних констант, може бути
        краще (або обов'язково) зберігати визначення констант.
        Ця #прагма дозволяє позначити символ (змінну чи константу) як "використаний" і уникнути попередження синтаксичного аналізатора.
        константу) як "використаний" і уникнути попередження синтаксичного аналізатора.

        Символ #pragma має з'являтися після оголошення символу -але
        вона не обов'язково має з'являтися одразу після оголошення.

        В одній #pragma може з'являтися декілька назв символів; символи
        повинні бути розділені комами.

**#розділ** _назва_.

    Починає новий розділ для згенерованого коду. Будь-які змінні та функції, оголошені "статичними
    які оголошено "статичними", будуть видимими лише у секції, до якої вони належать.
    до якого вони належать. За замовчуванням, кожен вихідний файл є окремою секцією
    і в одному файлі може бути лише одна секція.

    За допомогою директиви #section ви можете створити декілька секцій в одному

    вихідний файл. Назва розділу не є обов'язковою, якщо її не задано, для назви розділу використовується унікальний
    для назви секції використовується унікальний ідентифікатор вихідного файлу.

    Будь-яка оголошена секція автоматично завершується в кінці файлу.

**#tryinclude** _ім'я_ або _< ім'я файлу >_.

    Ця директива поводиться подібно до директиви #include, але вона
    не видає помилки, якщо файл, який потрібно включити, не існує - тобто, якщо ви спробуєте
    включити, але мовчки завершиться з помилкою.

**#undef** _ім'я_.

    Видаляє макрос підстановки тексту або числову константу, оголошену
    з константою const. Параметр "name" має бути "префіксом" макросу - буквено-цифровою частиною макросу
    буквено-цифровою частиною макросу. Докладні відомості та приклади див. на сторінці 93
    про підстановку тексту.

---

`Див. також "Попередньо визначені константи" на сторінці 102`.

`Escape character: 99`

Підтримка раціональних чисел: 98`

Попереджувальні повідомлення: 161`

---

[Повернутися до змісту](00-Contents.md)


