# Вступ до підручника

---

pawn - це проста мова програмування з синтаксисом, що нагадує мову програмування "C"
мову програмування "C". Піша програма складається з набору функцій та
набору змінних. Змінні є об'єктами даних, а функції містять
інструкції (так звані "оператори"), які оперують об'єктами даних або виконують завдання.

Перша програма майже на будь-якій комп'ютерній мові - це програма, яка виводить простий
рядок; друк "Hello world" є класичним прикладом. На пішаку ця програма виглядатиме так:

Посилання: hello.p

```c

main()
    printf "Hello world\n"

```

Цей посібник передбачає, що ви знаєте, як працювати з програмою застави; якщо ні, будь ласка
зверніться до посібника з використання програми (більше підказок на сторінці 168).

Програма-пішак починає виконання у функції "входу "* - майже у всіх прикладах цього посібника ця функція
прикладах цього посібника ця функція входу називається "main". Тут функція
main містить лише одну інструкцію, яка знаходиться на рядок нижче самої функції
головкою самої функції. Розриви рядків і відступи незначні; виклик функції
функції print може з однаковим успіхом знаходитися у тому ж рядку, що і заголовок функції main.

Визначення функції вимагає, щоб після назви функції була пара круглих дужок
іменем функції. Якщо функція отримує параметри, їх оголошення розміщуються між
круглими дужками. Функція main не береться в круглі дужки. Правила
для виклику функції (або виклику функції) є іншими; дужки є
у виклику функції print дужки не обов'язкові.

Єдиним аргументом функції print є рядок, який потрібно взяти в подвійні лапки
у подвійні лапки. Символи \n у кінці рядка утворюють екранування
послідовність, у цьому випадку вони позначають символ "переведення рядка". При виведенні на друк символ \n зустрічається
символ переведення рядка на новий рядок, курсор буде переведено на перший стовпчик
наступного рядка. Щоб вставити "новий рядок" у рядок, слід використовувати екрануючу послідовність \n, оскільки
рядка, оскільки рядок не може переноситися на декілька рядків.

---

###### ∗ Це не слід плутати з функціями введення "стану", які також називаються введенням, але мають іншу мету - див. стор. 42

`Складання та запуск скриптів: див. сторінку 168

`Строкові літерали: 99 Екранована послідовність: 99`

---

pawn є "чутливою до регістру" мовою: великі та малі літери вважаються
різними літерами. Буде помилкою написати функцію printf у вищенаведеному прикладі
у наведеному вище прикладі як "PrintF". Ключові слова та наперед визначені символи, такі як ім'я
функції "main", повинні бути набрані в нижньому регістрі.

Якщо ви знаєте мову C, вам може здатися, що вищенаведений приклад не
схожий на еквівалентну програму "Hello world" на C/C++. пішак може
також може виглядати дуже схоже на C. Наступний приклад програми також є правильним
синтаксису pawn (і вона має ту ж саму семантику, що і попередній приклад):

Лістинг: hello.p - стиль C

```c

#include <console> #include <console>

main()
{
    printf("Hello world\n");
}

```

Ці перші приклади також показують деякі відмінності між пішаком і мовою C:

- зазвичай немає необхідності включати будь-який системний "заголовний файл";

- крапка з комою не обов'язкова (за винятком випадків, коли в одному рядку записано декілька операторів);

- коли тіло функції є однією інструкцією, дужки (для складеної інструкції) не є обов'язковими;

- якщо ви не використовуєте результат функції у виразі або присвоюванні, дужки навколо аргументу функції є необов'язковими.

Зауважимо, що кілька попередніх пунктів стосуються необов'язкових синтаксисів. Це
який синтаксис ви бажаєте використовувати: жоден стиль не є "застарілим" або
"вважається шкідливим". У прикладах, наведених у цьому посібнику, розставляються дужки і використовується
відступ, відомий як "стиль Уайтсміта", але pawn - це вільна мова форматування, а інші стилі відступів
мова форматування, і інші стилі відступів так само хороші.

Оскільки pawn розроблено як мову розширення для додатків,
набір функцій/бібліотека, яку має у своєму розпорядженні pawn-програма, залежить від
хост-додатку. Як наслідок, мова pawn не має власних знань
про жодну функцію. Функція друку, яка використовується у цьому першому прикладі, повинна бути
доступною хост-програмі і має бути "оголошена" синтаксичному аналізатору.

---

###### ∗ У специфікації мови термін "синтаксичний аналізатор" означає будь-яку реалізацію, яка обробляє та виконує відповідні програми Pawn - інтерпретатори або компілятори

`Більше описів функцій на стор. 124`

---

Однак передбачається, що всі програми хоста надають мінімальний набір загальних
функцій, таких як print та printf.

У деяких середовищах дисплей або термінал потрібно увімкнути, перш ніж виводити на нього текст
може бути виведено на нього. У такому випадку вам слід додати виклик функції
"console" перед першим викликом функції print або printf. Функція console
також дозволяє вказати характеристики пристрою, такі як кількість
рядків і стовпчиків на дисплеї. Приклади програм у цьому
посібнику не використовують консольні функції, оскільки багато платформ не вимагають або не надають їх.

### - Арифметика

Фундаментальними елементами більшості програм є обчислення, рішення
(умовне виконання), ітерації (цикли) та змінні для зберігання вхідних даних, вихідних
даних та проміжних результатів. Наступний приклад програми ілюструє багато з
з цих понять. Програма обчислює найбільший спільний дільник двох
значень, використовуючи алгоритм, винайдений Евклідом.

Лістинг: gcd.p

```c

/* найбільший спільний дільник двох величин, використовуючи алгоритм Евкліда
за алгоритмом Евкліда */

main()
{
    print "Введіть два значення\n"
    new a = getvalue()
    new b = getvalue()
    while (a != b)
    if (a > b)
        a = a - b
    else
        b = b - a
    printf "Найбільший спільний дільник дорівнює %d\n", a
}

```

Функція main тепер містить більше, ніж один оператор "print". Коли
тіло функції містить більше одного оператора, ці оператори
слід брати у фігурні дужки - символи "{" і "}". Це групує конструкції in-
конструкції в один складений оператор. Поняття групування інструкцій
у складеному операторі застосовується також до тіл інструкцій if-else та циклу.

Ключове слово new створює змінну. Ім'я змінної слідує за new.
Це оголошення даних є загальноприйнятим, але не обов'язковим,
для присвоєння значення змінній вже в момент її створення.

Складений вираз: 112`

Детально про декларування даних йдеться на сторінці 62

---

Змінні мають бути оголошені до того, як вони будуть використані у виразі.
Функція getvalue (також поширена попередньо визначена функція)
зчитує значення з клавіатури і повертає результат. Зауважте, що pawn
це безтипова мова, всі змінні є числовими
клітинками, які можуть містити знакове інтегральне значення.

Ім'я функції getvalue супроводжується парою круглих дужок. Вони є обов'язковими
необхідні, оскільки значення, яке повертає getvalue, зберігається у змінній. Крім того, аргументи (або параметри) функції getvalue
Зазвичай, аргументи (або параметри) функції не з'являються між дужками, але
дужками, але getvalue (у цій програмі) не приймає жодних
явних аргументів. Якщо ви не присвоюєте результат функції змінній
або не використовуєте її у виразі іншим чином, дужки не є обов'язковими. Наприклад
наприклад, результат операторів print і printf не використовується. Ви
можете використовувати дужки навколо аргументів, але це не є обов'язковим.

Інструкції циклу, такі як "while", повторюють одну інструкцію до тих пір, поки умова циклу
(вираз у круглих дужках) є "істинною". Можна
виконати кілька інструкцій у циклі, згрупувавши їх у складеному операторі.
Інструкція if-else має одну інструкцію для умови "істина" і одну для умови "хибність".

Зверніть увагу, що деякі оператори, такі як while та if-else, містять (або
"обгортають" іншу інструкцію - у випадку if-else навіть дві інші інструкції.
Повний набір - це, знову ж таки, одна інструкція. Тобто

- оператори присвоювання "a = a - b" під if та "b = b - a" під else є операторами;

- інструкція if-else згортається навколо цих двох інструкцій присвоювання і утворює єдину інструкцію;

- інструкція while згортається навколо інструкції if-else і утворює, знову ж таки, єдину інструкцію.

Зазвичай, вкладеність операторів вказується з допомогою відступів під будь-якими
підречення під твердженням у вихідному тексті. У прикладі "Найбільший дільник компанії" відступ від лівого поля збільшується на чотири пробіли.
У прикладі "Найбільший дільник числа" відступ від лівого поля збільшується на чотири пробіли
після оператора while, а також після ключових слів if та else. Стан - це стан, в якому перебувають
стани, які належать до одного рівня, наприклад, виклик printf і цикл while, мають однаковий відступ від поля.
цикл while, мають однаковий відступ.

Умова циклу для циклу while має вигляд "(a != b)"; символ != - це оператор
оператор "не дорівнює". Тобто, інструкція if-else повторюється
до тих пір, поки "a" не стане рівним "b". Доброю практикою є використання відступів для інструкцій, які виконуються під управлінням іншого оператора
інструкції, які виконуються під керуванням іншого оператора, як це зроблено у попередньому прикладі.

---

Виклик printf у нижній частині прикладу відрізняється від виклику print
безпосередньо під відкриваючою фігурною дужкою ("{"). "f" у printf означає "відформатований",
що означає, що функція може форматувати і виводити числові значення та інші
дані (у форматі, визначеному користувачем), а також буквальний текст. Символ %d у рядку
є маркером, який вказує на позицію і формат, у якому має бути наступний
аргумент функції printf має бути надруковано. Під час виконання функції лексема %d замінюється
замінюється значенням змінної "a" (другий аргумент printf).

Функція print може друкувати лише текст; вона швидша за printf. Якщо вам потрібно
вивести на екран літеру "%", вам слід скористатися print або подвоїти
у рядку, який ви передаєте функції printf. Тобто

`print "20% персоналу припадає на 80% витрат\n"` `print "20% персоналу припадає на 80% витрат\n"`

і

`printf "20%% персоналу припадає на 80%% витрат\n"`.

вивести той самий рядок.

---

Цикл while: 116`

"якщо інакше": 114`

`Реляційні оператори: 107`

---

### - Масиви та константи

Окрім простих змінних розміром в одну комірку, pawn підтримує "масивні
змінні", які містять багато комірок/значень. Наступний приклад програми виводить на екран
ряд простих чисел, використовуючи добре відоме "решето Ератосфена". Програма
також вводить ще одну нову концепцію: символьні константи.
Символічні константи виглядають як змінні, але їх не можна змінювати.

Посилання: sieve.p

```c

/* Виведіть усі прості числа до 100, використовуючи "сито Ератосфена" */

main()
{
    const max_primes = 100
    new series[max_primes] = { true, ...  }
    for (new i = 2; i < max_primes; ++i)
    if (series[i])
    {
        printf "%d ", i
        /* відфільтрувати усі кратні даному "простому" зі списку */
        for (new j = 2 * i; j < max_primes; j += i)
            series[j] = false
    }
}

```

---

Якщо програма або підпрограма має вбудовану фіксовану межу, корисно створити для неї символічну константу.
створити для нього символічну константу. У попередньому прикладі символ
max_primes є константою зі значенням 100. Програма використовує символ
max_primes тричі після його визначення: в оголошенні змінної
series та в обох циклах for. Якщо адаптувати програму так, щоб вона виводила усі
простих чисел, менших за 500, потрібно змінити лише один рядок.

Як і прості змінні, масиви можуть бути ініціалізовані при створенні. pawn пропонує
зручний скорочений запис для ініціалізації всіх елементів фіксованим значенням:
усі сто
елементам масиву "series" присвоюється значення true - без необхідності вводити слово "true" сто разів.
від програміста сто разів вводити слово "true". Символи true
та false є наперед визначеними константами.

Коли в першому виразі циклу оголошується проста змінна, як, наприклад, змінні i та j у прикладі з просіюванням простих чисел,
оголошується у першому виразі циклу for, змінна
дійсна тільки всередині циклу.
Оголошення змінної має свої правила; це не інструкція
хоч і виглядає як інструкція.
Одне з цих правил полягає в тому, що перший вираз
циклу for може містити оголошення змінної.

Обидва цикли for також вводять нові оператори у своєму третьому виразі.
Оператор ++ збільшує операнд на одиницю, тобто ++i дорівнює i = i + 1.
Оператор += додає вираз праворуч від нього до змінної ліворуч;
тобто j += i дорівнює j = j + i.

Існує проблема "off-by-one", про яку потрібно знати, якщо ви працюєте з
масивами. Першим елементом масиву series є series[0], тому якщо масив
містить max_primes елементів, останнім елементом масиву буде series[max_primes 1].
Якщо max_primes дорівнює 100, то останнім елементом буде series[99]. Звернення до series[100] є некоректним.

Постійна декларація: 101`

Прогресивні ініціатори: 65`

Цикл "for": 113`

`Огляд всіх операторів: 104`

### - Функції

У великих програмах завдання та операції поділяються на функції. Використання функцій
підвищує модульність програм, а функції, якщо вони добре написані, є
переносяться в інші програми. У наступному прикладі реалізовано функцію для
обчислення чисел з ряду Фібоначчі.

Послідовність Фібоначчі була відкрита Леонардо "Фібоначчі" з Пізи, італійським математиком
італійським математиком 13 століття, чиїм найбільшим досягненням була
популяризація індуїстсько-арабської системи числення у західному світі. Метою
послідовності було описати зростання популяції (ідеалізованих) кроликів;

і послідовність має вигляд 1, 1, 2, 3, 5, 8, 13, 21,. . . .
(кожне наступне значення є сумою двох попередніх).

Лістинг: fib.p

```c

/* Обчислення чисел Фібоначчі за допомогою ітерацій */ ** Обчислення чисел Фібоначчі за допомогою ітерацій */

main()
{
    print "Введіть значення:  "
    new v = getvalue()
    if (v > 0)
        printf "Значення числа Фібоначчі %d дорівнює %d\n", v, fibonacci(v)
    else
        printf "Число Фібоначчі %d не існує\n", v
}
fibonacci(n)
{
    assert n > 0
    new a = 0, b = 1
    (new i = 2; i < n; i++)
    {
        new c = a + b
        a = b
        b = c
    }
    return a + b
}

```

Інструкція assert у верхній частині функції Фібоначчі заслуговує на окрему
згадки; вона захищає від "неможливих" або недопустимих умов. Від'ємне число Фі
боначчі є неприпустимим, і інструкція assert позначає це як помилку програміста, якщо такий випадок трапляється.
помилкою програміста, якщо такий випадок трапляється. Оператори ствердження повинні позначати лише помилки програміста
помилки програміста, але не помилки введення даних користувачем.

Реалізація функції, визначеної користувачем, мало чим відрізняється від реалізації
функції main. Однак функція fibonacci демонструє два нових поняття: вона
отримує вхідне значення через параметр і повертає значення (має параметр
"результат").

Параметри функції оголошуються у заголовку функції; єдиний параметр
у цьому прикладі є "n". Усередині функції параметр поводиться як
локальна змінна, але така, значення якої передається ззовні при
виклику функції.

Оператор return завершує функцію і встановлює результат виконання функції.
Він не обов'язково повинен з'являтися в самому кінці функції; допускається достроковий вихід.

твердження "стверджую": 112`

`Функціонали: властивості та особливості: 70`

---

Головна функція прикладу Фібоначчі викликає попередньо визначені "рідні" функції,
такі як getvalue і printf, а також визначену користувачем функцію fibonacci.
З точки зору виклику функції (як і у функції main), немає ніякої
різниці між визначеними та власними функціями немає.

Послідовність чисел Фібоначчі описує дивовижне розмаїття природних явищ.
номенів. Наприклад, два або три набори спіралей в ананасах, соснових шишках
та соняшнику зазвичай мають послідовність чисел Фібоначчі від 5 до 89
відповідно до кількості спіралей. Числа, які природно зустрічаються у розгалужених
(наприклад, у рослин) дійсно є числами Фібоначчі. Нарешті, хоча
послідовність Фібоначчі не є геометричною послідовністю, чим далі послідовність
тим ближче співвідношення між послідовними членами наближається до
до золотого перетину, що дорівнює 1.618. . . ∗ що так часто зустрічається в мистецтві та архітектурі.

### - Виклик за посиланням та виклик за значенням

Дати є особливо багатим джерелом алгоритмів та процедур перетворення,
тому що календарі, на які посилається дата, знали таке розмаїття,
у різні часи та у різних куточках світу.

"Число юліанських днів" приписується Йосипу Скалігеру† і рахує
кількість днів, починаючи з 24 листопада 4714 року до н.е. (пролептичне григоріанське кал
endar‡). Скалігер обрав цю дату, оскільки вона знаменувала собою збіг трьох
добре відомих циклів: 28-річного сонячного циклу (за старим юліанським календарем),
19-річного метонічного циклу та 15-річного циклу індикацій (періодичні податки або урядові реквізиції в
(періодичні податки або державні реквізиції у Стародавньому Римі), а також тому, що жодна література чи записана історія не існувала до
до цієї дати в далекому минулому не існувало жодних літературних чи історичних пам'яток. Скалігер
використовував цю концепцію для узгодження дат в історичних документах, а пізніше астрономи
пізніше астрономи, щоб легше обчислювати інтервали між двома подіями.

---

###### ∗ Точне значення золотого перетину дорівнює 1/2(√5 + 1). Зв'язок між числами Фібоначчі та золотим перетином також дозволяє "прямо" обчислити будь-який номер послідовності, замість описаного тут ітераційного методу

###### ∗ Існують суперечки щодо того, що саме винайшов Йосип Скалігер і на честь кого чи чого він його назвав

###### ∗ Григоріанський календар був запроваджений 15 жовтня 1582 року папою Григорієм XIII, а це означає, що більш ранні дати в григоріанському календарі насправді не існують. Коли ми поширюємо григоріанський календар на дні до 15 жовтня 1582 року, ми називаємо його пролептичним григоріанським календарем

`Власний інтерфейс функцій: 85`

---

Числа юліанських днів (іноді позначаються одиницею "jd") не слід змішувати з юліанськими датами (кількістю днів у році).
з юліанськими датами (кількість днів від початку одного року),
або з юліанським календарем, запровадженим Юлієм Цезарем.

Нижче наведено програму, яка обчислює номер юліанського дня за датою в
(пролептичному) григоріанському календарі, і навпаки. Зверніть увагу, що у пролептичному
Григоріанському календарі першим роком є 1 рік нашої ери (Anno Domini), а попереднім роком
тобто 1 до н.е. (до Різдва Христового): нульового року не існує! Програма використовує
від'ємні значення року для років до нашої ери і додатні (ненульові) значення для років нашої ери.

Лістинг: julian.p

```c

/* обчислити число юліанського дня за датою, і навпаки */.

main()
{
    new d, m, y, jdn
    print "Введіть дату (дд-мм-гггг):  "

    d = getvalue(_, '-', '/')
    m = getvalue(_, '-', '/')
    y = getvalue()
    jdn = DateToJulian(d, m, y)

    printf("Дата %d/%d/%d = %d JD\n", d, m, y, jdn)
    вивести "Введіть номер дня за юліанським календарем: "

    jdn = getvalue()
    JulianToDate jdn, d, m, y

    printf "%d JD = %d/%d/%d\n", jdn, d, m, y
}

DateToJulian(день, місяць, рік)
{
    /* Перший рік - 1.  Року 0 не існує: це 1 до н.е. (або -1) */.

    assert year != 0
    if (year < 0)
    year++

    /* перенести січень і лютий на кінець попереднього року */.

    if (month <= 2)
    рік--, місяць += 12
    new jdn = 365*рік + рік/4 - рік/100 + рік/400
    + (153*місяць - 457) / 5
    + день + 1721119

    return jdn
}

JulianToDate(jdn, &day, &month, &year)
{
    jdn -= 1721119

    /* приблизний рік, потім скоригуйте в циклі */

    year = (400 * jdn) / 146097
    while (365*year + year/4 - year/100 + year/400 < jdn)
        year++
    рік--
    /* визначення місяця */

    jdn -= 365*рік + рік/4 - рік/100 + рік/400
    місяць = (5*jdn + 457) / 153

    /* визначте день */

    день = jdn - (153*місяць - 457) / 5

    /* перенести січень і лютий на початок року */.

    if (month > 12)
        month -= 12, year++

    /* відкоригувати від'ємні роки (0 рік має стати 1 роком до н.е., або -1) */.

    if (year <= 0)
        year--
}

```

---

Основна частина функції починається зі створення змінних для зберігання дня, місяця та року,
та обчисленого числа юліанського дня. Потім вона зчитує дату - три виклики функції
getvalue- і викликає функцію DateToJulian для обчислення номера дня. Після обчислення результату
обчислення результату, main виводить дату, яку ви ввели, і число дня за юліанським календарем для цієї дати.
День за юліанським календарем для цієї дати. Тепер зосередимося на функції DateToJulian. . .

У верхній частині функції DateToJulian збільшує значення року, якщо воно від'ємне
від'ємне; це робиться для того, щоб впоратися з відсутністю "нульового" року у
пролептичному григоріанському календарі. Іншими словами, функція DateToJulian модифікує свої аргументи функції
аргументи функції (пізніше вона також змінює місяць). Усередині функції аргумент
поводиться як локальна змінна: ви можете змінювати його. Ці зміни залишаються
локальними для функції DateToJulian. Функція main передає значення
d, m і y у DateToJulian, яка зіставляє їх з аргументами своєї функції
день, місяць і рік відповідно. Хоча DateToJulian змінює рік і
month, він не змінює y та m у функції main; він лише змінює локальні копії
y та m. Ця концепція називається "виклик за значенням".

У прикладі навмисно використовуються різні імена для локальних змінних у функціях
функції main і DateToJulian, щоб полегшити наведену вище екс-планіровку.
спрощення наведеного вище прикладу. Перейменування змінних d, m та y у функції main на day, month
і рік відповідно, не змінює суті справи: тоді у вас просто з'являться
дві локальні змінні з іменами day, two з іменами month і two з іменами year, що
цілком допустимо у пішаку.

"Виклик за значенням" проти "Виклику за посиланням": 71`

---

Решта функції DateToJulian є, з точки зору
пішакової мови, нецікава арифметика.

Повертаючись до другої частини функції main, ми бачимо, що тепер вона запитує
номер дня і викликає іншу функцію, JulianToDate, щоб знайти дату
яка відповідає номеру дня. Функція JulianToDate цікава тим, що
вона отримує один вхідний аргумент (номер дня за юліанським календарем) і повинна обчислити
три вихідних значення: день, місяць і рік. На жаль, функція може мати лише
єдине значення, що повертається - тобто, оператор повернення у функції може
може містити лише один вираз. Щоб вирішити цю проблему, JulianToDate спеціально вимагає, щоб
щоб зміни, які він вносить до деяких аргументів функції, копіювалися назад до
змінні викликувача функції. Тоді, в основному, змінні, які повинні
зберігати результат роботи JulianToDate, передаються як аргументи до JulianToDate.

Функція JulianToDate позначає відповідні аргументи для "копіювання
назад до абонента", додаючи до них символ &. Аргументи з & будуть
копіюються, аргументи без символу & - ні. "Копіювання назад" насправді не є
правильний термін. Аргумент, позначений &, передається у функцію у
спеціальним способом, який дозволяє функції безпосередньо модифікувати вихідну змінну.
Це називається "виклик за посиланням", а аргумент, який його використовує - "аргумент-посилання".

Іншими словами, якщо main передає y до JulianToDate - яка зіставляє його зі своєю функцією
аргументу year- і JulianToDate змінює рік, то JulianToDate дійсно
змінює y. Тільки через аргументи-посилання функція може безпосередньо змінювати
змінну, оголошену в іншій функції.

Підсумовуючи використання виклику за значенням у порівнянні з викликом за посиланням: якщо функція
має одне вихідне значення, ви зазвичай використовуєте інструкцію return; якщо функція має
більше вихідних значень, ви використовуєте аргументи-посилання. Ви можете комбінувати ці два способи
в одній функції, наприклад, у функції, яка повертає свій "звичайний"
за допомогою аргументу-посилання та коду помилки у значенні, що повертається.

Крім того, багато десктопних додатків використовують перетворення в і з
чисел Юліанського дня (або його різновидів) для зручного обчислення кількості днів
між датами або для обчислення дати, яка буде через 90 днів - наприклад.---.

### - Раціональні числа

Усі обчислення, які ми проводили до цього моменту, стосувалися лише цілих чисел -integer
pawn також підтримує числа, які можуть містити дробові значення:

їх називають "раціональними числами". Однак, чи буде увімкнено цю підтримку
залежить від використовуваної програми.

Раціональні числа можуть бути реалізовані як числа з плаваючою або фіксованою комою
з плаваючою або фіксованою комою. Арифметика з плаваючою комою зазвичай використовується для обчислень загального призначення та
наукових обчислень, тоді як арифметика з фіксованою комою більше підходить для
фінансової обробки та додатків, де помилки округлення не повинні виникати

(або, принаймні, вони мають бути передбачуваними). Інструментарій пішака має як модуль з плаваючою, так і з фіксованою комою
з плаваючою та фіксованою точкою, а також деталі (і
компроміси) для
цих модулів у відповідній документації. Проблема, однак, полягає у тому, що
хост-програма може реалізовувати або плаваючу, або фіксовану комірку, або обидві
або жодну з них.∗ Програма, наведена нижче, вимагає наявності принаймні одного з типів раціональної
раціональних чисел; вона не зможе запуститися, якщо хост-програма не підтримує
не підтримує раціональні числа взагалі.

Лістинг: c2f.p

```c

main()
{
    new Rational:  Цельсій
    new Rational:  Фаренгейт
    вивести "Celsius\t Fahrenheit\n"
    for (Celsius = 5; Celsius <= 25; Celsius++)
    {
        Фаренгейт = (Цельсій * 1.8) + 32
        printf "%r \t %r\n", Celsius, Fahrenheit
    }
}

```

У прикладі програма перетворює таблицю градусів Цельсія у градуси Фаренгейта.
Першою директивою цієї програми є імпорт визначень для підтримки раціональних чисел
підтримки раціональних чисел з включаємого файлу. Файл "rational" містить або підтримку
для чисел з плаваючою комою або для чисел з фіксованою комою, залежно від того, що доступно.

Змінні Celsius і Fahrenheit оголошуються з тегом "Rational:"
між ключовим словом new та іменем змінної. Ім'я тегу вказує на
призначення змінної, її дозволене використання і, як окремий випадок для раціональних чисел
для раціональних чисел - розташування у пам'яті.

---

###### ∗ Власне, це вже стосується всіх нативних функцій, включно з усіма нативними функціями, які використовуються у прикладах у цьому посібнику

`Імена тегів: 68

---

Тег Rational: вказує синтаксичному аналізатору, що змінні Celsius і Fahrenheit
містять дробові значення, а не цілі числа.

Рівняння для отримання градусів Фаренгейта з градусів Цельсія має вигляд

°F = ⁹⁄₅ + 32 °C

Програма використовує значення 1.8 для частки 9/₅. Якщо увімкнено підтримку раціональних чисел
підтримка раціональних чисел, пішак підтримує значення з дробовою частиною після
десятковою крапкою.

Єдиною нетривіальною зміною у порівнянні з попередніми програмами є те, що у рядку формату
для функції printf тепер містить заповнювачі змінних, які позначаються
"%r" замість "%d". Заповнювач %r друкує раціональне число у позиції
позиції; %d призначено лише для цілих чисел ("цілих чисел").

Я використовував файл включення "rational", а не "float" або "fixed" у
щоб зробити приклад програми портативним. Якщо ви знаєте, що програма на хості
додаток підтримує арифметику з плаваючою комою, може бути зручніше
"#include" визначення з файлу float і використовувати тег Float: замість
замість Rational - при цьому вам також слід замінити %r на %f у виклику
printf. Докладні відомості про підтримку фіксованої та плаваючої копійок наведено у
"Бібліотека підтримки фіксованої точки" та "Бібліотека підтримки плаваючої точки", які доступні окремо.
Floating Point Support Library", які можна завантажити окремо.

### - Рядки

пішак не має внутрішнього типу "рядок"; рядки символів зберігаються у масивах, з
домовленістю, що елемент масиву за останнім допустимим символом дорівнює нулю.
Тому робота з рядками еквівалентна роботі з масивами.

Серед найпростіших схем шифрування є схема під назвою "ROT13" -
насправді алгоритм досить "слабкий" з криптографічної точки зору. Він
найбільш широко використовується на публічних електронних форумах (BBS, Usenet) для приховування текстів
від випадкового читання, наприклад, розгадки ребусів або загадок. ROT13 просто
"обертає" алфавіт на половину його довжини, тобто на 13 символів. Це симетрична
операція симетрична: якщо застосувати її двічі до одного і того ж тексту, можна побачити оригінал.

---

Лістинг: rot13.p

```c

/* Просте шифрування, з використанням ROT13 */ ** Просте шифрування, з використанням ROT13 */

main()
{
    printf "Будь ласка, введіть рядок для манглування:  "

    новий рядок str[100]
    getstring str, sizeof str
    rot13 str

    printf "Після спотворення рядок має вигляд:  \"%s\"\n", str
}

rot13(string[])
{
    for (new index = 0; string[index]; index++)
    if ('a' <= string[index] <= 'z')
        string[index] = (string[index] - 'a' + 13) % 26 + 'a'
    else if ('A' <= string[index] <= 'Z')
        string[index] = (string[index] - 'A' + 13) % 26 + 'A'
}

```

У заголовку функції rot13 параметр "string" оголошено як масив
але без зазначення розміру масиву - між квадратними дужками немає значення
квадратними дужками. Коли ви вказуєте розмір масиву у заголовку функції,
він повинен відповідати розміру фактичного параметра у виклику функції. Опускання
вказівки розміру масиву у заголовку функції знімає це обмеження і
дозволяє викликати функцію з масивами будь-якого розміру. У такому випадку ви повинні мати
якийсь інший спосіб визначення (максимального) розміру масиву. У випадку
рядкового параметра можна просто шукати нульовий термінатор.

Цикл for, який проходить над рядком, є типовим для функцій обробки рядків
ції обробки рядків. Зверніть увагу, що умовою циклу є "рядок[індекс]". Правило для умов true/
false в pawn полягає в тому, що будь-яке значення є "істинним", окрім нуля. Тобто
коли комірка масиву за адресою string[index] дорівнює нулю, це означає "false" і цикл переривається.

Алгоритм ROT13 обертає лише літери; цифри, знаки пунктуації та спеціальні
символи залишаються незмінними. Крім того, великі та малі літери повинні
оброблятися окремо. Усередині циклу for два оператори if відфільтровують
символи, що нас цікавлять. Звертає на себе увагу те, як другий if пов'язаний з оператором "else"
першого if заслуговує на увагу, оскільки це типовий метод
перевірки декількох умов, що не перетинаються.

Раніше в цьому розділі було розглянуто поняття "виклик за значенням" та "виклик за
посиланням". Коли ви працюєте з рядками або масивами взагалі, зверніть увагу на те, що
що пішак завжди передає масиви за посиланням. Це робиться для економії пам'яті
і для підвищення продуктивності - масиви можуть бути великими структурами даних і передача
їх за значенням вимагає створення копії цієї структури даних, що займає як пам'ять, так і час.

---

`Функція, яка отримує масив як аргумент і не змінює його, може позначити аргумент як "const"; див. сторінку 72`.

Завдяки цьому правилу функція rot13 може модифікувати свій параметр function
(у прикладі - "рядок") без необхідності оголошувати його як аргумент
аргумент-посилання.

Ще одним моментом, що викликає інтерес, є умови у двох операторах if. Перший з них
if, наприклад, містить умову "'a' <= string[index] <= 'z'", що
означає, що вираз істинний тоді (і тільки тоді), коли 'a' <= string[index]
та string[index] <= 'z' є істинними. У комбінованому виразі оператори відношення
оператори відношення називаються "ланцюговими", оскільки вони об'єднують декілька порівнянь
в одній умові.

Нарешті, зверніть увагу на те, як останній printf у функції main використовує екрануючу послідовність
\" для друку подвійних лапок. Зазвичай подвійні лапки ставляться у кінці рядка з літералами;
екрануюча послідовність "\"" вставляє подвійні лапки у рядок.

Продовжуючи тему рядків і масивів, нижче наведено програму, яка розділяє
рядок тексту на окремі слова і підраховує їх. Це проста програма
яка демонструє декілька нових можливостей пішакової мови.

Лістинг: wcount.p

```c

/* підрахунок слів: підрахунок слів у рядку, який вводить користувач */

main()
{
    print "Будь ласка, введіть рядок:  "
    новий рядок[100]
    getstring string, sizeof string

    new count = 0

    нове слово[20]
    новий індекс
    for ( ;; )
    {
        word = strtok(string, index)
        if (strlen(word) == 0)
            break
        count++
        printf "Слово %d: '%s'\n", count, word
    }
    printf "\nКількість слів: %d\n", count
}

strtok(const string[], &index)
{
    new length = strlen(string)

    /* пропустити початковий пробіл */
    while (index < length && string[index] <= ' ')
        index++
    /* зберігаємо слово літера за літерою */
    new offset = index /* зберігаємо початкову позицію токена */
    new result[20] /* рядок для збереження слова */
    while (index < length
        && string[index] > ' '
        && index - offset < sizeof result - 1)
    {
        result[index - offset] = string[index]
        index++
    }
    result[index - offset] = EOS /* зрівняти рядок в нуль */
    повернути результат
}

```

---

`Реляційні оператори: 107`

Послідовність втечі: 99`

Функція main спочатку показує повідомлення і отримує рядок, який
користувач повинен ввести. Потім вона входить у цикл: запис "for (;;)" створює цикл
без ініціалізації, без інкременту і без тесту - це нескінченний цикл,

еквівалентно "while (true)". Однак, якщо синтаксичний аналізатор видасть вам
попередження, якщо ви введете "while (true)" (щось на кшталт "надлишковий тестовий вираз; завжди істинний"), то "for" пройде повз нього.
тестовий вираз; завжди істинний"), "for (;;)" пройде через синтаксичний аналізатор без попередження.

Типовим застосуванням нескінченного циклу є випадок, коли вам потрібен цикл
з тестом в середині - гібрид між циклом while і do. . . . циклом while, так би мовити.
pawn не підтримує цикли з тестом в середині безпосередньо,
але ви можете імітувати його, закодувавши нескінченний цикл з умовним розривом. У
цьому прикладі програми, цикл

- отримує слово з рядка -code перед тестом ;

- перевіряє, чи доступне нове слово, і виходить з циклу, якщо ні - тест в середині;

- виводить слово та його порядковий номер - код після тесту .

Як видно з рядка "word = strtok(string, index)" (і
оголошення змінної word), pawn підтримує присвоювання масивів та функції
що повертають масиви. Синтаксичний аналізатор pawn перевіряє, що масив, який повертає функція strtok
має той самий розмір і розмірність, що і змінна, якій він присвоюється.

Функція strlen є нативною функцією (попередньо визначеною), але strtok не є такою: її потрібно
реалізувати самостійно. Функція strtok була натхненна однойменною функцією
з тією ж назвою з C/C++, але вона не змінює вихідний рядок. Замість цього

вона копіює символи з вихідного рядка, слово за словом, у локальний масив,
який потім повертає.

---

### - Масиви та зчислення (структуровані дані)

У безтиповій мові ми можемо призначити деяким елементам масиву
елементам масиву, ніж іншим елементам того ж масиву. pawn підтримує перераховані
константи з розширенням, яке дозволяє імітувати деякі функції, які
які інші мови реалізують за допомогою "структур" або "записів".

Приклад для ілюстрації зчислень та масивів довший за
попередніх програм-пішаків, а також демонструє деякі інші особливості, такі як глобальні
змінні та іменовані параметри.
Лістинг: queue.p

```c

/* Пріоритетна черга (для простих текстових рядків) */

enum message
{
    text[40 char],
    пріоритет
}

main()
{
    new msg[повідомлення]

    /* вставити декілька елементів (зчитати з консольного вводу) */

    printf "Будь ласка, вставте декілька повідомлень та їхні пріоритети; \
        закінчити порожнім рядком\n"
    for ( ;; )
    {
        printf "Повідомлення:    "
        getstring .string = msg[text], .maxlength = 40, .pack = true
        if (strlen(msg[text]) == 0)
            break
        printf "Пріоритет:  "
        msg[priority] = getvalue()
        if (!insert(msg))
        {
            printf "Черга переповнена, неможливо вставити більше елементів\n"
            break
        }
    }
    /* тепер виводимо повідомлення, витягнуті з черги */
    printf "\nВміст черги:\n"
    while (extract(msg))
        printf "[%d] %s\n", msg[пріоритет], msg[текст]
}

const queuesize = 10
new queue[queuesize][message][message]
new queueitems = 0
insert(const item[message])
{
    /* перевіряємо, чи може черга вмістити ще одне повідомлення */
    if (queueitems == queuesize)
        return false /* черга переповнена */

    /* знайти позицію для вставки */
    new pos = queueitems /* починаємо знизу */
    while (pos > 0 && item[priority] > queue[pos-1][priority])
        --pos /* вищий пріоритет: перемістити на одну позицію вгору */

    /* створюємо місце для елементу в місці вставки */
    for (new i = queueitems; i > pos; --i)
        queue[i] = queue[i-1]

    /* додаємо повідомлення у потрібний слот */
        queue[pos] = item
    queueitems++

    return true
}

extract(item[message])
{
    /* перевіряємо, чи є в черзі ще одне повідомлення */
    if (queueitems == 0)
        return false /* черга порожня */

    /* копіюємо самий верхній елемент */
    item = queue[0]
    --queueitems

    /* пересуваємо чергу на одну позицію вгору */
    for (new i = 0; i < queueitems; ++i)
        queue[i] = queue[i+1]

    return true
}

```

---

Цикл "for": 113`

Оператор перебору: 101`

Оператор "char": 110`

У верхній частині лістингу програми знаходиться оголошення перечислювача mes-
sage. Цей зчислювач визначає дві константи: text, яка дорівнює нулю, і pri- ority, яка дорівнює 11.
аботність, яка дорівнює 11 (припускаючи, що комірка 32-розрядна). Ідея перечислення полягає у тому, щоб
полягає у швидкому визначенні списку символічних констант без дублікатів. За
кожна константа у списку на 1 більша за свою попередницю, а найперша константа у списку дорівнює нулю.
перша константа у списку дорівнює нулю. Однак, ви можете вказати додатковий інкремент для константи
таким чином, щоб константа-спадкоємець мала значення 1 плюс цей додатковий приріст. Для цього слід скористатися командою

text задає додатковий приріст на 40 char. У пішаку char - це оператор
оператором, який повертає кількість комірок, необхідних для
для розміщення упакованого рядка типу

задану кількість символів. Припустимо, що комірка 32-бітна, а символ 8-бітний,
10 комірок можуть містити 40 упакованих символів.

Одразу на початку функції main оголошується нова змінна масиву з параметрами
розміром message. Символ message - це ім'я перечислення. Це
також є константою зі значенням останньої константи у списку зчислень
плюс необов'язковий додатковий приріст для цього останнього елемента. Отже, у цьому прикладі
message дорівнює 12. Тобто, масив msg оголошено таким, що містить 12 комірок.

Далі в main йдуть два цикли. Цикл for зчитує рядки та значення пріоритетів
з консолі і вставляє їх у чергу. Цикл while, наведений нижче
that
витягує елемент за елементом з черги і виводить інформацію на
на екран. Слід зазначити, що цикл for зберігає як рядок, так і
номер пріоритету (ціле число) у тій самій змінній msg; дійсно, функція main
оголошує лише одну змінну. Функція getstring зберігає текст повідомлення
яке ви вводите, починаючи з масиву msg[text], а значення пріоритету зберігається
(за присвоюванням кількома рядками нижче) у msg[priority]. Функція printf
у циклі while зчитує рядок і значення також з цих позицій.

У той же час, масив msg є сутністю сам по собі: він передається повністю
цілком
у функцію insert. Ця функція наприкінці говорить "queue[queueitems]

= item", де item - масив з розміром повідомлення, а queue - це
двовимірний
вимірний масив, який містить елементи розміру queue з повідомленням size. Оголошення queue та queuesize
queue та queuesize знаходиться трохи вище функції insert.

У прикладі реалізовано "пріоритетну чергу". Ви можете вставити кількість
повідомлень
повідомлень у чергу, і коли всі ці повідомлення мають однаковий пріоритет,
вони будуть витягнуті з черги у тому ж порядку. Однак, коли
повідомлення
повідомлення мають різні пріоритети, то повідомлення з найвищим пріоритетом витягується
першим. "Розум" для цієї операції знаходиться всередині функції insert: вона
спочатку
визначає позицію нового повідомлення, яке потрібно додати, потім пересуває кілька повідомлень
на одну позицію вгору, щоб звільнити місце для нового повідомлення. Функція extract
просто завжди отримує перший елемент черги і зсуває всі інші
елементи вниз на одну позицію.

Зверніть увагу, що обидві функції insert і extract працюють з двома спільними змінними,
queue та queueitems. Змінна, яка оголошена всередині функції,
наприклад
змінна msg у функції main, може бути доступна лише з цієї функції.
"Глобальна змінна" доступна усім функціям, і ця змінна
оголошена
за межами області видимості будь-якої функції. Змінні все одно мають бути оголошені до того, як їх буде використано
тому main не може отримати доступ до змінних queue і queueitems, але обидві функції
insert і extract можуть.

---

Функція extract повертає повідомлення з найвищим пріоритетом через аргумент функції
аргумент функції. Тобто вона змінює свій аргумент функції шляхом копіювання
першого елемента масиву черги в item. Функція insert копіює у зворотному
напрямку і не змінює аргумент функції item. У такому випадку
рекомендується позначати аргумент функції як "const". Це допоможе синтаксичному аналізатору pawn
як перевіряти помилки, так і генерувати кращий (компактніший, швидший) код.

Останнє зауваження щодо цього останнього прикладу - виклик getstring у функції main:
Зверніть увагу на те, як параметрам присвоюються описи. Перший параметр
етер має назву ".string", другий - ".maxlength", а третій - ".pack".
Функція getstring отримує "іменовані параметри", а не позиційні параметри.
раметри. Порядок перерахування іменованих параметрів не має значення.
Іменовані параметри зручні для вказівки - і розшифровки - довгих списків па
раметрів у довгих списках.

---

Іменовані параметри: 74`

### - Бітові операції для маніпулювання ''множинами''

Деякі алгоритми найпростіше розв'язуються за допомогою "операцій над множинами", наприклад
перетин,
об'єднання та інверсія. На рисунку нижче, наприклад, ми хочемо розробити алгоритм
алгоритм, який повертає нам точки, до яких можна дістатися з деякої іншої точки
за вказану максимальну кількість кроків. Наприклад, якщо ми попросимо його
повернути точки, яких можна досягти за два кроки, починаючи з точки B, алгоритм повинен
повернути C, D, E і F, але не G, тому що G знаходиться на відстані трьох кроків від B.

Наш підхід полягає в тому, щоб зберігати для кожної точки графіка множину інших точок
до яких вона може дістатися за один крок - це множина "next_step". У нас також є
також маємо множину "результат", яка зберігає всі точки, які ми вже знайшли. Ми почнемо з того, що
встановлюємо множину результатів рівною множині next_step для точки відправлення. Тепер
ми маємо у результуючій множині всі точки, які можна досягти за один крок. Далі, для
кожної точки в нашій множині результатів ми створюємо об'єднання множини результатів і
наступного_кроку для цієї точки. Цей процес повторюється протягом заданої кількості циклів.

---

Процедуру, описану вище, можна пояснити на прикладі. Коли відправною точкою
B, ми починаємо з того, що встановлюємо значення набору результатів на D і E - це точки, до яких
точки, до яких можна дістатися з B за один крок. Потім ми проходимо через
множину результатів. Перша точка, яку ми зустрічаємо у множині - це D, і ми перевіряємо
в які точки можна потрапити з D за один крок: це точки C і F. Отже, ми додаємо
C і F до множини результатів. Ми знаємо, що точки, до яких можна дістатися з
D за один крок, є C і F, тому що C і F знаходяться у множині next_step для

D. Отже, ми об'єднаємо множину next_step для точки D з множиною result
множину. Об'єднання називається "об'єднанням" у теорії множин. Це обробляє точку D. Початковий
також містила точку E, але множина next_step для E порожня, тому
більше не додається жодної точки. Таким чином, нова результуюча множина тепер містить C, D, E і F.

![img](https://i.ibb.co/m9Dq7x2/image.png)

Набір - це контейнер загального призначення для елементів. Єдина інформація, яку
про елемент - це те, чи присутній він у множині, чи ні. Порядок
елементів у множині є несуттєвим, і множина не може містити один і той самий елемент

декілька разів. У мові пішаків не передбачено типу даних "множина" або
операторів, які працюють з множинами. Однак, множини з 32 елементами можуть бути
симулювати за допомогою бітових операцій. Для зберігання стану "присутній/відсутній" потрібен лише один біт
і 32-бітова комірка може зберігати стан для 32 елементів множини
-за умови, що кожному елементу присвоєно унікальну бітову позицію.

Зв'язок між операціями над множинами та побітовими операціями наведено у
наступній таблиці. У таблиці велика літера позначає множину, а
мала літера - елемент з цієї множини.

| поняття, математичні позначення, вираз пішака.
| ------------ | --------------------- | --------------- |
| перетин | A ∩ B | A & B | A & B
| об'єднання | A ∪ B | A I B
| доповнення A ~ A ~ A
| порожня множина ε = 0
членство | x ∈ A | (1 << x ) & A | | (1 << x ) & A | | (1 << x ) & A | | (1 << x ) & A |)

---

Щоб перевірити множину на приналежність, тобто запитати, чи містить вона певний
створіть множину з одним елементом і візьміть точку перетину. Якщо результат
дорівнює 0 (порожня множина), то елемента немає у множині. Нумерація бітів починається
зазвичай з нуля; молодший біт - це біт 0, а старший біт у 32-бітній комірці
є біт 31. Щоб зробити комірку з бітом 7 у множині, зсуньте значення 1 вліво на сім одиниць
-або у виразі з пішаком: "1 << 7".

Нижче наведено програму, яка реалізує описаний раніше алгоритм пошуку
всіх точок, до яких можна дістатися з заданого пункту відправлення за задану кількість
кроків. Алгоритм повністю знаходиться у функції findtargets.

Лістинг: set.p

```c

/* Операції над множинами, використовуючи бітову арифметику */

main()
{
    enum (<<= 1) { A = 1, B, C, D, E, F, G }
    new nextstep[] =

        { C | E, /* A може дістатися до C і E */
           D | E, /* B " " D і E */
           G, /* C " " G */
           C | F, /* D " " C і F */
           0, /* E " " немає */
           0, /* F " " немає */
           E | F, /* G " " E та F */
        }
    #pragma unused A, B

    вивести "Точка відправлення: "
    new source = clamp( .value = toupper(getchar()) - 'A',
                .min = 0,
                .max = sizeof nextstep - 1
                 )
    print "\nКількість кроків:  "
    new steps = getvalue()

    /* створюємо множину */
    new result = findtargets(source, steps, nextstep)
    printf "Точки досяжні з %c за %d кроків:  ", source+'A',
    кроки
    for (new i = 0; i < sizeof nextstep; i++)
        if (result & 1 << i)
            printf "%c ", i + 'A'
}

findtargets(source, steps, nextstep[], numpoints = sizeof nextstep)
{
    новий результат = 0
    new addedpoints = nextstep[source]
    while (steps-- > 0 && result != addedpoints)
    {
        result = addedpoints
        for (new i = 0; i < numpoints; i++)
            if (result & 1 << i)
                addedpoints |= nextstep[i]
    }
    return result
}

```

---

Інструкція enum, що знаходиться під заголовком головної функції, оголошує константи
константи для вершин від A до G, але з деякими змінами. Зазвичай, перерахування починається
відлік з нуля; тут значення першої константи, A, явно задано у вигляді

1. На особливу увагу заслуговує вираз "(<<= 1)" між ключовим словом enum
    і відкриваючою фігурною дужкою, з якої починається список констант: він задає "бітовий" приріст
    зсув" приросту. За замовчуванням, кожна константа у переліку отримує значення, яке на
    на 1 більше за попередню, але ви можете вказати кожну наступну константу
    у зчисленні, щоб вона мала значення, яке є:

його попередник збільшується на будь-яке значення (не лише на 1) - наприклад, "(+= 5)";_.

_його попередник, помножений на будь-яке значення - наприклад, "(_= 3)";\_

_попередник зсунуто вліво на довільну величину - наприклад, "(<<= 1)";_.

Зауважте, що у двійковій арифметиці зсув вліво на один біт дорівнює
що і множення на два, тобто `(/*= 2)` і `(<<= 1)` роблять те саме.

При роботі з множинами типовою задачею, яка виникає, є визначення кількості
елементів у множині. Нижче наведено просту функцію, яка виконує цю задачу:

Лістинг: проста функція підрахунку бітів

```c

bitcount(set)
{
    new count = 0
    for (new i = 0; i < cellbits; i++)
        if (set & (1 << i))
            count++
    повернути count
}

```

При розмірі комірки у 32 біти цикл цієї функції повторюється 32 рази для перевірки
один біт на кожній ітерації. За допомогою магії двійкової арифметики ми можемо
зменшити цикл до циклу лише для кількості "встановлених" бітів.  
Тобто, наступна функція виконується лише один раз, якщо у вхідному значенні встановлений лише один біт:

Лістинг: покращено функцію бітового лічильника

```c

bitcount(set)
{
    new count = 0
    if (set)
        do
            count++
        while ((set = set & (set - 1)))
    return count
}

```

---

Оператор перебору: 101`

`"cellbits" константа: 102`.

---

### - Простий калькулятор RPN

Загальноприйнятий математичний запис, що містить вирази на кшталт "26 3 (5 + 2)",
відомий як алгебраїчний запис. Це компактний запис і
ми
звикли до нього. pawn і, безумовно, більшість інших мов програмування
використовують алгебраїчний запис для своїх програмних виразів. Алгебраїчний запис

однак, має кілька недоліків. Наприклад, іноді
вимагає, щоб порядок виконання операцій був явним, для чого частину виразу
виразу у дужках. Вираз у верхній частині цього абзацу
можна
можна переписати, прибравши дужки, але це призведе до збільшення його довжини майже удвічі.
його довжини. На практиці алгебраїчні позначення доповнюються правилами рівня пріоритету
які говорять, наприклад, що множення йде перед додаванням і відніманням.
віднімання.∗ Рівні пріоритетів значно зменшують потребу в дужках, але не позбавляють від них повністю.
не позбавляють від них повністю. Гірше те, що коли кількість операторів стає великою,
ієрархія рівнів пріоритету і конкретний рівень пріоритету
ієрархія рівнів пріоритету і конкретний рівень пріоритету для кожного оператора стають важкими для запам'ятовування - саме тому багата на оператори
мова, як APL, взагалі відмовляється від рівнів пріоритету.

Приблизно у 1920 році польський математик Ян Лукасевич продемонстрував, що
поставивши оператори перед операндами, а не між ними,

рівні пріоритету стали зайвими, а дужки ніколи не були потрібними.
Цей запис став відомим як "польський запис".† Чарльз Гамблін
пізніше запропонував розміщувати оператори за операндами, назвавши його "зворотним польським записом".

---

###### ∗ Ці правила часто узагальнюються в мнемоніці на кшталт "Будь ласка, вибачте мою дорогу тітку Саллі" (дужки, піднесення до степеня, множення, ділення, додавання, віднімання)

###### \* Польська нотація абсолютно не пов'язана з "угорською нотацією" - це просто звичка додавати до назв змінних або функцій ідентифікаційні знаки "тип" або "призначення"

---

`Алгебраїчна нотація також називається "інфіксною" нотацією`.

`Зворотна польська нотація також називається "постфіксною" нотацією`.

---

Перевага зворотного порядку полягає у тому, що оператори
перераховані у тому ж порядку, у якому вони повинні бути виконані: при
читаючи оператори зліва направо, ви також матимете операції, які потрібно виконати у
тому ж порядку. Алгебраїчний вираз, наведений на початку цього розділу, матиме вигляд
читається у rpn як:

`26 3 5 2 + × -`

Якщо розглядати лише оператори, то ми маємо: спочатку додавання, потім множення, а потім віднімання.
множення і, нарешті, віднімання. Операнди кожного оператора зчитуються
справа наліво: операндами для оператора + є значення 5
і 2, для оператора - результат попереднього додавання
і значення 3, і так далі.

Корисно уявити собі значення, які потрібно скласти у стопку, де оператори
беруть один або декілька операндів з вершини купи і кладуть результат назад на вершину
стопки. При зчитуванні виразу rpn значення 26, 3, 5 і
2 "складаються" у такому порядку. Оператор + видаляє два верхні елементи

зі стеку (5 і 2) і відсуває суму цих значень назад - стек
тепер має вигляд "26 3 7". Потім оператор видаляє 3 і 7 і виштовхує
добуток цих значень до стеку - у стеку тепер "26 21". Нарешті, оператор
віднімає 21 від 26 і зберігає єдине значення 5, кінцевий результат
виразу, назад у стек.

Зворотна польська система числення стала популярною, тому що її було легко зрозуміти і
легко реалізувати у (ранніх) калькуляторах. Він також відкриває шлях до операторів
з більш ніж двома операндами (наприклад, інтегрування) або операторів з більш ніж
одним результатом (наприклад, перетворення між полярними та декартовими координатами).

Основна програма для калькулятора зворотної польської нотації знаходиться нижче:

Посилання: rpn.p

```c

/* простий калькулятор RPN */
#include strtok
#include stack
#include rpnparse

main()
{
    print "Введіть вираз у зворотному польському записі:  "
    new string[100]
    getstring рядок, sizeof рядок
    rpncalc рядок
}

```

---

Основна програма містить дуже мало власне коду; натомість вона включає в себе перероблений код з трьох інших файлів.
код з трьох інших файлів, кожен з яких реалізує декілька функцій, які разом створюють
які разом створюють калькулятор rpn. Коли програми або скрипти стають більшими,
зазвичай рекомендується розподіляти реалізацію по декількох файлах, щоб
щоб полегшити супровід.

Функція main спочатку виводить запит і викликає власну функцію getstring
щоб прочитати вираз, який ввів користувач. Потім вона викликає користувацьку функцію
rpncalc для виконання реальної роботи. Функцію rpncalc реалізовано у файлі
файлі rpnparse.inc, який наведено нижче:

Лістинг: rpnparse.inc

````c

/* основний парсер rpn та лексичний аналіз, частина калькулятора RPN */
#include <rational>
#include <string>

enum токен
{
    t_type, /* тип оператора або токену */
    Rational: t_value, /* значення, якщо t_type рівний "Число" */
    t_word[20], /* сирий рядок */

}

const Number = '0'
const EndOfExpr = '#'

rpncalc(const string[])
{
    новий індекс
    нове поле[токен]
    for ( ;; )
    {
        field = gettoken(string, index)
        switch (field[t_type])
        {
            case Номер:
                push field[t_value]
            case '+':
                push pop() + pop()
            case '-':
                push - pop() + pop()
            case '*':
                push pop() * pop()
            case '/', ':':
                push 1.0 / pop() * pop()
            case EndOfExpr:
                break /* вихід з циклу for */
            за замовчуванням:
                printf "Невідомий оператор '%s'\n", field[t_word]
        }
    }
    printf "Результат = %r\n", pop()
    if (clearstack())
        print "Стек не порожній\n", red
}

gettoken(const string[], &index)
{
    /* спочатку отримати наступне "слово" з рядка */
    new word[20]
    word = strtok(string, index)

    /* потім розбираємо його */
    new field[token]
    field[t_word] = word
    if (strlen(word) == 0)
    {
        field[t_type] = EndOfExpr /* спеціальний "стоп" символ */
        field[t_value] = 0
    }
    else if ('0' <= word[0] <= '9')
    {
        field[t_type] = Number
        field[t_value] = rationalstr(word)
    }
    else
    {
        field[t_type] = word[0]
        field[t_value] = 0
    }
    поле повернення

}

```***

Калькулятор rpn використовує підтримку раціональних чисел і rpnparse.inc містить
файл "rational" для цієї мети. Майже всі операції над раціональними
числами приховано в арифметиці. Єдиними прямими посиланнями на
раціональних чисел є код формату "%r" у операторі printf у нижній частині
функції rpncalc та виклик функції rationalstr на півдорозі gettoken.

Першим примітним елементом у файлі rpnparse.inc є оголошення enum
де один елемент має тег (t_field), а інший елемент має розмір
(t_word). Функція rpncalc оголошує змінну field як масив, використовуючи
символ перечислення як його розмір. За кадром це оголошення робить більше
ніж просто створює масив з 22 комірок:

/*Індексному тегу масиву присвоєно ім'я тегу "token:". Це означає, що ви можете індексувати масив будь-якими елементами зі зчислення, але не значеннями, які мають інший тег. Іншими словами, field[t_type] - це нормально, але field[1] видає діагностику синтаксичного аналізатора.

/*Ім'я тегу перечислення перекриває ім'я тегу змінної масиву, якщо такий є. Змінна field не має тегів, але field[t_value] має тег Rational:, оскільки так оголошено елемент перечислення t_value. Таким чином, ви можете створити масив, елементи якого мають різні імена тегів.

/*Коли елемент перечислення має розмір, елемент масиву, на який вказує цей елемент, іноді розглядається як підмасив. У rpncalc вираз "поле[t_тип]" - це одна комірка, "поле[t_значення]" - одна комірка, але "поле[t_слово]" - це одновимірний масив з 20 комірок. Ми бачимо це конкретно в рядку:

    printf "Unknown operator '%s'\n", field[t_word]

де код формату %s очікує рядок - масив з нульовим закінченням.





Раціональні числа, див. також приклад "Перехід від градусів Цельсія до Фаренгейта" на стор. 16

Оператор перебору: 101`

`Інший приклад індексного тегу: page 68`.



// прийшов сюди




***

Якщо ви знаєте C/C⁺⁺ або Java, вам варто звернути увагу на інструкцію switch.
Оператор switch відрізняється кількома способами від інших мов
у яких він реалізований. Наприклад, випадки не є випадаючими, що, у свою чергу, означає, що
означає, що оператор break для випадку EndOfExpr виходить з охоплюючого циклу
охоплюючого циклу, а не з switch.

У верхній частині циклу for у функції rpncalc ви знайдете інструкцію
інструкцію "field = gettoken(string, index)". Як вже було показано у прикладі програми
wcount.p ("підрахунок слів") на сторінці 19, функції можуть повертати масиви.
Цікавіше виглядає подібний рядок у функції gettoken:

field[t_word] = word

де word - масив з 20 комірок, а field - масив з 22 комірок.
Однак, оскільки поле перерахування t_word оголошено як таке, що має розмір 20 комірок,
"field[t_word]" вважається підмасивом з 20 комірок, що точно відповідає
розміру масиву word.

Лістинг: strtok.inc

```c

/* витягнути слова з рядка (слова повинні бути відокремлені пропуском) */
#include <string> </string

strtok(const string[], &index)
{
    new length = strlen(string)

    /* пропустити початковий пробіл */
    while (index < length && string[index] <= ' ')
        index++

    /* зберігаємо слово літера за літерою */
    new offset = index /* зберігаємо початкову позицію токена */
    new result[20] /* рядок для збереження слова */
    while (index < length
        && string[index] > ' '
        && index - offset < sizeof result - 1)
        {
            result[index - offset] = string[index]
            index++
        }
    result[index - offset] = EOS /* зрівняти рядок в нуль

    повернути результат
}

````

---

`"switch" оператор: page 115`

---

Функція strtok така сама, як і у прикладі wcount.p. Її реалізовано
реалізовано в окремому файлі для програми rpn calculator. Зауважте, що функція
strtok у тому вигляді, у якому вона реалізована тут, може обробляти лише слова з довжиною до 19

символів - 20-й символ є нульовим термінатором. Дійсно універсальна
багаторазова реалізація функції strtok передавала б масив призначення
як параметр, щоб вона могла обробляти слова будь-якого розміру. Підтримка
як запакованих, так і розпакованих рядків також була б корисною властивістю
функції загального призначення.

При обговоренні переваг оберненого польського запису я згадував, що стек
стек є одночасно і допоміжним засобом для "візуалізації" алгоритму, а також
зручний метод для реалізації синтаксичного аналізатора rpn. У цьому прикладі rpn калькулятора використовується
стек з повсюдно використовуваними функціями push і pop. Для перевірки помилок
та скидання стеку є третя функція, яка очищає стек.

Лістинг: stack.inc

```c

/* стекові функції, частина обчислювача RPN */
#include <rational>

static Rational: stack[50]
static stackidx = 0

push(Rational: value)
{
    assert stackidx < sizeof stack
    stack[stackidx++] = value
}

Rational: pop()
{
    assert stackidx > 0
    return stack[--stackidx]
}

clearstack()
{
    assert stackidx >= 0
    if (stackidx == 0)
        return false
    stackidx = 0
    return true
}

```

---

`wcount.p: page 19`

---

Файл stack.inc знову містить файл rational. Це технічно не є
необхідності (rpnparse.inc вже містить визначення для підтримки раціональних чисел), але це не зашкодить
раціональних чисел), але це також не зашкодить, і для зручності повторного використання коду,
краще зробити так, щоб будь-який файл містив визначення бібліотек, від яких він
залежить.

Зверніть увагу, що дві глобальні змінні stack і stackidx оголошено
як "статичні" змінні; з використанням ключового слова static замість new. Це робить глобальні змінні
глобальні змінні "видимими" лише у цьому файлі. Для всіх інших файлів у
більшому проєкті, символи stack і stackidx є невидимими, і вони не можуть (випадково) змінювати змінні.
випадково) модифікувати ці змінні. Це також дозволяє іншим модулям оголошувати
власні приватні змінні з цими іменами, що дозволяє уникнути зіткнення імен.

Калькулятор rpn насправді все ще досить маленька програма, але вона була налаштована
так, ніби це велика програма. Він також був розроблений для демонстрації набору
елементів пішакової мови, а приклад програми можна було б
реалізовано більш компактно.

### - Програмування, кероване подіями

Всі приклади програм, які були розроблені в цій главі до цього часу, використовували
використовували "лінійну" модель програмування: вони починаються з main, і код визначає, що робити, а що ні.
що робити і коли запитувати вхідні дані. Цю модель програмування легко
для розуміння, і вона добре підходить для більшості мов програмування, але ця модель не підходить для багатьох "реальних
модель не підходить для багатьох ситуацій "реального життя". Досить часто програма не може
просто обробити дані і запропонувати користувачеві ввести дані тільки тоді, коли він/вона
користувачеві лише тоді, коли він/вона готовий(а). Натомість, саме користувач вирішує, коли надавати дані,
а програма або скрипт повинні бути готові обробити його за прийнятний
час, незалежно від того, що він робить у цей момент.

З наведеного вище опису випливає, що програма повинна мати можливість переривати свою роботу і займатися іншими справами до того, як вона почне виконувати початкове завдання.
переривати свою роботу і виконувати інші дії перед тим, як продовжити виконання початкового завдання. У
ранніх реалізаціях така функціональність дійсно була реалізована: багатозадачна система
багатозадачна система, де одна задача (або потік) керувала фоновими завданнями
а друга задача/потік, що знаходиться в циклі, постійно запитує вхідні дані у користувача.
Однак це важке рішення. Більш легка реалізація
адаптивної системи є те, що називається "подієво-керованою" моделлю програмування.

---

У моделі подієвого програмування програма або скрипт розбиває будь-яке
довге (фонове) завдання на короткі керовані блоки, а в проміжках між ними
доступні для введення. Однак, замість того, щоб програма опитувала вхідні дані, хост-додаток (або інша підсистема)
хост-додаток (або якась інша підсистема) викликає функцію, яка приєднана
до події - але тільки якщо подія відбувається.

Типовою подією є "вхід". Зверніть увагу, що вхідні дані надходять не лише від
операторів. Вхідні пакети можуть надходити через послідовні кабелі, мережеві стеки,
внутрішні
підсистеми, такі як таймери і годинники, а також всі види іншого обладнання, яке
може бути підключено до вашої системи. Багато пристроїв, які створюють вхідні дані, просто надсилають їх.
вхідні дані, просто надсилають їх. Надходження такого вхідного сигналу є подією, так само, як натискання клавіші
натискання клавіші.
Якщо ви не перехоплюєте події, деякі з них можуть зберігатися у
внутрішня
системної черги, але як тільки черга переповнюється, події просто відкидаються.

pawn безпосередньо підтримує модель, керовану подіями, оскільки підтримує декілька
точок входу. Єдиною точкою входу лінійної програми є головна; керована подіями
програма має точку входу для кожної події, яку вона перехоплює. У порівнянні з
лінійною моделлю, керовані подіями програми часто виглядають "знизу вгору": замість

ваша програма викликає хост-додаток і вирішує, що робити далі,
вашу програму викликають ззовні і вона повинна
відповісти
належним чином і швидко.

pawn не вказує стандартну бібліотеку, і тому немає гарантії, що у
конкретній реалізації будуть працювати функції типу printf та getvalue. Хоча
передбачається, що кожна реалізація надає мінімальний консольний/термінальний
інтерфейс з цими функціями, їх доступність, зрештою, залежить від
реалізація-

залежними. Те саме стосується публічних функцій - точок входу для
скрипту. Це залежить від реалізації, які загальнодоступні функції підтримує хост-додаток.
підтримує хост-додаток. Тому скрипт у цьому розділі може не працювати на вашій платформі
(навіть якщо всі попередні скрипти працювали нормально). Інструменти зі стандартного
дистрибутив
системи pawn підтримують всі скрипти, розроблені у цьому посібнику, за умови, що

ваша операційна система або середовище підтримує стандартні функції терміналу

наприклад, встановлення положення курсору.

Ранньою мовою програмування, яка була розроблена виключно для навчання дітей
концепцій програмування для дітей, була "Лого". Цей діалект LISP робив програмування наочним
програмування наочним, адже маленький робот, "черепашка", їздив по підлозі
під контролем простої програми. Цю концепцію потім скопіювали для переміщення
(зазвичай трикутного) курсору на дисплеї комп'ютера, знову ж таки під контролем
програмою. Новинкою було те, що черепаха тепер залишала за собою слід, що дозволяло
створювати малюнки, правильно запрограмувавши черепаху - це стало відомо як черепашача графіка.

---

Державні функції: 83`

---

Термін "черепашача графіка" також використовувався для позначення активної взаємодії з клавішами клавіатури, а "черепаха" - для позначення поточного
активно за допомогою клавіш зі стрілками на клавіатурі та "черепашки" для позначення поточної
позицію. Такий спосіб малювання на комп'ютері був популярним недовго
до появи миші.

Посилання: turtle.p

```c

@keypressed(key)
{
    /_ отримати поточну позицію */
    new x, y
    деxy x, y

    /_ визначення способу оновлення поточної позиції */
    switch (key)
    {
        case 'u': y-- /_ вгору */
        case 'd': y++ /_ вниз */
        case 'l': x-- /_ вліво */
        case 'r': x++ /_ right */
        case '\e': exit /_ Escape = exit */
    }

    /_ відрегулюйте положення курсору та намалюйте щось */
    перемістити черепашку x, y
}

moveturtle(x, y)
{
    gotoxy x, y
    вивести '/*'
    gotoxy x, y
}

```

Точкою входу наведеної вище програми є @keypressed - вона викликається після натискання клавіші
натискання клавіші. Якщо ви запустите програму і не введете жодної клавіші, функція
функція @keypressed ніколи не виконується; якщо ви введете десять клавіш, @keypressed буде виконано десять разів.
Порівняйте цю поведінку з функцією main: функція main виконується одразу після запуску скрипта.
запуску скрипта і виконується лише один раз.

Допускається додавання функції main до програми, керованої подіями: функція main
слугуватиме для одноразової ініціалізації. Простим доповненням до цього
прикладу програми є додавання головної функції для того, щоб очистити
консоль/
терміналу при вході і, можливо, встановити початкове положення "черепашки"
у центр.

Підтримка функціональних клавіш та інших спеціальних клавіш (наприклад, клавіш зі стрілками) сильно
залежить від системи. На терміналах ANSI ці клавіші створюють інші коди
ніж у "вікні DOS" Windows.

---

Щоб зробити приклад програми
я використовував звичайні літери ("u" для "вгору", "l" для "ліворуч" і т.д.). Це
не означає, що спеціальні клавіші знаходяться поза межами можливостей пішака.

У скрипті "черепаха" клавіша "Escape" завершує роботу хост-програми через
інструкцією виходу. Для простого хоста часу виконання пішака це справді спрацює.
З хост-додатками, де скрипт є надбудовою, або
хост-додатками

які вбудовані в пристрій, скрипт зазвичай не може завершити роботу хост-програми.

### - Кілька подій

Переваги моделі подієво-орієнтованого програмування для побудови реактивних
програм стають очевидними при наявності декількох подій. Насправді,
модель, керована подіями, корисна лише у випадку, якщо у вас більше однієї точки входу
Якщо ваш скрипт обробляє лише одну подію, він може з таким самим успіхом створити цикл опитування
цикл опитування для цієї єдиної події. Чим більше подій потрібно обробити, тим
складнішою стає модель лінійного програмування. Наведений нижче скрипт реалізує просту програму
програму "чату", використовуючи лише дві події: одну для надсилання і одну для отримання.
Скрипт дозволяє користувачам у мережі (або, можливо, через інше з'єднання)
обмінюватися однорядковими повідомленнями.

Скрипт залежить від хост-додатку для надання власних та загальнодоступних
функції для надсилання та отримання "дейтаграм" і для реагування на введені ключі
які вводяться. Як хост-програма надсилає свої повідомлення, через послідовний
послідовною лінією або за допомогою TCP/IP, хост-програма може вирішувати сама. Інструменти з набору

стандартний розподіл пішаків пересилає повідомлення через мережу TCP/IP, і
підтримувати режим "широкомовлення", щоб більше двох людей могли спілкуватися в чаті один з одним.

---

Лістинг: chat.p

```c

#include <datagram>

@receivestring(const message[], const source[])
printf "[%s] каже: %s\n", source, message

@keypressed(key)
{
    статичний рядок[100 char]
    статичний індекс

    if (key == '\e')
        exit /* вихід за натисканням клавіші 'Esc' */

    ехо-клавіша

    if (key == '\r' || key == '\n' || index char == sizeof string)
    {
        string{index} = '\0' /* завершити рядок */
        sendstring рядок

        index = 0
        string[index] = '\0'
    }
    else
        string{index++} = key
}

echo(key)
{
    new string[2 char] = { 0 }
    string{0} = key == '\r' ? '\n' : key
    printf рядок
}

```

Основна частина наведеного вище скрипта обробляє збір отриманих натискань клавіш
у рядок і надсилає цей рядок після того, як побачить клавішу введення. Клавіша "Escape"
завершує роботу програми. Функція echo слугує для візуального відображення того, що
що вводить користувач: вона будує рядок з нульовим закінченням з клавіші і виводить його на друк.

Незважаючи на свою простоту, цей скрипт має цікаву властивість, яка полягає в тому, що в ньому
немає фіксованого або прописаного порядку надсилання та отримання повідомлень
немає схеми запитів-відповідей, де кожен хост має свою чергу говорити і
слухати. Нове повідомлення може бути отримано навіть тоді, коли користувач набирає своє
власне повідомлення.∗

- Державне програмування

У програмі, що працює за подієвою моделлю, події надходять індивідуально, і
на них також реагують окремо. Однак іноді подія є частиною
послідовного потоку, який має оброблятися у певному порядку. Прикладами є передача даних
даних, наприклад, через послідовну лінію. Кожна подія може містити команду,
фрагмент даних, який є частиною більшого файлу, підтвердження або
інші сигнали, які беруть участь у протоколі.

---

###### ∗ Оскільки цей скрипт не намагається відокремити отримані повідомлення від набраних (наприклад, у двох різних областях прокрутки), термінал/консоль виглядатиме заплутано, коли це станеться. З покращеним користувацьким інтерфейсом цей простий скрипт міг би стати чудовою програмою для чату на основі бази повідомлень

---

Щоб потік подій (і пакетів даних, які вони несуть) мав сенс,
програма, керована подіями, повинна слідувати точному протоколу рукостискання.

Щоб дотримуватися протоколу, програма, керована подіями, повинна реагувати на кожну подію
відповідно до (нещодавньої) історії подій, отриманих раніше, та
відповідей на ці події. Іншими словами, обробка однієї події може встановити
"умову" або "середовище" для обробки однієї або кількох наступних подій.

Простою, але досить ефективною абстракцією для побудови реактивних систем
які повинні слідувати (частково) послідовним протоколам, є абстракція "автомата" або
автомата. Оскільки кількість станів зазвичай скінченна, теорія часто
часто називають такі автомати скінченними автоматами або автоматами зі скінченним числом станів (Finite State Automatons). В
автоматі контекст (або умова) події є його станом. Подія
що надходить, може оброблятися по-різному, залежно від стану автомата,
і у відповідь на подію автомат може перейти в інший стан -
це називається переходом. Перехід, іншими словами, як реакція автомата на подію в контексті
автомата на подію в контексті його стану.

Автомати дуже поширені як у програмному забезпеченні, так і в механічних пристроях (ви
можна розглядати жакардовий ткацький верстат як ранній автомат). Автомати зі скінченною кількістю станів
скінченною кількістю станів, є детермінованими (тобто передбачуваними у поведінці)
і їх відносно проста конструкція дозволяє легко
реалізацію з "діаграми станів".

![Діаграма стану](https://i.ibb.co/k3kWVvy/image.png)

На діаграмі станів стани зазвичай зображуються у вигляді кружечків або
закругленими прямокутниками, а стрілки позначають переходи. Оскільки переходи є
реакцією автомата на події, стрілка також може розглядатися як подія, "яка щось робить".

---

Подія/перехід, яка не визначена в конкретному
стані, вважається, що вона не має ніякого ефекту - вона просто ігнорується. Заповнена крапка
позначає початковий стан, який ваша програма (або хост-програма) повинна встановити під час запуску
запуску. Зазвичай на діаграмі станів опускають усі стрілки подій, які повертають
у той самий стан, але тут я вирішив зробити реакцію на всі події явною.

Ця діаграма станів призначена для "розбору" коментарів, які починаються з `/*` і закінчуються
символами `*/`. Існують стани для простого тексту і для тексту всередині коментаря, а також
два стани для попереднього входу до коментаря або виходу з нього. Автомат
призначений для інтерактивного розбору коментарів з символів, які користувач
користувач набирає на клавіатурі. Тому єдиними подіями, на які реагує автомат
є натискання клавіш. Власне, існує лише одна подія ("натискання клавіші") і
перемикачі стану визначаються параметром події - клавішею.

pawn підтримує автомати та стани безпосередньо у мові. Кожна функція*може мати один або декілька станів.
функція* може за бажанням мати один або декілька станів. pawn також підтримує
декілька автоматів, і кожен стан є частиною певного автомата. У мові pawn також підтримується декілька автоматів, і кожен стан є частиною певного автомата.

Наступний скрипт реалізує попередню діаграму станів (в одному, анонімному, автоматі).
автоматом). Щоб відрізнити звичайний текст від коментарів, обидва виводяться
різними кольорами.

Лістинг: comment.p

```c

/* розбирати коментарі C інтерактивно, використовуючи події та машину станів */.

main()
    стан рівнина

@keypressed(key) <plain> <plain>
{
    state (key == '/') slash
    if (key != '/')
        echo key
}

@keypressed(key) <slash> <slash> </slash
{
    state (key != '/') plain
    state (key == '/*') comment
    echo '/' /* print '/', що затримався з попереднього стану */
    if (key != '/')
        echo key
}

@keypressed(key) <коментар> </коментар
{
    echo key
    state (key == '/*') star
}

@keypressed(key) <звезда>
{
    echo key
    state (key != '/*') comment
    state (key == '/') plain
}

echo(key) <plain, slash>.
    printchar key, yellow

echo(key) <коментар, зірка>.
    printchar key, green

printchar(ch, color)
{
    setattr .foreground = color
    printf "%c", ch
}

```

---

###### ∗ За винятком "власних функцій" та операторів, визначених користувачем

---

Функція main встановлює початковий стан в main і виходить; вся логіка
Коли ключ надходить у стан plain, програма перевіряє наявність
косу риску і умовно виводить отриманий ключ. Взаємодія між станами
plain та slash демонструє складність, характерну для автоматів:
ви повинні вирішити, як реагувати на подію, коли вона надходить, не маючи можливості
не маючи можливості "зазирнути наперед" або скасувати реакцію на попередні події. Зазвичай це стосується систем, керованих подіями
випадку з системами, керованими подіями - ви не знаєте, яку подію отримаєте
наступну подію, ані коли ви її отримаєте, і якою б не була ваша реакція на поточну
подію, є велика ймовірність, що ви не зможете стерти її в майбутній події і
зробити вигляд, що цього ніколи не було.

У нашому конкретному випадку, коли надходить слеш, це може бути початком послідовності коментарів
послідовності коментарів (`/*`), але це не обов'язково так. Отже, ми не можемо вирішити, яким кольором друкувати
яким кольором надрукувати символ косої риски. Отже, ми стримуємо
його. Однак у скрипті немає глобальної змінної, яка б вказувала на те, що
що символ затримується - насправді, окрім параметрів функції, у цьому скрипті не оголошено жодної змінної
у цьому скрипті взагалі не оголошено жодної змінної. Інформація про те, що символ утримується
"захована" у стані автомата.

Як видно зі скрипта, зміни стану можуть бути умовними. Умова
не є обов'язковою, і ви також можете використовувати звичайну конструкцію if-else для зміни станів.

Залежність від стану не зарезервована для функцій подій. Інші функції
також можуть мати оголошення стану, як це демонструє функція echo. Коли
функція має однакову реалізацію для декількох станів, вам
просто потрібно написати єдину реалізацію і згадати всі застосовні стани. Для
echo є дві реалізації для обробки чотирьох станів.†

При цьому автомат повинен бути готовим до обробки всіх подій у будь-якому стані.
Як правило, автомат не контролює ні те, які події надходять, ні те, коли вони надходять.
коли вони надходять, тому необробка події у певному стані може призвести до неправильних
рішень. Тому часто трапляється, що деякі події мають сенс лише
лише у кількох конкретних станах, і що вони повинні викликати помилку або процедуру "скидання" у всіх інших випадках.
у всіх інших випадках вони повинні викликати помилку або процедуру "скидання". Функція для обробки події у такому стані "помилка"
може містити багато назв станів, якщо ви будете згадувати їх
їх явно. Існує коротший шлях: якщо не згадувати жодної назви між кутовими дужками
кутовими дужками, функція зіставляє всі стани, які не мають явної імплементації деінде.
не мають явної імплементації в інших місцях. Так, наприклад, ви можете використовувати сигнатуру `echo(key) <>`
для будь-якої з двох реалізацій (але не для обох).

Попередньо визначено один анонімний автомат. Якщо програма містить більше
більше одного автомата, інші повинні бути явно вказані, як у класифікаторі станів функції, так і в
класифікаторі станів функції, так і в інструкції стану. Для цього слід додати
ім'я автомата перед ім'ям стану і розділити імена
автомата і стану двокрапкою. Тобто, "parser:slash" означає
означає слеш стану синтаксичного аналізатора автомата. Функція може бути частиною лише одного автомата
одного автомата; ви можете використовувати одну реалізацію функції для декількох
станів одного автомата, але ви не можете використовувати цю функцію для станів
різних автоматів.

### - Вхідні функції та теорія автоматів

Державні автомати і основа "теорії автоматів" походять від механічного проєктування і пневматичних/пневматичних схем перемикання.
механічного дизайну та пневматичних/електричних схем перемикання (з використанням реле, а не транзисторів).
ніж транзистори). Типовими прикладами є монетоприймачі, керування світлофорами
та комутаційні схеми зв'язку. У цих застосуваннях надійність і
диктованість мають першорядне значення, і було виявлено, що ці цілі найкраще досягаються
коли дії (вихід) були прив'язані до станів, а не до подій (вхід).

---

###### \* Функція, яка має однакову реалізацію для всіх станів, не потребує класифікатора станів - див. printchar

---

![pcl](https://i.ibb.co/PYnBGS9/image.png)

###### Малюнок 1: Світло на пішохідному переході

---

Вхід у стан (необов'язково) спричиняє активність; події спричиняють зміну стану, але
не виконують інших операцій.

У системі освітлення пішохідного переходу світло для транспортних засобів і
пішоходів повинні бути синхронізовані. Очевидно, що поєднання зеленого світла для
зеленого світла для транспорту і знаку "пішохідний перехід" для пішоходів - це рецепт катастрофи. Ми
можемо також одразу відкинути поєднання жовтого / пішохідний перехід як надто
небезпечним. Таким чином, залишається розглянути чотири комбінації. На малюнку нижче наведено
діаграма станів для світлофора пішохідного переходу. Весь процес активується за допомогою
кнопкою і працює за таймером.

![pcl](https://i.ibb.co/9wNR3ry/image.png)

Коли закінчується час дії червоного сигналу світлофора, він не може негайно повернутися до
зелений/зачекайте, тому що пішоходам, які в цей момент переходять дорогу, потрібен час, щоб
в цей момент, потрібен час, щоб звільнити дорогу - стан червоний/зачекайте
дозволяє це зробити.

---

Для демонстрації, цей пішохідний перехід має додаткову
що коли пішохід натискає на кнопку, коли світло світлофора вже горить червоним кольором, час на перехід збільшується.
пішохід натискає на кнопку, коли світло вже червоне, час, який пішохід має для переходу, подовжується.
Якщо стан світлофора червоний/зачекайте, а кнопка натиснута, він перемикається назад на червоний/пішохідний.
Обвідна рамка навколо станів червоний/пішохідний та червоний/зачекайте для обробки події
для обробки події натискання кнопки - це просто зручність для нотації: Я також міг би
намалювати дві стрілки з обох станів назад до червоного/ходити. Вихідний код скрипту
(який наведено нижче) відображає ту ж саму нотаційну зручність.

У реалізації на мові пішаків функції події тепер завжди
мають один оператор, який є або зміною стану, або порожнім оператором.
Події, які не викликають зміни стану, відсутні на діаграмі, але вони
повинні бути оброблені в скрипті; звідси - "запасні" функції подій, які нічого не роблять.

У цьому прикладі програми виводяться лише повідомлення, виведені на консоль
виводяться за допомогою спеціальних функцій. Ввід функції можна
можна розглядати як основний для стану: він неявно викликається, коли вводиться
неявно викликається, коли вводиться стан, до якого вона приєднана. Зауважте, що функція входу також викликається
при "переході" до стану, у якому автомат вже перебуває: коли стан
red_walk виклик @keypressed встановлює стан у red_walk (у якому
він вже перебуває) і викликає функцію входу в стан red_walk - це
повторний вхід у стан.

Лістинг: traffic.p

```c

/* Синхронізатор світлофора, що використовує стани у подієво-керованій моделі */
#include <time>

main() state green_wait

@keypressed(key) <green_wait> стан yellow_wait
@keypressed(key) <red_walk, red_wait> стан red_walk
@keypressed(key) <> {} /* запасний варіант */

@timer() <yellow_wait> стан red_walk
@timer() <red_walk> стан red_wait
@timer() <red_wait> стан green_wait
@timer() <> {} /* запасний варіант */

entry() <green_wait>
    вивести "Зелений / Не ходити\n"

entry() <yellow_wait>
{
    print "Yellow / Don't walk\n"
    settimer 2000
}

entry() <red_walk>
{
    вивести "Red / Walk\n"
    settimer 5000
}

entry() <red_wait>
{
    print "Red / Don't walk\n"
    settimer 2000
}

```

---

Цей приклад програми має додаткову залежність від хостового додатку/середовища
оточення: на додаток до функції події "@натискання клавіші", хост повинен
також передбачити регульовану подію "@timer". Через функції синхронізації,
скрипт містить системний файл time.inc у верхній частині скрипта.

Функції події зі зміною стану знаходяться у верхній частині
сценарію. Функції розміщено так, щоб кожна з них займала один рядок, що створює
структуру, схожу на таблицю. У цьому прикладі всі зміни стану є безумовними, але умовні
зміни стану можна використовувати і з функціями входу. У нижній частині розташовані
функції подій.

Існує два переходи до стану red_walk - або три, якщо врахувати
залежність декількох станів від однієї функції події як просту
нотаційною зручністю: від yellow_wait та від комбінації red_walk і
red_wait. Всі ці переходи проходять через одну і ту ж функцію входу, таким чином
скорочуючи і спрощуючи код.

У теорії автоматів, автомат, який пов'язує вихід із входами в стан,
як у прикладі з пішохідним світлофором, є "автоматом Мура"; автомат, який пов'язує вихід із входами
автомат, який пов'язує вихід з (залежними від стану) подіями або переходами, називається
"автоматом Мілі". Інтерактивний синтаксичний аналізатор коментарів на сторінці 40 є типовим
автоматом Мілі. Ці два типи еквівалентні: автомат Мілі можна
можна перетворити на автомат Мура і навпаки, хоча автомат Мура може потребувати більше станів для реалізації
тону може знадобитися більше станів для реалізації тієї ж самої поведінки. На практиці, ці моделі часто змішуються.
моделі часто змішуються, із загальним дизайном "автомата Мура" і декількома
"дрібних станів", де це економить час.

- Змінні стану

Попередній приклад був створений для демонстрації деяких властивостей
програмування станів з пішаком, але його модель світлофора на пішохідному переході не є

дуже реалістично. Перше, чого не вистачає - це справедливості: пішоходи
не повинні мати можливість блокувати автомобільний рух на невизначений час. Автомобільний рух повинен
бачити зелене світло протягом певного мінімального періоду часу після того, як пішоходи
пішоходи закінчили свій часовий інтервал для переходу дороги. По-друге, багато світлофорів мають
можливість дистанційного керування, так що екстрений транспорт (швидка допомога, пожежна машина, ...)
може змусити зелене світло ввімкнутись на їхньому шляху. Відомим прикладом такого дистанційного керування є

контроль здійснюється за допомогою системи mirt (мобільний інфрачервоний передавач), але не де-факто
стандарту не існує - наприклад, у Нідерландах використовується радіографічна система під назвою vetag.
наприклад, Нідерланди використовують радіографічну систему під назвою vetag.

---

Нова діаграма станів для пішохідного переходу має ще два стани,
але що важливіше: вона повинна зберігати дані про всі події і ділитися ними між
станами. Коли пішохід натискає на кнопку в стані red_wait, ми
не хочемо реагувати на кнопку негайно (це було наше "правило справедливості")
ані проігнорувати кнопку чи "забути" про неї. Іншими словами, ми переходимо до
стан green_wait_interim незалежно від натискання кнопки, але запам'ятовуємо
для рішення, прийнятого в момент виходу зі стану green_wait_interim, але запам'ятовуємо натиснуту кнопку.

Автомати чудово моделюють потоки керування в реактивних/інтерактивних системах, але потік даних
системах, але потік даних традиційно є їхнім слабким місцем. Щоб зрозуміти чому, врахуйте, що
кожна подія обробляється функцією окремо, і що локальні змінні в
що локальні змінні в цій функції зникають при поверненні функції. Отже, локальні змінні не можна
не можна використовувати для передачі даних від однієї події до іншої. Глобальні змінні, хоча
забезпечують обхідний шлях, мають недоліки: глобальна область видимості та
"вічний" час життя. Якщо змінна використовується тільки в обробниках подій одного стану,
бажано приховати її від інших станів, щоб захистити від
випадкової модифікації. Аналогічно, скорочення часу життя до стану(-ів), в якому(-их) активна змінна
змінна є активною, зменшує використання пам'яті. "Змінні стану" забезпечують
поєднання області видимості змінної та часу життя змінної, які прив'язані до серії станів,
а не до функцій чи модулів.

pawn збагачує стандартну скінченну машину (або автомат) змінними
які оголошуються за допомогою класифікатора станів. Ці змінні доступні тільки
доступні лише з перелічених станів, а пам'ять, яку ці змінні займають, може бути
повторно використовуватися для інших цілей, поки автомат знаходиться в іншому стані (відмінному від
від перелічених). Окрім класифікатора станів, оголошення стану

подібне до оголошення глобальної змінної. Оголошення змінної
button_memo у наступному лістингу ілюструє цю концепцію.

---

Лістинг: traffic2.p

```c

/* більш реалістичний синхронізатор світлофорів, включаючи
 * "обхід" для аварійних машин
 */

#include <time>

main()
    стан green_wait_interim

new bool: button_memo <red_wait, green_wait_interim, yellow_wait

@keypressed(key)
{
    switch (key)
    {
        case ' ': button_press
        case '/*': mirt_detect
    }
}

button_press() <зелений_очікування>
    стан жовте_очікування

button_press() <red_wait, green_wait_interim>.
    button_memo = true

button_press() <> /* запасний варіант */
    {}

mirt_detect()
    state mirt_override

@timer() <yellow_wait> </yellow_wait
    стан red_walk

@timer() <червона_прогулянка>
    стан red_wait

@timer() <red_wait>
    стан green_wait_interim

@timer() <green_wait_interim>
{
    state (!button_memo) green_wait
    state (button_memo) yellow_wait
}

@timer() <mirt_override> </mirt_override
    стан green_wait

@timer() <> /* запасний варіант */
    {}

entry() <green_wait_interim>
{
    print "Зелений / Не ходити\n"
    settimer 5000
}

entry() <yellow_wait>
{
    вивести "Жовтий / Не ходити\n"
    button_memo = false
    settimer 2000
}

entry() <red_walk>
{
    вивести "Red / Walk\n"
    settimer 5000
}

entry() <red_wait>
{
    print "Red / Don't walk\n"
    settimer 2000
}

entry() <mirt_override>
{
    print "Green / Don't walk\n"
    settimer 5000
}

```

---

Якщо пішохід натискає кнопку під час активності mirt, це натискання кнопки
буде
забувається. Якщо аварійні ситуації не трапляються часто, це
ймовірно
незначною неприємністю; і це також легко виправити.

- Підсумки державної програми

Держави є всюдисущими, навіть якщо ми не завжди визнаємо їх такими. Концепція
Поняття скінченних автоматів традиційно застосовувалося переважно до про

грами, що імітують механічні пристрої, та програмне забезпечення, яке реалізує протоколи зв'язку.
комунікаційні протоколи. З появою віконних систем, керованих подіями,
машини станів також з'явилися у графічному інтерфейсі десктопних програм. Стани
рясніють у веб-програмах, тому що браузер і хост скриптів веб-сайту
мають лише слабкий зв'язок, але машина станів у веб-додатках зазвичай
реалізована спеціальним чином.

Держави також можна впізнати у спільних проблемах і загадках. У добре
відомій загадці про чоловіка, який повинен перевезти через річку капусту, вівцю і вовка,
∗ стани очевидні - хитрість загадки полягає в тому, щоб уникнути заборонених
станів. Але тепер, коли ми бачимо стани всюди, завдання полягає в тому, щоб не перестаратися.

---

Наприклад, у другій реалізації світлофора на пішохідному переході, див.
сторінку 47, я використовував змінну (button_memo) для зберігання критерію для рішення, яке буде прийнято
рішення, яке буде прийнято пізніше. Альтернативною реалізацією могло б бути додавання пари
більше станів для утримання ситуацій "червоне - очікування і натиснута кнопка" і "зелене -
проміжне очікування і натиснута кнопка". Тоді більше не знадобиться жодної змінної, але
але ціною більш складної діаграми станів та реалізації. Загалом
кількість станів повинна бути невеликою.

Хоча автомати забезпечують хорошу абстракцію для моделювання реактивних та інтерактивних систем, створення правильної схеми не є простим завданням.
тивних систем, прийти до правильної діаграми не так просто, а іноді просто важко.
часом просто дуже складно. Занадто часто "сценарій сонячного дня" станів і
подій, а все, що відхиляється від цього шляху, додається експромтом.
додається експромтом. Такий підхід несе в собі ризик того, що деякі комбінації
подій та станів будуть забуті, і дійсно, я зустрічав дві діаграми з коментарями
діаграми синтаксичного аналізатора (на зразок тієї, що на сторінці 40) різних авторів книг/журналів
які мали подібні недоліки. Натомість я раджу зосередитися на
на подіях і на реакції на окремі події. Для кожної держави слід розглядати кожну подію
розглядати кожну подію; не варто надто поспішно прокладати події через загальний запасний варіант.

На жаль, стало поширеною практикою впроваджувати теорію автоматів
з додатками, для яких існують кращі рішення. Один з прикладів, який часто повторюється
це автомат, який накопичує вартість серії монет, або "обчислює" залишок від ділення
монет, або який "обчислює" залишок після ділення на 3 двійкового числа. Ці
застосування могли б мати сенс у механічному/пневматичному дизайні, де

∗ Чоловік має переправити вовка, вівцю та капусту через річку в човні, який вміщує лише
через річку у човні, який вміщує лише 2 речі: людину і ще щось. Якщо вовк залишиться сам, то з'їсть вівцю.
вівцю, а вівця з'їсть капусту. Як чоловік може переправити їх через річку?

стан" - це єдина пам'ять, яку має автомат, але в програмному забезпеченні краще використовувати змінні та арифметичні операції.
варіацій та арифметичних операцій є кращим вибором. Інший типовий приклад
це зіставлення слів або шаблонів за допомогою автомата станів: кожен наступний елемент, що вводиться, переходить у новий стан.
кожний наступний введений елемент переходить у новий стан. Лексичні сканери, такі як ті.
які компілятори та інтерпретатори використовують для інтерпретації вихідного коду, можуть використовувати такі
станів для фільтрації "зарезервованих слів". Однак, для будь-якого практичного набору
зарезервованих слів, такі автомати стають громіздкими, і ніхто не буде розробляти
їх вручну. Крім того, немає жодної причини, чому лексичний сканер не може
зазирнути вперед у тексті або повернутися до позначки, яку він встановив раніше - що є
що є одним із критеріїв вибору державної реалізації в першу чергу,
і, нарешті, рішення на кшталт трикратного пошуку, ймовірно, простіші в розробці та впровадженні
але при цьому не менш швидкі.

У цій книжці я оминув формальний опис нотації для позначення
на діаграмах станів - частково тому, що вона відповідає звичайній нотації.
Закруглений прямокутник для стану містить назву стану і, за бажанням, короткий опис того, що робить функція входу в стан
короткий опис того, що робить функція входу у стан. Стрілка
для переходу містить назву події (або псевдоподії), необов'язкову умову
необов'язкову умову у квадратних дужках і необов'язкову дію за косою рискою ("/").

- Верифікація програми

Чи не повинен компілятор/інтерпретатор ловити всі помилки? Це риторичне питання
має як технічну, так і філософську сторони. Я опускаю всі
нетехнічні аспекти і лише зазначу, що на практиці існує компроміс
між "виразністю" комп'ютерної мови та "примусовою правильністю" (або
"доведеною коректністю" програм цією мовою. Зробити мову дуже
"суворою" не є рішенням, якщо потрібно виконати роботу, яка перевищує розмір
іграшкової програми. Занадто сувора мова змушує програміста боротися з
мовою, в той час як "проблема, яку потрібно вирішити" повинна бути справжньою боротьбою, а
а мова має бути простим засобом для вираження рішення.

Мета мови пішаків - надати розробнику неформальний,
і зручним у використанні механізмом для перевірки того, чи працює програма так, як було
задумано. Цей механізм називається "твердженнями" і, хоча концепція
тверджень передує ідеї "проєктування за контрактом", її найлегше пояснити через ідею
пояснити через ідею проєктування за контрактом.

Парадигма "проєктування за контрактом" пропонує альтернативний підхід до вирішення проблем, пов'язаних з помилковими умовами.
з помилковими умовами. Передумовою є те, що програміст
знає поставлену задачу, умови, за яких має працювати програма, і

середовище. У такому середовищі кожна функція визначає конкретні
умови у вигляді тверджень, які мають бути істинними, перш ніж клієнт зможе
виконати функцію. Крім того, функція може також визначати будь-які умови
які мають бути істинними після того, як вона завершить свою роботу. Це і є "контракт" функції
функції.

---

Назву "дизайн за контрактом" придумав Бертран Мейєр, а його принципи ґрунтуються на логіці предикатів та алгоритмічному аналізі.
походить від логіки предикатів та алгоритмічного аналізу.

- Передумови визначають допустимі значення вхідних параметрів та атрибутів середовища;

- Постумови визначають вихідні дані та (можливо, модифіковане) середовище;

- Інваріанти вказують на умови, які повинні виконуватися в ключових точках функції, незалежно від шляху, пройденого через функцію.

Наприклад, функція, яка обчислює квадратний корінь з числа, може вказати
що її вхідний параметр має бути невід'ємним. Це є передумовою. Вона також може
вказати, що її вихід, піднесений до квадрату, дорівнює вхідному значенню 0.01%. Це постумова
постумова; вона перевіряє правильність роботи підпрограми. Зручним
спосіб обчислення квадратного кореня - це "бісекція". На кожній ітерації цей алгоритм
дає принаймні один додатковий біт (двійкову цифру) точності. Це інваріант
(хоча це може бути інваріант, який важко перевірити).

Передумови, постумови та інваріанти схожі в тому сенсі, що вони
всі вони складаються з тесту і що невдалий тест вказує на помилку у
реалізації. Як наслідок, ви можете реалізувати передумови, постумови та інваріанти за допомогою однієї конструкції: "твердження".
інваріанти за допомогою однієї конструкції: "твердження". Для передумов слід писати
на самому початку підпрограми; для інваріантів напишіть твердження
де інваріант має виконуватися; для постумов пишіть твердження перед
кожним оператором "return" або в кінці функції.

У pawn інструкція називається assert; це простий оператор, який
містить тест. Якщо результат тесту "істина", нічого не відбувається. Якщо результат
"false", інструкція assert завершує роботу програми з повідомленням, що містить
що містить деталі невдалого твердження.

Твердження - це перевірка, яка ніколи не повинна давати збоїв. Справжні помилки, такі як
наприклад, помилки введення даних користувачем, слід обробляти за допомогою явних тестів у програмі, а
а не з допомогою тверджень. Як правило, вирази, що містяться у твердженнях, повинні бути
не мати побічних ефектів: твердження ніколи не повинно містити код, який потрібен для коректної роботи вашої
програма потребує для коректної роботи.

---

`Приклад функції добування квадратного кореня (бісектриса usin): 79`

---

Однак це призводить до того, що твердження ніколи не спрацьовують у
без вад: вони просто роблять код товстішим і повільнішим, без жодної видимої користувачеві
користі для користувача. Але не все так погано. Додатковою особливістю тверджень є те, що
що ви можете збирати код без тверджень, просто використовуючи прапорець або опцію
до синтаксичного аналізатора. Ідея полягає у тому, що ви вмикаєте твердження під час розробки
і збираєте "роздрібну версію" коду без тверджень. Це кращий
підхід, ніж вилучення тверджень, тому що всі твердження автоматично
"повертаються" при перекомпіляції програми - наприклад, для технічного обслуговування.

Під час супроводу, або навіть під час початкової розробки, якщо ви виявили помилку
яка не була відловлена твердженням, перед тим, як виправити помилку, вам слід подумати
про те, як твердження могло б запобігти цій помилці. Потім додайте це твердження
і перевірте, чи дійсно воно перехоплює помилку, перш ніж виправляти її. Роблячи так
код поступово стане міцнішим і надійнішим.

- Коментарі до документації

Коли програми стають більшими, документування програми та функцій
стає життєво важливим для її підтримки, особливо під час роботи в команді. Інструменти мови
pawn має деякі функції, які допоможуть вам у документуванні
код у коментарях. Документування програми або бібліотеки у коментарях до неї має
кілька переваг, наприклад: документацію легше підтримувати в актуальному стані
з програмою, це ефективно у тому сенсі, що програмні коментарі тепер
подвійно є документацією, а синтаксичний аналізатор допомагає вашим зусиллям з документування у створенні синтаксичних описів та
створення синтаксичних описів та перехресних посилань.

Кожен коментар, який починається з трьох косих рисок
("/// "), за якими слідує пробіл, або починається з косої риски та двох зірочок ("//_/_ ")
з подальшим пропуском, є
спеціальним коментарем до документації. Компілятор pawn витягує коментарі документації
і за бажанням записує їх до файлу "report". Зверніться до документації до програми
документацію до програми або додаток B, щоб дізнатися, як увімкнути створення звіту.

Зауважимо, що коментарі, які починаються з "/_", все одно слід закривати символом "_/".
Однорядкові коментарі до документації ("///") закриваються у кінці рядка.

Файл звіту - це XML-файл, який згодом може бути перетворений на HTML-документацію
документацію за допомогою таблиці стилів XSL/XSLT або запускати за допомогою інших інструментів для
для створення друкованої документації. Синтаксис файлу звіту сумісний з
синтаксисом продуктів для розробників ".Net" - за винятком того, що заставний компілятор зберігає
більше інформації у звіті, ніж просто витягнуті рядки документації.
Файл звіту містить посилання на таблицю стилів "smalldoc.xsl".

---

`Коментувати синтаксис: 97`

---

Наведений нижче приклад ілюструє коментарі до документації у простому скрипті, який
має декілька функцій. Ви можете писати коментарі до документації для функції
над її оголошенням або в її тілі. Усі коментарі документації, які з'являються
до кінця функції, приписуються функції. Ви можете
також
додати коментарі документації до глобальних змінних і глобальних констант - ці
коментарі повинні з'являтися над оголошенням змінної або константи. На
2 показано частину виводу для цього (досить довгого) прикладу. Стиль
виведення
можна налаштувати у каскадній таблиці стилів (CSS-файл), пов'язаній з файлом
файлом перетворення XSLT.

Посилання: weekday.p

```c

/**

- Ця програма ілюструє алгоритм конгруентності Целлера для обчислення

- день тижня, на який припадає дата.

*/

/**

- <summary> </summary> </summary> <summary> </summary

- Основна програма: просить користувача ввести дату і друкує

  на

- на який день тижня припадає ця дата.

- </summary> </summary> </summary> </summary> </summary> </summary

*/
main()
{
    новий день, місяць, рік
    if (readdate(day, month, year))
    {
        new wkday = weekday(день, місяць, рік)
        printf "Дата %d-%d-%d припадає на ", день, місяць, рік
        switch (wkday)
        {
            case 0:
            вивести "субота"
            case 1:
            вивести "неділя"
            case 2:
            вивести "понеділок"
            випадок 3:
            вивести "Tuesday"
            випадок 4:
            вивести "Wednesday"
            випадок 5:
            вивести "четвер"
            випадок 6:
            вивести "Friday"
        }
    }
    else
        вивести "Невірна дата"
    print "\n"
}

/**

- <summary> </summary> </summary> <summary> </summary

- Основна функція алгоритму конгруентності Целлера.  Функція

- працює за григоріанським календарем.

- </summary> </summary> </summary> </summary> </summary> </summary

-

- <param name="day"> </param

- День у місяці, значення від 1 до 31.

- </param> </param

- <param name="month"> </param

- Місяць: значення від 1 до 12.

- </param> </param

- <param name="year"> </param name="year">

- Рік з чотирьох цифр.

- </param> </param

-

- <returns>

- День тижня, де 0 - субота, а 6 - п'ятниця.

- </returns> </returns> </returns> </returns> </returns> </returns

-

- <зауваження>

- Ця функція не перевіряє дійсність дати; коли

  "У нас тут є

- дата в параметрах невірна, повертається "day of the

  тиждень".

- буде мати неправильне значення.

- <p/>

- Це рівняння не працює у багатьох мовах програмування, зокрема у більшості

- реалізаціями C, C++ та Pascal, оскільки ці мови

  мають

- нечітко визначений оператор "залишок".  Пішак, з іншого боку

  руку,

- надає істинний оператор за модулем, як визначено в математичній

- теорію і так, як це було задумано Целлером.

- </рекомендації></рекомендації

*/

weekday(день, місяць, рік)
{
/**

- <зауваження>

- Для алгоритму конгруентності Целлера місяці січень та

- Лютий - 13-й і 14-й місяць <em>попереднього</em> року.

- року.  Ідея полягає в тому, що "важкий місяць" лютий (який

- має 28 або 29 днів) переноситься на кінець року.

- </рекомендації></рекомендації

*/

    if (month <= 2)
        month += 12, --year

    new j = рік % 100
    new e = year / 100
    return (day + (month+1)*26/10 + j + j/4 + e/4 - 2*e) % 7
}

/**

- <summary> </summary> </summary> <summary> </summary

- Зчитує дату та зберігає її у трьох окремих полях. tata

- </summary> </summary> </summary> </summary> </summary> </summary

-

- <param name="day"> </param

- Після повернення зберігатиметься номер дня.

- </param> </param

- <param name="month"> </param

- Зберігатиме номер місяця після повернення.

- </param> </param

- <param name="year"> </param name="year">

- Зберігатиме номер року після повернення.

- </param> </param

-

- <returns>

- <em>true</em>, якщо дата дійсна, <em>false</em> в іншому випадку;

- якщо функція повертає <em>false</em>, то значення

- <paramref name="day"/>, <paramref name="month"/> та

- <paramref name="year"/> не можна використовувати.

- </returns> </returns> </returns> </returns> </returns> </returns

*/

bool: readdate(&day, &month, &year)
{
    print "Введіть дату (дд-мм-гггг): "
    day = getvalue(\_,'-','/')
    month = getvalue(\_,'-','/')
    year = getvalue()
    return 1 <= month <= 12 && 1 <= day <= daysinmonth(month,year)
}

/**

- <summary> </summary> </summary> <summary> </summary

- Повертає, чи є рік високосним.

- </summary> </summary> </summary> </summary> </summary> </summary

-

- <param name="year"> </param name="year">

- Рік з 4-х цифр.

- </param> </param

-

- <зауваження>

- Рік - це високосний рік:

- <ul>

- <li> якщо воно ділиться на 4, </li>

- <li> але <strong>не</strong>, якщо воно ділиться на 100,

</li> </li> <li>Примітка:</li>

- <li> але воно <strong>є</strong> ділиться на 400.

</li> </li> <li>Примітка:</li>

- <ul>

- </рекомендації></рекомендації

*/

bool: isleapyear(рік)

return year % 400 == 0 || year % 100 != 0 && year % 4 == 0

/**

- <summary> </summary> </summary> <summary> </summary

- Повертає кількість днів у місяці (місяць - це

  ціле число

- в діапазоні 1 ... 12).  За рік потрібно здати як

  що ж,

- оскільки функція враховує високосні роки.

- </summary> </summary> </summary> </summary> </summary> </summary

-

- <param name="month"> </param

- Номер місяця, значення від 1 до 12.

- </param> </param

- <param name="year"> </param name="year">

- Рік з 4-х цифр.

- </param> </param

*/

daysinmonth(місяць, рік)
{
    static daylist[] = { 31, 28, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31 }
    assert 1 <= month <= 12
    return daylist[month-1] + \_:(month == 2 && isleapyear(year))
}

```

Формат XML-файлу, що створюється продуктами для розробників ".Net"
задокументовано у документації Microsoft. Синтаксичний аналізатор створює міні-опис кожної функції, змінної або константи, що використовується у файлі.
опис кожної функції, глобальної змінної або константи, яка використовується в проєкті, незалежно від того, чи використовувалися
у проєкті, незалежно від того, чи використовувалися для цього коментарі у документації
функцію/змінну/константу. Синтаксичний аналізатор також генерує декілька власних тегів:

| ім'я та інформація
| ---------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| attribute | Атрибути для функції, наприклад, "native" або "stock".                                                                                                                                                                            |
| автомат | Автомат, до якого належить функція (якщо такий є).                                                                                                                                                                               |
| залежність | Назви символів (інших функцій, глобальних змінних та/чи глобальних констант), яких потребує функція. За бажанням, з залежностей можна побудувати дерево викликів.                                                    |
| param | Параметри функції. Коли ви додаєте опис параметра до коментаря документації, цей опис буде об'єднано з автоматично згенерованим вмістом для параметра.                                                              |
| paraminfo | Теги та інформація про масив або посилання на параметр.                                                                                                                                                                            |
| referrer | Усі функції, які посилаються на цей символ, тобто всі функції, які використовують або викликають цю змінну/функцію. Цієї інформації достатньо, щоб слугувати "перехресним посиланням" - дерево "посилань" є оберненим до дерева "залежностей". |

---

![fig2](https://i.ibb.co/VmQS0fL/image.png)

###### Рисунок 2: Документація, створена на основі вихідного коду

| ім'я та інформація
| ---------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
| stacksize | Орієнтовна кількість комірок, які функція виділить у стеку та купі. Ця оцінка використання стеку не враховує вимоги до стеку будь-яких функцій, які "викликаються" з функції, до якої застосовується документація. Наприклад, функція readdate задокументована як така, що займає 6 комірок у стеку, але вона також викликає daysinmonth, яка займає 4 додаткові комірки - і, у свою чергу, викликає isleapyear. Щоб обчислити загальні вимоги до стеку для функції readdate, слід розглянути дерево викликів. Окрім локальних змінних та параметрів функцій, компілятор також використовує стек для зберігання проміжних результатів у складних виразах. Простір у стеку, необхідний для цих проміжних результатів, також не розглядається у цьому звіті. Загалом, необхідні накладні витрати на проміжні результати не є кумулятивними (для всіх функцій), тому було б неточно додавати "запас міцності" до кожної функції. Для програми в цілому настійно рекомендується мати запас міцності. У додатку B (сторінка 168) описано опцію -v, за допомогою якої можна визначити максимальне використання стеку на основі дерева викликів. |
| tagname | Мітка константи, змінної, результату функції або параметра(ів) функції.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| перехід | Переходи, які викликає функція, та їхні умови - див. розділ про автомати на сторінці 38.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |

---

Весь текст у коментарях до документації також копіюється до кожної
функцію,
змінну або константу, до якої його приєднано. Текст у документації
копіюється без подальшої обробки - за одним винятком, див. нижче.
Оскільки решта файлу звіту знаходиться у форматі XML, а найбільш підходящим способом
обробки XML в онлайнову документацію є XSLT-процесор (наприклад, сучасний браузер), ви можете вибрати
сучасний браузер), ви можете вибрати будь-яке форматування в документації
коментарі за допомогою тегів HTML. Зауважте, що вам часто потрібно буде явно закривати
будь-які HTML-теги; стандарт HTML не вимагає цього, але XML/XSLT-процесори
процесори XML/XLT зазвичай вимагають цього. Набір інструментів pawn постачається з прикладом XSLT-файлу

(з відповідною таблицею стилів), який підтримує наступні теги XML/HTML:

| ім'я та інформація
| ----------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------- |
| `<code> </code>` | Попередньо відформатований вихідний код шрифтом з моноширинним інтервалом; хоча символи "&", "<" і ">" мають бути набрані як "&amp;", "&lt;" і "&rt;" відповідно.             |
| `<example> </example>` | Текст, розміщений під підзаголовком "Приклад".                                                                                                           |
| `<param name="..."> </param>` | Опис параметра, причому ім'я параметра міститься у відкриваючому тезі (опція "name="), а опис параметра слідує за ним. |
| `<paramref name="..." />` | Посилання на параметр, з назвою параметра всередині відкриваючого тегу (опція "name=").                                         |
| | `<remarks> </remarks>` | Текст, розміщений під підзаголовком "Примітки".                                                                                                           |
| `<returns> </returns>` | Текст у підзаголовку "Повернення".                                                                                                           |
| `<seealso> </seealso>` | Текст у підзаголовку "Див. також".                                                                                                          |
| `<summary> </summary>` | Текст, розміщений безпосередньо під заголовком символу.                                                                                               |
| | `<section> </section>` | Задає текст у заголовку. Це слід використовувати лише у документації, яка не пов'язана з функцією або змінною.                             |
| | `<підрозділ> <підрозділ>` | Задає текст у підзаголовку. Цей параметр слід використовувати лише у документації, яка не пов'язана з функцією або змінною.                         |

---

Наступні додаткові HTML-теги підтримуються для загального форматування тексту всередині будь-якого з перерахованих вище розділів:

| ім'я та інформація
| ---------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Текст набрано моноширинним шрифтом.                                                                                                                                       |
| `<em> </em>` | Текст виділяється, зазвичай курсивом.                                                                                                                             |
| `<p> </p>` | Текст починається з нового абзацу. Замість того, щоб обгортати <p> і </p> навколо кожного абзацу, можна вставити <p/> як роздільник між двома абзацами, що дасть той самий ефект. |
| `<para> </para>` | Альтернатива для <p> </p>.                                                                                                                                         |
| `<ul> </ul>` | Невпорядкований (маркований) список.                                                                                                                                        |
| Впорядкований (нумерований) список.                                                                                                                                          |
| Елемент у впорядкованому або невпорядкованому списку.                                                                                                                             |

---

Як зазначалося, є один виняток в обробці коментарів до документації
коментарів документації: якщо ваш коментар документації містить тег `<param ...>` (і відповідний йому `</param>`), то
відповідний `</param>`), парсер пішаків шукає параметр і комбінує
ваш опис параметра із вмістом, який він автоматично
згенерованим автоматично.

### - Попередження та помилки

Великою перешкодою, яку я переступив, є те, як насправді скомпілювати код
фрагментів коду, представлених у цій главі. Причина в тому, що процедура залежить від
від системи, яку ви використовуєте: у деяких програмах є кнопка "Зробити" або
"Скомпілювати скрипт" або пункт меню, тоді як в інших середовищах
вам потрібно ввести команду на кшталт "sc myscript" у командному рядку. Якщо
ви використовуєте стандартний набір інструментів pawn, ви знайдете настанови щодо
використання компілятора і часу виконання у супровідному буклеті "The pawn booklet

- Посібник користувача".

Незалежно від відмінностей у запуску компілятора, явище, яке
в результаті запуску компілятора, скоріш за все, буде дуже схожим
між усіма системами:

- або компіляція завершиться успішно і створить виконувану програму, яка може запускатися автоматично після компіляції, а може і не запускатися;

- або компілятор видасть список попереджень та повідомлень про помилки.

---

- Помилки трапляються, і парсер пішаків намагається зловити якомога більше з них
може. Коли ви перевіряєте код, на який скаржиться синтаксичний аналізатор, то
іноді вам може бути досить важко зрозуміти, чому код є помилковим
(або підозрілий). Наступні підказки можуть вам допомогти:

- Кожна помилка або попередження пронумеровані. Ви можете знайти повідомлення про помилку з цим номером у додатку А разом з коротким описом того, що насправді означає це повідомлення.

- Якщо синтаксичний аналізатор видає список помилок, то перша помилка у цьому списку є справжньою помилкою, але діагностичні повідомлення під нею можуть взагалі не бути помилками. Коли синтаксичний аналізатор бачить помилку, він намагається переступити через неї і завершити компіляцію. Однак, спотикання на помилці може збити синтаксичний аналізатор з пантелику, так що наступні правильні оператори будуть неправильно інтерпретовані і також повідомлені як помилки. Якщо ви сумніваєтеся, виправте першу помилку і повторіть компіляцію.

- Синтаксичний аналізатор перевіряє лише синтаксис (орфографію/граматику), а не семантику (тобто "значення") коду. Коли він виявляє код, який не відповідає синтаксичним правилам, насправді може існувати багато способів змінити код, щоб він став "правильним" у синтаксичному сенсі цього слова - навіть якщо багато з цих "виправлень" призведуть до безглуздого коду. В результаті, однак, синтаксичний аналізатор може мати труднощі з точним визначенням місця помилки: він не знає, що ви хотіли написати. Тому синтаксичний аналізатор часто виводить два номери рядків, а помилка знаходиться десь у діапазоні (між номерами рядків).

- Пам'ятайте, що програма, яка не містить синтаксичних помилок (синтаксичний аналізатор приймає її без повідомлень про помилки та попереджень), може мати семантичні та логічні помилки, які синтаксичний аналізатор не може виявити. Інструкція assert (стор. 112) призначена для того, щоб допомогти вам виявити ці помилки "під час виконання".

---

### - На завершення

Якщо ви знаєте мову програмування C, ви побачите багато концепцій
з якими ви вже знайомі, а також кілька нових. Якщо ви не знаєте C, то темп
цього вступу, ймовірно, був досить високим. Незалежно від того, чи ви новачок у C

або досвідчені в C, я рекомендую вам уважно прочитати наступні сторінки. Якщо
ви знаєте C або схожу на неї мову, до речі, вам варто спершу ознайомитися з
розділ "Підводні камені" (сторінка 134).

Ця брошура намагається бути водночас і неформальним вступом, і (більш формальною)
специфікацією мови одночасно, можливо, не досягнувши успіху ні в тому, ні в іншому. Оскільки
це також стандартна книга про пішаків,* основна увага в цій брошурі зосереджена на тому, щоб
точності та повноті, а не на тому, щоб її було легко зрозуміти.

Подвійна природа цього буклету проявляється в порядку, в якому
в якому він представляє теми. Спочатку розглядаються великі концептуальні частини мови, змінні
та функції, розглядаються спочатку. Оператори, оператори та загальні
синтаксичні правила йдуть далі - не тому, що вони менш важливі, а тому, що їх легше
вивчати, шукати або сприймати як належне.

---

###### ∗ Це вже не єдина книга про Пішака

---

[Повернутися до змісту](00-Contents.md)
