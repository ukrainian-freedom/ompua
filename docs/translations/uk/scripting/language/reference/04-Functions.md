# Функції

---

В оголошенні функції вказується ім'я функції та, між парентезами, її формальні параметри.
тезами, її формальні параметри. Функція може також повертати значення. Оголошення функції
має бути оголошена на глобальному рівні (тобто поза будь-якими іншими функціями) і
бути доступним на глобальному рівні.

Якщо після оголошення функції стоїть крапка з комою (а не інструкція), то оголошення
означає пряме оголошення функції.

Оператор return повертає результат функції. Наприклад, функція sum (див. нижче)
повертає значення обох аргументів, доданих разом. Вираз
не є обов'язковим для функції, але не можна використовувати значення функції
функції, яка не повертає значення.

Лістинг: функція суми

```c

sum(a, b)
повернути a + b

```

Аргументами функції є (неявно оголошені) локальні змінні для цієї функції.
Виклик функції визначає значення аргументів.

Інший приклад повного визначення функції leapyear
(яка повертає true для високосного року і false для невисокосного):

Лістинг: функція високосного року

```c

leapyear(y)
return y % 4 == 0 && y % 100 != 0 || y % 400 == 0

```

Логічні та арифметичні оператори, використані в прикладі з високосним роком, описані
на сторінках 108 та 104 відповідно.

Зазвичай функція містить оголошення локальних змінних і складається з оператора ком
фунта інструкції. У наступному прикладі зверніть увагу на інструкцію assert для
для захисту від від'ємних значень експоненти.

Лістинг: функція степеня (піднесення до степеня)

```c

power(x, y)
{
    /* повертає x, піднесений до степеня y */
    assert y >= 0
    new r = 1
    for (new i = 0; i < y; i++)
        r *= x
    return r
}

```

Функція може містити декілька операторів повернення - зазвичай це робиться так
для швидкого виходу з функції при помилці параметра або коли з'ясовується, що функція
що функція не має чого робити. Якщо функція повертає масив,
всі оператори повернення повинні вказувати масив з однаковим розміром і однаковими розмірностями.

---

`Переважний спосіб оголошення прямих функцій наведено на сторінці 82`

твердження "стверджую": 112`

---

- Аргументи функції (виклик за значенням проти виклику за посиланням)

Функція "факультет" у наступній програмі має один параметр, який вона використовує
у циклі для обчислення факультету цього числа. Що заслуговує на увагу, так це те.
що функція змінює свій аргумент.

Посилання: faculty.p

```c

/* Обчислення факторіалу значення */ ** Обчислення факторіалу значення */

main()
{
    print "Введіть значення: "
    new v = getvalue()
    new f = faculty(v)
    printf "Факультет %d - це %d\n", v, f
}

faculty(n)
{
    assert n >= 0

    new result = 1
    while (n > 0)
        result *= n--> result *= n--> result *= n--> result *= n--> result *= n--

    повернути результат
}

```

Яким би (додатним) не було значення "n" на вході в цикл while
у функції faculty, в кінці циклу "n" буде дорівнювати нулю. У випадку з функцією
faculty параметр передається "за значенням", тому зміна "n"
є локальною для функції факультету. Іншими словами, функція main передає "v" як
на вхід функції faculty, але після повернення функції faculty, "v" все ще має те саме
значення, яке було до виклику функції.

Аргументи, що займають одну комірку, можна передавати за значенням або за посиланням.
За замовчуванням використовується "передача за значенням". Щоб створити аргумент функції, який передається
за посиланням, додайте до імені аргументу символ &.

Приклад:

Лістинг: функція заміни

```c

swap(&a, &b)
{
    new temp = b
    b = a
    a = temp
}

```

Щоб передати масив у функцію, додайте пару дужок до імені
до імені аргументу. За бажанням ви можете вказати розмір масиву; це покращує
перевірку помилок синтаксичного аналізатора.

Приклад:

Лістинг: адикторна функція

```c

addvector(a[], const b[], size)
{
    for (new i = 0; i < size; i++)
        a[i] += b[i]
}

```

Масиви завжди передаються за посиланням. Зауважимо, що масив b у вищенаведеному прикладі
не змінюється в тілі функції. Аргумент функції
оголошено як const, щоб зробити це явним. На додаток до покращення перевірки помилок
перевірки помилок, це також дозволяє синтаксичному аналізатору генерувати більш ефективний код.

Щоб передати у функцію масив літералів, використовуйте той самий синтаксис, що і для
ініціалізаторів масиву: рядок літералів або послідовність індексів масиву, взятих у фігурні дужки
(див. сторінку 99; еліпсис для прогресивних ініціалізаторів не можна використовувати). Літеральні
масиви можуть мати лише один вимір.

Наступний фрагмент викликає addvector для додавання п'яти до кожного елементу масиву "vect":

Лістинг: використання адвектора

```c

new vect[3] = { 1, 2, 3 }

addvector(vect, {5, 5, 5}, 3)

/* vect[] тепер має значення 6, 7 та 8 */.

```

Виклик функції printf з рядком "Hello world\n" у першій
є ще одним прикладом передачі літерального масиву у функцію.

---

`Інший приклад - функція JulianToDate на сторінці 13`.

`Константні змінні: 64`

Програма "Hello world": 5`

---

### - Виклик функцій

Якщо вставити ім'я функції з її параметрами у оператор або вираз
функція буде виконана у цьому операторі/виразі.  
Оператор, який посилається на функцію, є "викликаючим", а сама функція - "викликається",
у цей момент є "отримувачем", тобто тією, яку викликають.

Стандартний синтаксис виклику функції полягає у написанні імені функції
з наступним переліком усіх параметрів, що явно передаються, у круглих дужках.
Якщо не передано жодного параметра або якщо функція не має жодного параметра, пара дужок
дужок за назвою функції все одно залишаються присутніми. Наприклад, щоб випробувати функцію power
функцію power, наступна програма викликає її таким чином:

Лістинг: приклад програми для функції потужності

```c

main()
{
    print "Please give the base value and the power to raise it to:"
    new base = getvalue()
    new power = getvalue()

    new result = power(base, power)
    printf "%d піднесений до степеня %d дорівнює %d", base, power, result
}

```

Функція може за бажанням повертати значення. Функції sum, leapear та power
повертають значення, а функція swap - ні. Навіть якщо функція
повертає значення, користувач може проігнорувати його.

Для ситуації, коли викликаюча сторона ігнорує значення, що повертається функцією, існує
альтернативний синтаксис виклику функції, який також проілюстровано
У попередньому прикладі програма викликає функцію power. Дужки навколо
всі аргументи функції є необов'язковими, якщо користувач не використовує значення, що повертається.

В останньому операторі прикладу програми читається

`printf "%d піднесено до степеня %d дорівнює %d", основа, степінь, результат

замість того, щоб

`printf("%d піднесено до степеня %d дорівнює %d", основа, степінь, результат)`

який робить те саме.

Синтаксис без круглих дужок навколо списку параметрів називається синтаксисом "виклику про
виклик процедури". Ви можете використовувати його тільки якщо:

- викликач не присвоює результат функції змінній і не використовує його у виразі або як "тестовий вираз", наприклад, в інструкції if;

- перший параметр не починається з відкриваючого парантезу;

- перший параметр знаходиться у тому ж рядку, що й назва функції, якщо тільки ви не використовуєте іменовані параметри (див. наступний розділ).

Як ви можете помітити, синтаксис виклику процедури застосовується у випадках, коли виклик функції
поводиться скоріше як оператор, як у викликах print та printf у попередньому прикладі
попередньому прикладі. Синтаксис спрямовано на те, щоб зробити такі оператори менш
менш зашифрованими і зручнішими для читання, але це не означає, що використання синтаксису є необов'язковим.

Зауважимо, що усі дужки у прикладі програми, наведеному у цьому розділі
є обов'язковими: значення, що повертаються при виклику getvalue, зберігаються
у двох змінних, а тому після функції має стояти порожня пара круглих дужок
ім'я. Функція getvalue має необов'язкові параметри, але у цьому прикладі жоден з них не передається.

---

`Функціональна потужність: 70`

`Функції сума та високосний рік: 70`

Заміна функцій: 71`

---

### - Іменовані параметри проти позиційних параметрів

У попередніх прикладах порядок параметрів виклику функції був важливим, оскільки
важливим, оскільки кожен параметр копіюється до аргументу функції з тією самою послідовною позицією
з однаковою послідовною позицією. Наприклад, у функції weekday (яка
використовує алгоритм конгруентності Целлера), визначену як показано нижче, ви повинні викликати
weekday(12,31,1999), щоб отримати день тижня останнього дня попереднього століття.

Лістинг: робота в будні дні

```c

weekday(місяць, день, рік)
{
    /* повертає день тижня: 0=субота, 1=неділя і т.д. */
    if (month <= 2)
        month += 12, --year
    new j = year % 100
    new e = year / 100
    return (day + (month+1)*26/10 + j + j/4 + e/4 - 2*e) % 7
}

```

Формати дат варіюються залежно від культури та нації. У той час як формат місяць/
день/рік поширений у Сполучених Штатах Америки, в європейських
країни часто використовують формат день/місяць/рік, а технічні публікації іноді
стандартизуються у форматі рік/місяць/день (ISO/IEC 8824). Іншими словами
жоден порядок аргументів у функції дня тижня не є "логічним" або "загальноприйнятим".
З огляду на це, альтернативним способом передачі параметрів у функцію є
використовувати "іменовані параметри", як у наступних прикладах (три виклики функції є еквівалентними):

Лістинг: використання в будні дні - позиційні параметри

```c

new wkday1 = weekday( .month = 12, .day = 31, .year = 1999)

new wkday2 = weekday( .day = 31, .month = 12, .year = 1999)

new wkday3 = weekday( .year = 1999, .month = 12, .day = 31)

```

З іменованими параметрами перед іменем аргументу функції ставиться крапка (".").
аргументу функції. Аргументом функції може бути будь-який вираз, який є допустимим
для аргументу. Знак рівності ("=") у випадку іменованого параметра
параметра не вказує на присвоєння, а зв'язує вираз, який слідує після знаку рівності
до одного з аргументів функції.

У виклику функції можна змішувати позиційні та іменовані параметри
з обмеженням, що всі позиційні параметри повинні передувати будь-яким іменованим
параметрам.

### - Значення аргументів функції за замовчуванням

Аргумент функції може мати значення за замовчуванням. Значення за замовчуванням для аргументу функції
має бути константою. Щоб вказати значення за замовчуванням, додайте до імені аргументу знак рівності
("=") і значення до імені аргументу.

Якщо у виклику функції замість дійсного аргументу вказано заповнювач
застосовується значення за замовчуванням. Заповнювачем аргументу є символ підкреслення
("\_"). Заповнювач аргументу дійсний лише для аргументів функції
які мають значення за замовчуванням.

Крайні праві заповнювачі аргументів можна просто вилучити зі списку аргументів функції
зі списку аргументів функції. Наприклад, якщо інкремент функції визначено як:

Лістинг: функція інкременту - значення за замовчуванням

```c

increment(&value, incr=1) value += incr

```

наступні виклики функцій є еквівалентними:

Лістинг: використання інкременту

```c

increment(a)
increment(a, \_)
increment(a, 1)

```

Значення аргументів за замовчуванням для аргументів, що передаються за посиланням, корисно зробити
вхідний аргумент необов'язковим. Наприклад, якщо функція divmod призначена
для повернення як частки, так і залишку від ділення через
аргументи, значення за замовчуванням роблять ці аргументи необов'язковими:

Лістинг: функція divmod - значення за замовчуванням для опорних параметрів

```c

divmod(a, b, &quotient=0, &remainder=0)
{
    quotient = a / b
    остача = a % b
}

```

З попереднім визначенням функції divmod, наступні виклики функції
тепер є дійсними:

Лістинг: використання divmod

```c

new p, q

divmod(10, 3, p, q)
divmod(10, 3, p, \_)
divmod(10, 3, \_, q)
divmod(10, 3, p)
divmod 10, 3, p, q

```

Аргументи за замовчуванням для аргументів-масивів часто зручно задавати за замовчуванням
рядок або підказку для функції, яка отримує рядковий аргумент. Наприклад:

Лістинг: функція друку помилок

```c

print_error(const message[], const title[] = "Помилка: ")
{
    вивести заголовок
    вивести повідомлення
    вивести "\n"
}

```

Наступний приклад додає поля одного масиву до іншого масиву і за замовчуванням
збільшує перші три елементи масиву-приймача на одиницю:

Лістинг: адикторна функція, переглянута

```c

addvector(a[], const b[] = {1, 1, 1}, size = 3)
{
    for (new i = 0; i < size; i++)
    a[i] += b[i]
}

```

---

`Зовнішні функції не підтримують значення аргументів за замовчуванням; див. сторінку 83`

---

### - оператор sizeof та аргументи функції за замовчуванням

Значення аргументу функції за замовчуванням має бути константою, і його значення
визначається в місці оголошення функції. Використання оператора
"sizeof" для встановлення значення аргументу функції за замовчуванням є окремим випадком: обчислення значення виразу
обчислення значення виразу sizeof відкладається до моменту виклику функції
функції і приймає розмір фактичного аргументу, а не формального.
формального аргументу. Коли функція використовується у програмі декілька разів,
з різними аргументами, результат виразу sizeof потенційно може бути
може бути різним при кожному виклику - а це означає, що "значення за замовчуванням" аргументу функції
може змінитися.

Нижче наведено приклад програми, яка генерує десять випадкових чисел у діапазоні
0-51 без повторень. Прикладом застосування програми для генерування випадкових чисел без
випадкових чисел без дублікатів є карткові ігри - ці десять чисел можуть замінити дві "руки" у грі в покер.
ють карти для двох "рук" у грі в покер. Переваги алгоритму
алгоритму, винайденого Робертом В. Флойдом, полягає в тому, що він є ефективним і
неупереджений - за умови, що генератор псевдовипадкових чисел також є неупередженим.

Лістинг: randlist.p

```c

main()
{
    new HandOfCards[10] </ new HandOfCards
    FillRandom(HandOfCards, 52)

    вивести "Жеребкування 10 чисел з діапазону від 0 до 51 \n
        (включно) без повторів:\n"
    for (new i = 0; i < sizeof HandOfCards; i++)
        printf "%d ", HandOfCards[i]
}

FillRandom(Series[], Range, Number = sizeof Series)
{
    assert Range >= Number /* не можна вибрати 50 значень
                                     * без повторень в діапазоні
                                     * наприклад, в діапазоні 0..40 */
    new Index = 0
    for (new Seq = Range - Number; Seq < Range; Seq++)
    {
        new Val = random(Seq + 1)
        new Pos = InSeries(Series, Val, Index)
        if (Pos >= 0)
        {
            Series[Index] = Series[Pos]
            Series[Pos] = Seq
        }
        else
            Series[Index] = Val
        Index++
    }
}

InSeries(Series[], Value, Top = sizeof Series)
{
    for (new i = 0; i < Top; i++)
        if (Series[i] == Value)
            повернути i
    return -1
}

```

У функції main оголошується масив HandOfCards розміром десять комірок, а потім
викликає функцію FillRandom, яка виводить десять додатних випадкових
випадкових чисел, менших за 52. Зверніть увагу, що єдині два параметри, які main
передаються у виклик FillRandom, є масив HandsOfCards, в якому
де повинні зберігатися випадкові числа, і верхня межа "52". Кількість
випадкових чисел для малювання ("10") передається до FillRandom неявно.

У визначенні функції FillRandom, наведеному нижче, для її третього параметра вказано: "Number" - це перший параметр, а "Series" - це другий параметр.
"Number = sizeof Series", де "Series" посилається на перший параметр
функції. Через особливий випадок "sizeof значення за замовчуванням", значення за замовчуванням
значенням за замовчуванням аргументу Number є не розмір формального аргументу Series,
а розмір фактичного аргументу в момент виклику функції: HandOfCards.

Зверніть увагу, що всередині функції FillRandom, запитуючи "sizeof" функції ар-гумент Series, ми все одно отримаємо нульове значення.
gument Series (як і раніше) отримає нульове значення, оскільки масив Series
оголошено з невизначеною довжиною (див. поведінку sizeof на сторінці 109).
Використання sizeof як значення за замовчуванням для аргументу функції є особливим випадком. Якщо
формальний параметр Series було оголошено з явним розміром, як у
Series[10], було б зайвим додавати аргумент Number з масивом
розмір фактичного аргументу, оскільки синтаксичний аналізатор буде змушений переконатися, що обидва аргументи
формальний і фактичний аргументи мають однаковий розмір і розмірність.

---

`"sizeof " оператор 109`

`"random" - це запропонована основна функція, див. сторінку 124`.

`Декларації масивів: 64`

`Імена тегів: 68

---

### - Аргументи з іменами тегів

Тег необов'язково ставиться перед аргументом функції. Використання тегів покращує
перевірку помилок під час компіляції скрипта, а також
слугує "неявним документуванням" функції.
"неявним документуванням" функції. Наприклад, функція, яка обчислює квадратний корінь

вхідного значення з точністю до фіксованої крапки може вимагати, щоб вхідний параметр
є значенням з фіксованою комою, і щоб результат також був з фіксованою комою. Функція
нижче використовує модуль розширення з фіксованою точкою і алгоритм наближення
відомий як "бісекція" для обчислення квадратного кореня. Зверніть увагу на перевизначення тегів
для числових літералів і результатів виразів.

Лістинг: функція sqroot - сильні теги

```c

Fixed: sqroot(Fixed: value)
{
    new Fixed: low = 0.0
    new Fixed: high = value
    while (high - low > Fixed: 1)
    {
        new Fixed: mid = (low + high) >> 1
        if (fmul(mid, mid) < value)
            low = mid
        else
            high = mid
    }
    return low
}

```

З вищенаведеним визначенням, парсер пішаків видає діагностику, якщо викликати функцію
sqroot з параметром з тегом, відмінним від "Fixed:", або коли
намагається зберегти результат функції у змінній з тегом "non-Fixed:".

Алгоритм бісекції пов'язаний з бінарним пошуком в тому сенсі, що він
безперервно зменшує вдвічі інтервал, в якому повинен знаходитись результат. Алгоритм "послідовної заміни", такий як алгоритм Ньютона-Раффа
алгоритм "послідовної підстановки", такий як Ньютона-Рафсона, який враховує нахил кривої функції
враховує нахил кривої функції, досягає точних результатів швидше, але ціною того, що критерій зупинки
критерій зупинки складніше сформулювати. Сучасні алгоритми
для обчислення квадратних коренів поєднують алгоритми бісекції та Ньютона-Рафсона.

У випадку масиву, індекси масиву також можуть бути позначені тегами. Наприклад
функція, яка створює перетин двох прямокутників, може бути записана так:

Лістинг: функція перетину

```c

intersection(dest[rectangle], const src1[rectangle], const src2[rectangle])
{
    if (src1[right] > src2[left] && src1[left] < src2[right])
    && src1[bottom] > src2[top] && src1[top] < src2[bottom])
    {
        \* є перетин, обчислити його з допомогою функцій "min" та
         *функціями "max" з бібліотеки "core", див. сторінку 124. */

        dest[left] = max(src1[left], src2[left])
        dest[right] = min(src1[right], src2[right])
        dest[top] = max(src1[top], src2[top])
        dest[bottom] = min(src1[bottom], src2[bottom])
        return true
    }
    else
    {
        /* "src1" та "src2" не перетинаються */
        dest = { 0, 0, 0, 0, 0 }
        return false
    }
}

```

---

`Арифметика з фіксованою комою: 90; див. також примітку до програми "Бібліотека підтримки арифметики з фіксованою комою"`.

`Щодо тегу "rectangle" див. сторінку 68`.

---

### - Змінні аргументи

Функція, яка отримує змінну кількість аргументів, використовує оператор "еліпсис" ("...") у заголовку функції для позначення позиції першої змінної.
ator ("...") у заголовку функції для позначення позиції першої змінної
аргументу. Функція може звертатися до аргументів з наперед визначеними функціями-номерами
numargs, getarg і setarg (див. сторінку 124).

Функція sum повертає суму всіх її параметрів.
Вона використовує список параметрів змінної довжини.

Лістинг: функція суми, переглянута

```c

sum(...)
{
    новий результат = 0
    for (new i = 0; i < numargs(); ++i)
        result += getarg(i)
    повернути результат
}

```

Ця функція може бути використана в:

Лістинг: використання функції sum

```c

new v = sum(1, 2, 3, 4, 5)

```

Перед еліпсом може стояти мітка, яка гарантує, що всі наступні параметри мають однакові мітки, але у протилежному випадку помилки не буде
перевірка зі змінним списком аргументів, тому цю функцію слід використовувати з обережністю.

Функції getarg і setarg припускають, що аргумент передається "за
посиланням". При використанні getarg на звичайних параметрах функції (замість
аргументів-змінних) слід бути обережним, оскільки ні компілятор, ні
абстрактна машина не можуть це перевірити. Реальні параметри, які передаються
як частина "списку аргументів-змінних", завжди передаються за посиланням.

---

`Імена тегів: 68

---

### - Правила примусу

Якщо аргумент функції, згідно з визначенням функції (або її оголошенням),
є "параметром-значенням", користувач може передати його як параметр функції:

- значення, яке передається за значенням;

- посилання, значення якого передається;

- (індексований) елемент масиву, який є значенням.

Якщо аргумент функції є посиланням, викликаюча сторона може перейти до функції:

- значення, адреса якого передається;

- посилання, яке передається за значенням, оскільки воно має тип, який очікує функція;

- (індексований) елемент масиву, який є значенням.

Якщо аргумент функції є масивом, користувач може передати його у функцію:

- масив з тими самими розмірами, початкова адреса якого передається;

- (індексований) елемент масиву, у цьому випадку передається адреса елемента.

### - Рекурсія

У прикладі функції факультету, наведеному раніше у цій главі, використовувався простий цикл. Приклад функції
функція, яка обчислювала число з ряду Фібоначчі, також використовувала
цикл і додаткову змінну, щоб виконати трюк. Ці дві функції є найбільш
популярними процедурами для ілюстрації рекурсивних функцій, тому, реалізувавши їх як
їх як ітераційні процедури, ви можете подумати, що pawn не підтримує рекурсію.

Так, пішак підтримує рекурсію, але обчислення факторіалів та чисел Fі
чисел Боначчі є гарними прикладами того, коли не варто використовувати рекурсію.
Обчислення факторіалу легше зрозуміти за допомогою циклу, ніж за допомогою рекурсії.  
Розв'язування чисел Фібоначчі за допомогою рекурсії дійсно спрощує проблему, але ціною
ціною надзвичайної неефективності: рекурсивний Фібоначчі обчислює одні й ті ж
значення знову і знову.

Наведена нижче програма є реалізацією відомої гри "Вежі Ханоя" у рекурсивній функції:

Посилання: hanoi.p

```c

/* Вежі Ханоя, гра, розв'язана за допомогою рекурсії*/.

main()
{
    print "Скільки дисків: "
    new disks = getvalue()
    move 1, 3, 2, disks
}

move(from, to, spare, numdisks)
{
    if (numdisks > 1)
        перемістити з, spare, на, numdisks-1
    printf "Перемістити диск зі стовпчика %d на стовпчик %d\n", from, to
    if (numdisks > 1)
        перемістити spare, to, from, numdisks-1
}

```

---

"факультет": 71`

"Фібоначчі": 11`

"Існує інтригуюче ітеративне рішення для веж Ханоя".

---

### - Форвардні декларації

Для стандартних функцій поточна "еталонна реалізація" компілятора pawn
не вимагає оголошення функцій перед їх першим використанням.∗
Визначені користувачем оператори є спеціальними функціями, і на відміну від стандартних функцій
вони повинні бути оголошені перед використанням. У багатьох випадках зручно помістити
реалізацію визначеного користувачем оператора у включаємому файлі, щоб його реалізація та оголошення передували будь-якому
виклику/виклику. Однак іноді може бути необхідним (або зручним) спочатку оголосити визначений користувачем оператор
а потім реалізувати його в іншому місці. Особливо часто ця техніка використовується для реалізації
"заборонених" операторів користувача.

Щоб створити оголошення forward, додайте перед назвою функції та списком її параметрів слово forward
теру ключовим словом forward. Для сумісності з ранніми версіями
pawn, а також для схожості з C/C⁺⁺, альтернативним способом прямого оголошення
функції є введення заголовка функції і завершення його крапкою з комою
(яка слідує за закриваючою круглою дужкою зі списком параметрів).

Повний опис функції з непорожнім тілом
реалізовано деінде у вихідному файлі (за винятком заборонених користувацьких операторів).

Державні класифікатори ігноруються у форвардних деклараціях.

---

###### ∗ Інші реалізації мови Pawn (якщо вони існують) можуть використовувати синтаксичні аналізатори "за один прохід", які вимагають визначення функцій перед використанням.

---

`Заборонені користувацькі оператори: 92`

---

### - Державні класифікатори

Усі функції, окрім власних функцій, можуть за бажанням мати атрибут стану.
Він складається зі списку назв станів (і автоматів), укладених у кутові дужки
за заголовком функції. Назви розділено комами. Якщо атрибут
стан є частиною автомата не за замовчуванням, назва автомата і двокрапка
і двокрапка повинні передувати стану; наприклад, "parser:slash" означає
означає стан слеш синтаксичного аналізатора автомата.

Якщо функція має стани, у вихідному коді має бути декілька "реалізацій" функції.
Усі функції повинні мати однаковий заголовок функції (за винятком списку класифікатора станів).

Як спеціальний синтаксис, коли між кутовими дужками немає імен, функція
зв'язується з усіма станами, які не приписані іншим
реалізаціям функції. Функція, яка обробляє "всі стани, які не обробляються в інших місцях"
є так званою резервною функцією.

### - Публічні функції, функція main

Автономна програма повинна мати функцію main. Ця функція є
початковою точкою програми. Функція main може не мати аргументів.

Бібліотека функцій не обов'язково повинна мати головну функцію, але вона повинна мати або
головну функцію, або принаймні одну загальнодоступну функцію. Головна функція є основною
точкою входу у скомпільовану програму; загальнодоступні функції є
альтернативні точки входу до програми. Віртуальна машина може почати виконання з
однієї із загальнодоступних функцій. Бібліотека функцій може мати головну функцію для
виконувати одноразову ініціалізацію під час запуску.

Щоб зробити функцію загальнодоступною, додайте до її назви ключове слово public.
Наприклад, текстовий редактор може викликати загальнодоступну функцію "onkey" для кожної клавіші
яку ввів користувач, щоб користувач міг змінювати (або відхиляти) натискання клавіш. Функція
onkey, наведена нижче, замінить кожен символ "~" (код 126 у наборі символів ISO
Latin-1) на код "пробіл" у таблиці символів ANSI:

Лістинг: функція клавіші

```c

public onkey(код ключа)
{
    if (key=='~')
        return 160 /* замінити ~ на пробіл (код 160 латиницею-1) */
    else
        повернути ключ /* інші ключі залишити без змін */
}

```

---

Приклад: 40`

---

Функції, назва яких починається з символу "@", також є загальнодоступними. Отже
альтернативний спосіб написання загальнодоступної функції - функція onkey:

Лістинг: Функція @onkey

```c

@onkey(код ключа)
    return key=='~' ? 160 : key

```

Символ "@" при використанні стає частиною імені функції, тобто в
останньому прикладі функція називається "@onkey". Хост-додаток вирішує
імена загальнодоступних функцій, які може реалізувати скрипт.

Аргументи публічної функції можуть не мати значень за замовчуванням. Загальнодоступна функція
з'єднує хост-додаток зі скриптом пішака. Отже, аргументи
передані у загальнодоступну функцію, походять з хост-додатку, і хост-додаток не може знати, які "значення за замовчуванням
програма не може знати, які "значення за замовчуванням" встановив автор сценарію для
аргументи функції - саме тому парсер пішаків позначає використання значень за замовчуванням
для аргументів загальнодоступних функцій як помилку. Проблема значень за замовчуванням
в аргументах загальнодоступних функцій виникає лише у випадку, якщо ви хочете викликати загальнодоступні функції з самого скрипта.

### - Статичні функції

Якщо до імені функції додано ключове слово static, область видимості функції
обмежується файлом, у якому знаходиться функція.

Атрибут static можна комбінувати з атрибутом "запас".

### - Біржові функції

"Запасна" функція - це функція, яку синтаксичний аналізатор повинен "підключити" до
програму, коли вона використовується, і яку він може просто "вилучити" з програми
(без попередження), коли вона не використовується. Запасні функції дозволяють компілятору або
інтерпретатору оптимізувати використання пам'яті та розмір файлу (скомпільованої)
програма-пішак: будь-яка стокова функція, на яку не посилаються, повністю пропускається
-так, ніби вона відсутня у вихідному файлі.

Отже, типове використання фондових функцій полягає у створенні набору
"бібліотечних" функцій. Набір функцій загального призначення, позначених як "запаси", можна
можна помістити в окремий include-файл, який потім буде включено до будь-якого пішакового
скрипт. Тільки ті бібліотечні функції, які дійсно використовуються, будуть "підключені".

Щоб оголосити стокову функцію, додайте до імені функції ключове слово stock.
Загальнодоступні та власні функції не можуть бути оголошені як stock.

Коли функція-стокс викликає інші функції, зазвичай, гарною практикою є
оголошувати ці інші функції також як "стокові" - за винятком
власних функцій. Аналогічно, будь-які глобальні змінні, які використовуються стоковою функцією
функцією, у більшості випадків також слід визначати як "запаси". Видалення невикористовуваних (запасних) функцій
функції може спричинити ланцюгову реакцію, за якої інші функції та глобальні змінні
до інших функцій та глобальних змінних також більше не буде доступу. Ці функції також будуть видалені,
таким чином продовжуючи ланцюгову реакцію до тих пір, поки не залишаться тільки ті функції, які використовуються,
прямо чи опосередковано, не залишаться лише функції, які використовуються.

---

`Значення аргументів функції за замовчуванням: 75`

`Змінні загального доступу можуть бути оголошені як "stock"`

`Змінні в запасі: 63`

---

### - Нативні функції

Програма-пішак може викликати специфічні для програми функції через "власну функцію".
Нативна функція повинна бути оголошена у програмі-пішаку за допомогою
прототипу функції. Назві функції має передувати ключове слово native.

Приклади:

```c

native getparam(a[], b[], size)

native multiply_matrix(a[], b[], size)

native openfile(const name[])

```

Імена "getparam", "multiply_matrix" та "openfile" є внутрішніми
іменами власних функцій; це імена, під якими функції відомі
функції відомі у програмі-пішаку. За бажанням, ви також можете задати зовнішнє
зовнішнє ім'я для нативної функції, тобто ім'я, під яким функція відома у "хост-програмі".
Для цього перед прототипом функції слід поставити знак рівності, а потім зовнішнє ім'я. Наприклад:

```c

native getparam(a[], b[], size) = host_getparam

native multiply_matrix(a[], b[], size) = mtx_mul

```

Коли нативна функція повертає масив, розміри та розмір масиву ar-
променя повинні бути оголошені явно. Специфікація масиву міститься між
назвою функції та списком параметрів. Наприклад:

```c

enum rect { left, top, right, bottom }
native intersect[rect](src1[rect], src2[rect])

```

Якщо не вказано явно, зовнішнє ім'я дорівнює внутрішньому імені
власної функції. Одним з типових випадків використання явних зовнішніх імен є встановлення символічного імені
символічного імені для визначеного користувачем оператора, який реалізовано як власну функцію.

Див. "Посібник реалізатора" для реалізації нативних функцій у C/C++ (на стороні "хост-додатку").

Нативні функції можуть не мати специфікаторів стану.

---

`Приклад власного визначеного користувачем оператора наведено на сторінці 89`

---

### - Оператори, визначені користувачем

Єдиним типом даних пішака є "комірка", як правило, 32-бітне число або бітовий
шаблон.

Мітки: 68 Значення значення у комірці залежить від конкретного застосування - це не завжди має бути
pawn дозволяє прикріпити "значення" до комірки за допомогою механізму "тегів".

На основі тегів pawn також дозволяє перевизначати оператори для комірок
з певною метою. У прикладі нижче визначено тег "ones" та оператор
для додавання двох значень "одиниць" (у прикладі також реалізовано оператори
оператори віднімання та заперечення). Приклад був натхненний алгоритмом контрольної суми
декількох протоколів з набору протоколів TCP/IP: він імітує арифметику доповнення
арифметику доповнення, додаючи біт переносу арифметичного переповнення назад
до найменшого значущого біта значення.

Лістинг: ones.p

```c

forward ones: operator+(ones: a, ones: b)
forward ones: operator-(ones: a, ones: b)
forward ones: operator-(ones: a)

main()
{
    new ones: chksum = ones: 0xffffffffffff
    print "Вхідні значення у шістнадцятковому форматі, нуль для виходу\n"

    нові: значення
    do
    {
        вивести ">> "
        value = ones: getvalue(.base=16)
        chksum = chksum + value
        printf "Checksum = %x\n", chksum
    }
    while (value)
}

stock ones: operator+(ones: a, ones: b)
{
    const ones: mask = ones: 0xffff /* маска слова */
    const ones: shift = ones: 16 /* зсув слова */

    /* додавання малих та великих слів окремо*/
    new ones: r1 = (a & mask) + (b & mask)
    нові: r2 = (a >>> shift) + (b >>> shift)

    нові: перенести
    перезапустити:                                        /* кодова мітка (перехід до цілі) */ ** код мітки (перехід до цілі)

    \* додаємо перенесення нового молодшого слова до старшого слова, а потім
    * вилучити його з молодшого слова */

    carry = (r1 >>> shift)
    r2 += carry
    r1 &= mask

    \* додати перенос з нового старшого слова назад до молодшого
    *, а потім вилучити його з старшого слова */

    carry = (r2 >>> shift)
    r1 += carry
    r2 &= mask

    \* перенесення з старшого слова назад у молодший розряд
    * може призвести до переповнення нового молодшого слова, тому у цьому випадку перезапустіть програму */

    if (carry)
        goto перезапуск
    return (r2 << shift) | r1
}

stock ones: operator-(ones: a)
    return (a == ones: 0xffffffffff) ? a : ~a

stock ones: operator-(ones: a, ones: b)
    повернути a + -b

```

У прикладі помітним рядком є рядок "chksum = chksum + value" у
у циклі функції main. Оскільки обидві змінні chksum і value мають
тегами, оператор "+" посилається на визначений користувачем оператор
(замість стандартного оператора "+"). Користувацькі оператори є лише нотацією
зручність. Той самий ефект досягається при явному виклику функцій.

Означення оператора подібне до означення функції, з тією лише різницею, що
тією різницею, що назва оператора складається з ключового слова "opera-" і символу самого оператора.
tor" і символу самого оператора. У наведеному вище прикладі як унарний "-", так і бінарний
унарний "-" і бінарний "-" оператори перевизначено. Операторна функція
для бінарного оператора повинна мати два аргументи, для унарного
повинна мати один аргумент. Зауважте, що бінарний оператор "-" додає два значення
значення після інвертування знаку другого операнда. Віднімання

Таким чином, оператор відноситься як до визначеного користувачем "заперечення" (унарний "-"), так і до операторів додавання.

Перевизначений оператор повинен дотримуватися наступних обмежень:

- Визначений користувачем оператор має бути оголошений перед використанням (на відміну від "звичайних" функцій): або розмістіть реалізацію визначеного користувачем оператора над функціями, які його використовують, або додайте пряме оголошення у верхній частині файлу.

- Тільки наступні оператори можуть бути перевизначені: +, -, \*, /, %, ++, --, ==, !=, <, > , <=, >=, ! і =. Тобто, набори арифметичних і реляційних операторів можна перевантажувати, але порозрядні і логічні оператори - ні. Оператори = та ! є особливим випадком.

- Ви не можете вигадувати нові оператори; ви не можете визначити оператор "#", наприклад.

- Рівень пріоритету та асоціативність операторів, а також їхня "арність" залишаються визначеними. Наприклад, ви не можете створити унарний оператор "+".

- Тег повернення реляційних операторів та оператора "!" має бути "bool:".

- Тег повернення арифметичних операторів ви можете вибрати самостійно, але ви не можете перевизначити оператор, який є ідентичним іншому оператору, за винятком його тегу повернення. Наприклад, ви не можете створити як `alpha: operator+(alpha: a, alpha: b)`, так і `beta: operator+(alpha: a, alpha: b)` (Оператор присвоювання є винятком з цього правила).

- PAWN вже визначає оператори для роботи з комірками без тегів, ви не можете перевизначити оператори з аргументами без тегів.

- Аргументами операторної функції повинні бути не масиви, що передаються за значенням. Не можна змусити оператор працювати над масивами.

У наведеному вище прикладі обидва аргументи бінарних операторів мають однаковий тег
однакову мітку. Це не є обов'язковим; ви можете, наприклад, визначити
бінарний оператор "+", який додає ціле значення до числа типу "одиниці:".

По суті, робота синтаксичного аналізатора пішаків полягає у пошуку тегу(ів)
операндів, з якими працює оператор, і перевірити, чи існує визначений користувачем оператор
оператор для комбінації оператора і тегу(ів). Однак
синтаксичний аналізатор розпізнає особливі ситуації і надає наступні можливості:

Синтаксичний аналізатор розпізнає оператори типу "+=" як послідовність "+" і
"=" і викликає визначений користувачем оператор "+", якщо він доступний, та/або визначений користувачем оператор
оператор "=". У прикладі програми рядок "chksum = chksum + value"
можна було б скоротити до "chksum += value".

Синтаксичний аналізатор розпізнає комутативні оператори ("+", "\*", "==" та "!=")
і поміняє місцями операнди комутативних операторів, якщо це призведе до
відповідність з оператором, визначеним користувачем. Наприклад, зазвичай немає необхідності застосовувати обидва оператори

`ones:operator+(ones:a, b)`

і

`ones:operator+(a, ones:b)`

(реалізація обох функцій є допустимою і корисною у випадку, якщо визначений користувачем оператор
не повинен бути комутативним).

- Префіксні та постфіксні оператори обробляються автоматично. Вам потрібно визначити лише один користувацький оператор для операторів "++" і "--" для тегу.

- Синтаксичний аналізатор викликає оператор "!" неявно у випадку тесту без явного порівняння. Наприклад, в операторі "if (var) ...", коли var має тег "ones:", для var буде викликано визначений користувачем оператор "!". Таким чином, оператор "!" подвоюється як оператор "перевірки на нуль". (У доповняльній арифметиці як "всі одиниці", так і "всі нулі" представляють нуль).

- Користувацький оператор присвоювання неявно викликається для аргументу функції, який передається "за значенням", коли імена тегів формального і фактичного аргументів збігаються з іменами тегів лівої і правої частин оператора. Іншими словами, синтаксичний аналізатор пішаків імітує, що "передача за значенням" відбувається через присвоювання. Визначений користувачем оператор не викликається для аргументів функції, які передаються "за посиланням".

- Якщо ви хочете заборонити операцію, ви можете "передати оголошення" оператора, не визначаючи його (див. сторінку 82). Це призведе до виникнення помилки під час виклику визначеного користувачем оператора. Наприклад, щоб заборонити оператор "%" (залишок після ділення) над значеннями з плаваючою комою, ви можете додати рядок: `forward Float: operator%(Float: a, Float: b)`.

Оператори, визначені користувачем, можуть бути оголошені "стандартними" або "власними". У випадку власної операторної функції, визначення повинно містити зовнішнє ім'я. Наприклад (коли на стороні хоста власна функція називається float_add):

Лістинг: нативний оператор+функція

```c

native Float: operator+(Float: val, Float: val) = float_add

```

Оператор присвоювання, визначений користувачем, є особливим випадком, оскільки це оператор
який має побічний ефект. Хоча оператор має вигляд бінарного оператора
його "результатом виразу" є значення у правій частині - оператор присвоювання
був би "нульовим" оператором, якби не його побічний ефект. У програмі pawn
користувацький оператор присвоювання оголошується як:

Лістинг: operator= function

```c

ones: operator=(a)

повернути одиниці: ( (a >= 0) ? a : ~(-a) )

```

Визначений користувачем оператор "=" виглядає як унарний оператор у цьому визначенні
але він є окремим випадком. На відміну від інших операторів
операторів, тег значення, що повертається, для визначеного користувачем оператора є важливим: парсер pawn
використовує теги аргументу і значення, що повертається, щоб знайти відповідний користувацький оператор.

Наведений вище приклад функції є типовим застосуванням визначеного користувачем оператора присвоювання
для автоматичного примусового приведення/перетворення неміченого значення у мічене значення
значення, а також за бажанням змінити представлення значення у пам'яті під час
у процесі роботи. Зокрема, інструкція "new ones:A = -5" викликає виконання визначеного користувачем оператора
і для константи -5 оператор поверне "~(- -5)", або ~5, або -6.∗

---

Мітки: 68`

`Передоплата за декларацію: 82

"Виклик за значенням" проти "виклику за посиланням": 71`

Власні функції: 85`

`Раціональні літерали: 98`.

`#pragma rational: 121``.

---

### - Арифметика з плаваючою та фіксованою комою

pawn має лише внутрішню підтримку цілочисельної арифметики (домен -domain: "цілі
числа", як додатні, так і від'ємні). Підтримка арифметики з плаваючою комою
або арифметики з фіксованою комою має бути реалізована за допомогою (власних) функцій.
Тоді користувацькі оператори дозволять більш природно записувати вирази з числами з фіксованою або плаваючою комою.

Парсер пішаків має підтримку буквених значень з дробовою частиною, які він
називає "раціональними числами". Підтримка раціональних літералів повинна бути включена явно
явно за допомогою #pragma. Прагма # вказує на спосіб зберігання раціональних чисел
зберігати раціональні числа - з плаваючою або фіксованою комою. Для раціональних значень з фіксованою комою
#pragma також вказує точність у десяткових знаках. Два приклади для #pragma

```c

#pragma rational Float /* формат з плаваючою комою */
#pragma rational Fixed(3) /* фіксована кома, з 3 знаками після коми */

```

---

###### ∗ Сучасні процесори використовують цілочисельну арифметику з двома доповненнями. Для додатних значень побітове представлення значення однакове як в одному, так і в двох доповненнях, але для від'ємних значень представлення відрізняються. Наприклад, той самий набір бітів, що означає -5 у першому доповненні, означає -6 у другому доповненні.

---

Оскільки значення з фіксованою крапкою все одно має поміститися в комірці, кількість знаків після коми
безпосередньо впливає на діапазон значення з фіксованою комою. Для значення з фіксованою точкою
з 3 десятковими знаками діапазон буде -2, 147, 482 ... + 2, 147, 482.

Формат раціонального числа може бути задано лише один раз для всієї
пішакової програми. У реалізації зазвичай вибирають або
підтримку плаваючої або фіксованої точки. Як зазначалося вище, для фактичної реалізації арифметики з плаваючою або фіксованою ко
арифметики з плаваючою або фіксованою комою, pawn потребує
допомоги (власних) функцій та визначених користувачем операторів. Хорошим місцем для розміщення
#pragma для підтримки раціональних чисел буде у файлі include, який
також визначає функції та оператори.

Файл include † для арифметики з фіксованою комою містить визначення на кшталт:

```c

native Fixed: operator\*(Fixed: val1, Fixed: val2) = fmul
native Fixed: operator/(Fixed: val1, Fixed: val2) = fdiv

```

Користувацькі оператори множення та ділення двох чисел з фіксованою комою
чисел з фіксованою комою є псевдонімами безпосередньо до власних функцій fmul та fdiv. Отже, хост-програма
програма повинна надавати ці власні функції.

Інший власний користувацький оператор зручний для автоматичного перетворення цілого числа до
фіксовану крапку автоматично, якщо вона присвоєна змінній, позначеній як "Fixed:":

```c

native Виправлено: operator=(oper) = fixed

```

З таким визначенням ви можете написати "new Fixed: fract = 3" і значення
буде перетворено на 3.000, коли його буде збережено у змінній fract. Як пояснюється
у розділі про визначені користувачем оператори, оператор присвоювання також виконується для
аргументів функції, які передаються за значенням. У виразі "new Fixed:
root = sqroot(16)" (див. реалізацію функції sqroot на сторінці 79),
для аргументу 16 викликається користувацький оператор присвоювання.

Для додавання двох значень з фіксованою комою достатньо стандартного оператора "+".
і те саме стосується віднімання. Додавання звичайного (цілого) числа
до числа з фіксованою комою відбувається інакше: звичайне значення потрібно масштабувати перед
додаванням нормальне значення потрібно масштабувати. Отже, у файлі include реалізовано оператори і для цієї мети:

###### † Див. примітку до програми "Бібліотека підтримки фіксованих точок", щоб дізнатися, де отримати файл include.

Лістинг: адитивні оператори, комутативні та некомутативні

```c

stock Fixed: operator+(Fixed: val1, val2)
    return val1 + fixed(val2)

stock Fixed: operator-(Fixed: val1, val2)
    return val1 - fixed(val2)

stock Fixed: operator-(val1, Fixed: val2)
    return fixed(val1) - val2

```

Оператор "+" є комутативним, тому одна реалізація обробляє обидва випадки.
Для оператора "-" обидва випадки мають бути реалізовані окремо.

Нарешті, у файлі include заборонено використання оператора модуля ("%") для значень з фіксованою
з фіксованою комою: модуль можна застосовувати лише до цілих чисел:

Лістинг: заборонені оператори над значеннями з фіксованою комою

```c

forward Fixed: operator%(Fixed: val1, Fixed: val2)
forward Fixed: operator%(Fixed: val1, val2)
forward Fixed: operator%(val1, Fixed: val2)

```

Через наявність (переднього) оголошення оператора, пішак
намагатиметься використати визначений користувачем оператор, а не оператор за замовчуванням
"%". Якщо оператор не буде застосовано, синтаксичний аналізатор видасть повідомлення про помилку.
`Означені користувачем оператори: 86`

---
### - Виклик за значенням та виклик за посиланням
У Pawn аргументи функції можна передавати двома способами: за значенням та за посиланням.
#### Виклик за значенням
У цьому способі у функцію передається значення змінної. Створюється копія змінної, і функція працює з копією, а не з оригінальною змінною. Будь-які зміни, внесені до змінної всередині функції, не впливають на оригінальну змінну.

```c
swap(a, b){
	new c = a;
	a = b
	b = c;
}

main(){
	new x = 10, y = 20;
	printf("Значення x дорівнює %d, а значення y дорівнює %d, до виклику 'swap'.", x, y);
	swap(x, y);
	printf("Значення x дорівнює %d і значення y дорівнює %d, після виклику swap.", x, y);
}
```
Вивести
```
Значення x дорівнює 10, а значення y дорівнює 20, до виклику функції swap.
Значення x дорівнює 10, а значення y дорівнює 20, після виклику функції swap.
```

#### Виклик за посиланням
У цьому методі у функцію передається адреса змінної. Функція оперує з вихідною змінною, і будь-які зміни, внесені до змінної всередині функції, відображаються у вихідній змінній.
```c
swap(&a, &b){
	new c = a
	a = b
	b = c;
}

main(){
	new x = 10, y = 20;
	printf("Значення x дорівнює %d, а значення y дорівнює %d, до виклику 'swap'.", x, y);
	swap(x, y);
	printf("Значення x дорівнює %d і значення y дорівнює %d, після виклику swap.", x, y);
}
```
Вивести
```
Значення x дорівнює 10, а значення y дорівнює 20, до виклику swap.
Значення x дорівнює 20, а значення y дорівнює 10, після виклику функції swap.
```

### - Рекурсія / Рекурсія функцій
Рекурсія в програмуванні означає процес виклику функції самої себе для вирішення проблеми. Це фундаментальна концепція, яка використовується для вирішення проблем, які можна розбити на менші екземпляри однієї і тієї ж проблеми. Рекурсія складається з двох основних компонентів: базових випадків і рекурсивних випадків.
##### Базовий випадок:
Кожна рекурсивна функція повинна мати один або декілька базових випадків. Базовий випадок - це умова, за якої функція перестає викликати сама себе і повертає результат безпосередньо. Без базових випадків рекурсія буде продовжуватися нескінченно, що призведе до переповнення стеку. Щоб дізнатися більше про це, прочитайте розділ Стек/Веревина.
##### Рекурсивний випадок:
Рекурсивний випадок - це коли функція викликає сама себе для розв'язання меншого екземпляру задачі. Кожен рекурсивний виклик повинен наближати задачу до базового варіанту.
#### Приклад
```c
stock factorial(n) {
    // Базовий випадок: факторіал від 0 дорівнює 1
    if (n == 0) { // Базовий випадок: факторіал від 0 дорівнює 1.
        return 1;
    }
    // Рекурсивний випадок: n! = n * (n - 1)!
    else {
        return n * factorial(n - 1);
    }
}
main() {
    new num = 3;
    new result = factorial(num);
    printf("Факторіал від %d дорівнює %d", num, result); // Вивести: Факторіал від 3 дорівнює 6
}
```
#### Продемонструвати виведення
```
main() \\ головна функція, з якої починається виконання програми
new num = 3; \\ створюється змінна num
new result = factorial(num); \\ створюємо змінну result та викликаємо функцію factorial() з передачею значення num, factorial(5)
factorial(3) \\ ініціюємо факторіал
   if(3 == 0) \\ перевіряємо умову, яка є хибною
   else{ 3 * factorial(3-1) } \\ 3 * і викликає факторіал(2)
      factorial(2) \\ знову ініціюємо факторіал
         if(2 == 0) \\ перевіряє умову, яка є хибною
         else{ 2 * factorial(2-1) } \\ 3 * 2 * і викликає factorial(1)
            factorial(1) \\ знову ініціюємо факторіал
            if(1 == 0) \\ перевіряє умову, яка є хибною
            else{ 1 * factorial(1-1) } \\ 3 * 2 * 1 і викликає factorial(0)
 	       factorial(0) \\ знову ініціює факторіал
               if(0 == 0) return 1 \\ перевіряє умову, яка є істинною і повертає 1
		\\ при останньому виклику 3 * 2 * 1 * 1
```
### Стекова пам'ять
Стек - це область пам'яті, яка використовується для зберігання локальних змінних, інформації про виклики функцій та даних потоку керування. Він працює за принципом LIFO (Last-In-First-Out), що означає, що останній елемент, який потрапив до стеку, буде першим з нього витягнутий.
#### Приклад (переповнення стеку)
```c
#pragma dynamic 35 // (35 * 4 байти, розмір комірки) #pragma dynamic [cells] допомагає змінювати розмір стеку, читайте docs/scripting/language/Directives, щоб дізнатися більше про #pragma
main(){
	grow_stack(1);
}
grow_stacK(n){ // рекурсивна функція
	printf("N: %d", n);
	grow_stacK(n+1);
}
```
#### Виведення
```
N: 1
N: 2
N: 3
.. .
Зіткнення стеку і купи (недостатній розмір стеку)
```
![Стек](https://i.imgur.com/ZaIVUkJ.png)

[Повернутися до змісту](00-Contents.md)


