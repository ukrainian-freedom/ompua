# ДОДАТКИ

---

## Повідомлення про помилки та попередження

---

Коли компілятор знаходить помилку у файлі, він виводить повідомлення у такому порядку:

- ім'я файлу

- номер рядка, в якому компілятор виявив помилку між круглими дужками, безпосередньо за назвою файлу

- клас помилки ("помилка", "фатальна помилка" або "попередження")

- номер помилки

- описове повідомлення про помилку

Наприклад:

    demo.p(3) : error 001: expected token: ";", but found "{"

Зауваження: номер рядка, вказаний компілятором, може вказувати на позицію за фактичною помилкою
фактичної помилки, оскільки компілятор не завжди може виявити помилку, не проаналізувавши
проаналізувавши весь вираз.

Після завершення роботи компілятор повертає код:

    0 помилок немає - але можуть бути попередження
    1 знайдено помилок
    2 зарезервовано
    3 перервано користувачем

Ці коди повернення можна перевірити за допомогою пакетних процесорів (наприклад, утиліти make).

### - Категорії помилок

Помилки поділяються на три класи:

| Тип | Опис |
| ------------ | ------------------------------------------------------------------------------------------------------------------------------------------- |
| Помилки | Описують ситуації, коли компілятор не може згенерувати відповідний код. Повідомлення про помилки нумеруються від 1 до 99.                   |
| Фатальні помилки | Фатальні помилки описують помилки, після яких компілятор не може відновитися. Синтаксичний аналіз переривається. Повідомлення про фатальні помилки нумеруються від 100 до 199. |
| Попередження | Попередження відображаються для непередбачуваних припущень компілятора та поширених помилок. Попередження пронумеровано від 200 до 299.              |

### - Помилки

| Номер |Опис |Опис
| ------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 001 | **очікуваний токен:** _token_, **але знайдено** _token_
| Пропущено необхідний токен.                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| 002 | **Тільки один оператор (або вираз) може слідувати за кожним "case "**.
| Кожний case в операторі switch може містити лише один вираз. Щоб помістити кілька операторів у регістр, візьміть ці оператори у фігурні дужки (це створить складений оператор).                                                                                                                                                                                                                                                                              |
| Оголошення локальної змінної повинно міститися у складеному блоці**| | Оголошення локальної змінної повинно міститися у складеному блоці.
| Оголошення локальної змінної має міститися між фігурними дужками ("{. . . }") на рівні активної області видимості.                                                                                                                                                                                                                                                                                                                                                            |
| Коли синтаксичний аналізатор відзначає цю помилку, оголошення змінної з'являється як єдиний оператор функції або єдиний оператор, що стоїть нижче операторів if, else, for, while або do. Зауважте, що оскільки локальні змінні доступні лише з області видимості (або нижче), в якій з'являється їх оголошення, використання оголошення змінної як єдиного оператора в будь-якій області видимості не має сенсу.                                                                                          |
| 004 | **функція** _ім'я_ **не реалізована**
| Не існує реалізації для вказаної функції. Можливо, функцію було оголошено "заздалегідь" - або створено прототип - але повне визначення функції, включно з оператором або блоком операторів, відсутнє.                                                                                                                                                                                                                                                   |
| Функція може не мати аргументів*******************************************************************.
| Функція main() є точкою входу у програму. Вона може не мати аргументів.                                                                                                                                                                                                                                                                                                                                                                                        |
006 | **має бути присвоєний масиву** | | _Додаткове значення повинно бути присвоєне масиву_*| _Додаткове значення повинно бути присвоєне рядку
| Рядкові літерали або масиви слід присвоювати масиву. Це повідомлення про помилку може також вказувати на відсутність індексу (або індексів) у масиві праворуч від знака "=".                                                                                                                                                                                                                                                                                         |
| 007 | **оператор не може бути перевизначений** | _Оператор не може бути перевизначений__ _Оператор не може бути перевизначений_*
| | | Тільки вибраний набір операторів можна перевизначити, цей оператор не належить до них. Докладні відомості наведено на сторінці 86.                                                                                                                                                                                                                                                                                                                                                       |
008 | **повинен бути константним виразом; за замовчуванням дорівнює нулю** | | | Розмір масивів не може бути визначений.
| Розмір масивів і параметри більшості директив мають бути сталими значеннями.                                                                                                                                                                                                                                                                                                                                                                                 |
009 | **недопустимий розмір масиву (від'ємний або нульовий)** | | | Кількість елементів масиву
| Кількість елементів масиву завжди має бути 1 або більше.                                                                                                                                                                                                                                                                                                                                                                                                      |
| 010 | **незаконна функція або оголошення**
| Компілятор очікує оголошення глобальної змінної або функції у поточному місці, але не може інтерпретувати його як таке.                                                                                                                                                                                                                                                                                                                             |
011 | **Недійсні зовнішні функції** | | ¦ ¦ ¦ ¦
| Інструкція або оператор є недійсними на глобальному рівні. Локальні мітки та (складені) оператори є дійсними, тільки якщо вони використовуються всередині функцій.                                                                                                                                                                                                                                                                                                                        |
012 | **Недійсний виклик функції, невірна адреса** | | | Символ не є функцією.
| Символ не є функцією.                                                                                                                                                                                                                                                                                                                                                                                                                                     |
013 | **відсутня точка входу (немає загальнодоступних функцій)** | | ¦.
| Файл не містить головної функції або будь-якої загальнодоступної функції. Отже, скомпільований файл не має точки входу для виконання.                                                                                                                                                                                                                                                                                                                     |
014 | **Недійсний оператор; не у switch** | | ¦ ¦ ¦ ¦ ¦ ¦
| Оператори case та default є дійсними лише всередині оператора switch.                                                                                                                                                                                                                                                                                                                                                                                         |
| 015 | **"за замовчуванням" має бути останнім оператором в операторі switch** | ¦ ¦ ¦
| Пішак вимагає, щоб оператор default був останнім в операторі switch.                                                                                                                                                                                                                                                                                                                                                                                     |
| 016 | **кілька значень за замовчуванням в операторі switch**
| Кожен оператор switch може мати тільки один параметр за замовчуванням.                                                                                                                                                                                                                                                                                                                                                                                                           |
| 017 ¦Невизначений символ** _символ_ _символ_ ¦ ¦ ¦ ¦
| Символ (змінна, константа або функція) не оголошено.                                                                                                                                                                                                                                                                                                                                                                                                      |
| 018 | **Дані ініціалізації перевищують оголошений розмір**
| Ініціалізація: 65 Ініціалізовано масив з явним розміром, але кількість ініціалізаторів перевищує кількість вказаних елементів. Наприклад, у "arr[3]={1,2,3,4};" вказано, що масив має три елементи, але ініціалізаторів чотири.                                                                                                                                                                                                      |
| 019 | **не мітка:** _ім'я_|.
| Оператор goto розгалужується на символ, який не є міткою.                                                                                                                                                                                                                                                                                                                                                                                                        |
| 020 | **неправильна назва символу**
| | | Символ може починатися з літери, символу підкреслення або знака "at" ("@") і може супроводжуватися послідовністю літер, цифр, символів підкреслення та "@".                                                                                                                                                                                                                                                                                               |
021 | **символ вже визначено:** _ідентифікатор_ | | | символ вже визначено
| Символ вже визначено на поточному рівні.                                                                                                                                                                                                                                                                                                                                                                                                              |
| 022 | **повинно бути значенням l (не константа)** | ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦
| Символ, який змінюється (інкрементується, декрементується, присвоюється значення тощо), має бути змінною, яку можна модифікувати (такий тип змінної називається l-значенням). Функції, рядкові літерали, масиви та константи не є l-значеннями. Змінні, оголошені з атрибутом const, також не є l-значеннями.                                                                                                                                                          |
Присвоєння масиву повинно бути простим присвоєнням**| 023 | **присвоєння масиву повинно бути простим присвоєнням** | _Присвоєння масиву
| При присвоюванні одного масиву іншому не можна поєднувати арифметичну операцію з присвоюванням (наприклад, не можна використовувати оператор "+=").                                                                                                                                                                                                                                                                                                                     |
| 024 | **"break" або "continue" вирвані з контексту**
| Оператори break та continue діють лише у контексті циклу (інструкції do, for або while). На відміну від мов C/C⁺⁺ та Java, break не вистрибує з оператора switch.                                                                                                                                                                                                                                                                 |
| 025 | **заголовок функції відрізняється від прототипу**
| Кількість аргументів у попередньому оголошенні функції не збігається з кількістю аргументів у поточному оголошенні.                                                                                                                                                                                                                                                                                                                  |
| 026 | **Не співпадає "#if... "** | ¦ ¦Директива #else не співпадає з директивою #if....
| Зустрілася директива #else або #endif, але не знайдено відповідної директиви #if.                                                                                                                                                                                                                                                                                                                                                                           |
| 027 | **Неприпустима символьна константа**
| | | Однією з імовірних причин цієї помилки є поява невідомої екранованої послідовності, наприклад, "\x". Вставлення декількох символів між одинарними лапками, як у випадку з "abc", також призводить до цієї помилки. Третьою причиною цієї помилки є ситуація, коли очікується введення символьної константи, але її не було надано (або було надано несимвольний вираз).                                                                                                                           |
| 028 | **Недійсний підрядковий оператор (не масив або занадто багато підрядкових операторів):** _ідентифікатор_|.
| | | Оператори підстановки "[" і "]" допустимі лише для масивів. Кількість пар квадратних дужок не може перевищувати кількість вимірів масиву.                                                                                                                                                                                                                                                                                                          |
| 029 | **Неправильний вираз, прийнятий за нуль**
| Компілятор не зміг інтерпретувати вираз.                                                                                                                                                                                                                                                                                                                                                                                                                  |
| 030 Складений оператор не закривається в кінці файлу.
| Стався несподіваний кінець файлу. Один або декілька складених операторів не завершено (наприклад, не знайдено закриваючу дужку " ").                                                                                                                                                                                                                                                                                                                         |
| 031 | **невідома директива**
| | Символ "#" з'являється першим у рядку, але не було вказано жодної дійсної директиви.                                                                                                                                                                                                                                                                                                                                                                                  |
032 | **індекс масиву виходить за межі** | | | Індекс масиву виходить за межі
| Індекс масиву більший за найвищий допустимий елемент масиву.                                                                                                                                                                                                                                                                                                                                                                                              |
| 033 | **масив має бути проіндексовано** (**змінна** _ім'я_)
| Масив як єдине ціле не можна використовувати у виразі; ви повинні вказати елемент масиву у квадратних дужках.                                                                                                                                                                                                                                                                                                                                            |
| 034 | **аргумент не має значення за замовчуванням** (**аргумент** _індекс_)
| Заповнювач аргументу можна використовувати лише тоді, коли у визначенні функції вказано значення за замовчуванням для аргументу.                                                                                                                                                                                                                                                                                                                                                |
035 | **невідповідність типу аргументу** (**аргумент** _індекс_) | | ¦ ¦ (**аргумент** _індекс_) | ¦ ¦ (**аргумент** _індекс_)
| Аргумент, який ви передаєте, відрізняється від аргументу, який очікує функція, і компілятор не може перетворити переданий аргумент до потрібного типу. Наприклад, ви не можете передати як аргумент буквальне значення "1", якщо функція очікує масив або посилання.                                                                                                                                                                            |
| 036 | **порожній оператор**
| Рядок містить крапку з комою, якій не передує вираз. pawn не підтримує крапку з комою як порожній оператор, використовуйте замість неї порожній складений блок.                                                                                                                                                                                                                                                                                                |
| 037 | **неправильний рядок (можливо, нетермінований рядок)** | ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦
| Рядок було неправильно сформовано; наприклад, відсутня остання лапка, якою закінчується рядок, або ім'я файлу для директиви #include не було взято у подвійні лапки або кутові дужки.                                                                                                                                                                                                                                                                         |
038 | | **Додаткові символи у рядку** | ¦ ¦ ¦ ¦ ¦ ¦ ¦
| У рядку, який містить директиву, є додаткові символи (директива починається з символу #, див. сторінку 117).                                                                                                                                                                                                                                                                                                                                           |
039 | **константний символ не має розміру** | | | Змінна не має розміру
| Змінна має розмір (вимірюється в кількості клітинок), константа не має розміру. Тобто ви не можете використовувати (символьну) константу з оператором sizeof, наприклад.
| 040 | **дублююча мітка case** (**значення** _значення_)
| Попередня "case-мітка" у списку оператора switch обчислюється до того самого значення.                                                                                                                                                                                                                                                                                                                                                                         |
| 041 | **Неприпустиме багатокрапка, розмір масиву невідомий** | ¦ ¦.
| Ви використали синтаксис на кшталт "arr[] = { 1, ... };", що є неправильним, оскільки компілятор не може визначити розмір масиву з оголошення.                                                                                                                                                                                                                                                                                                                    |
| 042 | **Неприпустима комбінація специфікаторів класу** | ¦ ¦ ¦ ¦
| Функція або змінна позначається одночасно як "public" і "native", що не підтримується. Інші комбінації також можуть бути непідтримуваними; наприклад, функція не може бути одночасно "public" і "stock" (змінна може бути оголошена як "public" і "stock").                                                                                                                                                                                                            |
| 043 | **Символьна константа виходить за межі діапазону для упакованого рядка** | ¦ ¦.
| Зазвичай спроба зберегти символ Unicode у запакованому рядку, де запакований символ має довжину 8 біт.                                                                                                                                                                                                                                                                                                                                                            |
| змішування іменованих та позиційних параметрів
| Ви повинні використовувати або іменовані параметри, або позиційні параметри для всіх параметрів функції.                                                                                                                                                                                                                                                                                                                                                                 |
| 045 | |Занадто багато аргументів функції
| Максимальна кількість аргументів функції наразі обмежена до 64.                                                                                                                                                                                                                                                                                                                                                                                              |
| 046 | **Невідомий розмір масиву** (**змінна** _ім'я_)
| Для присвоювання масивів розмір обох масивів має бути визначено явно, навіть якщо вони передаються як аргументи функції.                                                                                                                                                                                                                                                                                                                                          |
047 | **Розміри масивів не збігаються, або масив-приймач є замалим** | | ¦.
| Для присвоювання масивів, масиви у лівій та правій частині оператора присвоювання повинні мати однакову кількість вимірів. Крім того:                                                                                                                                                                                                                                                                                                                  |
| | | - для багатовимірних масивів обидва масиви повинні мати однаковий розмір; | | | - для одиночних масивів
| для одиночних масивів з одним виміром масив у лівій частині оператора присвоювання повинен мати розмір, що дорівнює або більший за розмір масиву у правій частині.                                                                                                                                                                                                                                                                                       |
| При передачі масивів в якості аргументу функції ці правила також діють для масиву, що передається у функцію (у виклику функції), а не для масиву, оголошеного в описі функції.                                                                                                                                                                                                                                                                       |
| Коли функція повертає масив, у всіх операторах повернення має бути вказано масив з однаковим розміром і розмірністю.                                                                                                                                                                                                                                                                                                                                                  |
| 048 | **розміри масивів не збігаються**
| Для присвоювання масиву розміри масивів по обидва боки від знаку "=" повинні співпадати; при передачі масивів в якості аргументу функції, масиви, що передаються у функцію (у виклику функції), повинні співпадати з визначенням аргументів функції.                                                                                                                                                                                                    |
| Якщо функція повертає масив, то у всіх операторах повернення повинен бути вказаний масив з однаковим розміром та розмірністю.                                                                                                                                                                                                                                                                                                                                                  |
| 049 | **Неприпустиме продовження рядка**
| Символ продовження рядка (зворотна коса риска в кінці рядка) знаходиться у неприпустимій позиції, наприклад, у кінці файлу або в однорядковому коментарі.                                                                                                                                                                                                                                                                                                         |
| 050 | **недопустимий діапазон**
| Числовий діапазон із синтаксисом "n1 .. n2", де n1 і n2 є числовими константами, є неприпустимим. Або одне із значень не є дійсним числом, або n1 не менше за n2.                                                                                                                                                                                                                                                                                      |
| 051 | **неправильний підрядковий індекс, використовуйте оператори "[ ]" на великих розмірностях** | | ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦
| | | Можна використовувати оператор "індекс символу масиву" (дужки: "{ }" тільки для останнього виміру. Для інших розмірностей слід використовувати оператор індексу комірки (квадратні дужки: "[ ]").
| Багатовимірні масиви мають бути повністю ініціалізовані_**_.
| Якщо масив з більш ніж одним виміром ініціалізується при його оголошенні, то праворуч від знаку рівності ("=") повинно бути стільки ж літеральних векторів/підмасивів, скільки вказано для головного(их) виміру(ів) масиву.                                                                                                                                                                                                                                  |
| 053 | **перевищення максимальної кількості вимірів**
| Поточна реалізація пішакового компілятора підтримує масиви лише з одним або двома вимірами.                                                                                                                                                                                                                                                                                                                                                                  |
054 | **Невідповідна закриваюча дужка** | | _Невідповідна закриваюча дужка__
| Знайдено закриваючу дужку ("}") без відповідної відкриваючої дужки ("{").                                                                                                                                                                                                                                                                                                                                                                                             |
| Початок тіла функції без заголовка функції.
| Знайдено відкриваючу дужку ("{") за межами області видимості функції. Це може бути спричинено крапкою з комою в кінці заголовка попередньої функції.                                                                                                                                                                                                                                                                                                                    |
056 | **Локальні змінні та аргументи функції не можуть бути загальнодоступними** | |.
| Локальна змінна або аргумент функції починається з символу "@", який є неприпустимим.                                                                                                                                                                                                                                                                                                                                                                          |
| 057 | **Незакінчений вираз перед директивою компілятора**
| Директиви компілятора можуть зустрічатися тільки між операторами, але не всередині оператора. Ця помилка зазвичай виникає, коли вираз розбивається на декілька рядків і між початком і кінцем виразу з'являється директива компілятора. Це не підтримується.                                                                                                                                                                                     |
| 058 | **Дублікат аргументу; той самий аргумент передається двічі** | ¦ ¦.
| У виклику функції той самий аргумент з'являється двічі, можливо, через поєднання іменованих і позиційних параметрів.                                                                                                                                                                                                                                                                                                                                             |
| 059 | **Аргумент функції може не мати значення за замовчуванням** (**змінна** _ім'я_)
| Всі аргументи загальнодоступних функцій повинні передаватися явно. Загальнодоступні функції зазвичай викликаються з головної програми, яка не знає значень параметрів за замовчуванням. Аргументи визначених користувачем операторів маються на увазі з виразу і не можуть бути виведені зі значення аргументу за замовчуванням.
| 060 | **кілька директив "#else" між "#if . . . #endif** |
| Дві або більше директив #else з'являються у тілі між відповідними #if та #endif.                                                                                                                                                                                                                                                                                                                                                                              |
| 061 | **Директива #elseif слідує за директивою #else**
| Усі директиви #elseif мають стояти перед директивою #else. Ця помилка також може вказувати на те, що відсутня директива #endif для вищого рівня.                                                                                                                                                                                                                                                                                                               |
| 062 | **кількість операндів не вміщується в оператор** | ¦ ¦.
| При перевизначенні оператора кількість операндів, які має оператор (1 для унарних операторів і 2 для бінарних), має дорівнювати кількості аргументів операторної функції.                                                                                                                                                                                                                                                                   |
| 063 | **оператор вимагає, щоб результат функції мав тег "bool "** | | _Оператор вимагає, щоб результат функції мав тег "bool".
| Логічні та реляційні оператори визначаються як такі, що мають результат, який є або істинним (1), або хибним (0) і має тег "bool". Оператор, визначений користувачем, повинен відповідати цьому визначенню.                                                                                                                                                                                                                                                                           |
064 | **не можна змінювати попередньо визначені оператори** | **не можна змінювати попередньо визначені оператори** | | не можна змінювати попередньо визначені оператори_*
| Наприклад, не можна визначати оператори для роботи над значеннями без тегів, оскільки pawn вже визначає цю операцію.                                                                                                                                                                                                                                                                                                                                                 |
| 065 | **Аргумент функції може мати лише одну мітку** (**аргумент** _число_)
| У визначеному користувачем операторі аргумент функції не може мати декілька тегів.                                                                                                                                                                                                                                                                                                                                                                                       |
066 | **Аргумент функції не може бути аргументом-посиланням або масивом** (**аргумент** _число_) | | ¦ ¦Аргумент функції не може бути аргументом-посиланням або масивом** (**аргумент** _число_)
| У визначеному користувачем операторі всі аргументи мають бути комірками (не масивами), які передаються "за значенням".                                                                                                                                                                                                                                                                                                                                                                  |
Змінна не може бути одночасно посиланням і масивом**(**змінна** _ім'я_) | | | Змінна не може бути одночасно посиланням і масивом**(**змінна** _ім'я_)
| Аргумент функції може бути позначений як "посилання" або як масив, але не як і те, і інше.                                                                                                                                                                                                                                                                                                                                                                              |
068 | **Неправильна точність раціональних чисел у #pragma** | | _Введено від'ємну або від'ємну точність раціональних чисел.
| Вказано від'ємну або надто високу точність. Для раціональних чисел з плаваючою комою специфікацію точності слід опустити.                                                                                                                                                                                                                                                                                                                                       |
| 069 | **формат раціонального числа вже визначено**
| Ця #прагма конфліктує з попередньою #прагмою, яка визначила інший формат.                                                                                                                                                                                                                                                                                                                                                                                 |
| 070 | **Підтримку раціональних чисел не ввімкнено**
| Виявлено раціональне буквене число, але формат для раціональних чисел не було визначено.                                                                                                                                                                                                                                                                                                                                                                 |
071 | u**Оператор, визначений користувачем, має бути оголошений перед використанням** (**функція** _ім'я_) | | ¦ ¦ (**функція** _ім'я_)
| Як і змінну, визначений користувачем оператор має бути оголошено перед його першим використанням. Це повідомлення вказує на те, що перед оголошенням визначеного користувачем оператора стався випадок, коли цей оператор було використано з операндами з однаковими тегами. Це може свідчити або про те, що програма намагається змішано використовувати оператор за замовчуванням і визначений користувачем (що не підтримується), або про те, що визначений користувачем оператор має бути "оголошений заздалегідь". |
| 072 | **Оператор "sizeof" є неприпустимим для символів "function" ** **Оператор "sizeof" є неприпустимим для символів "function
| Ви використали щось на зразок "sizeof MyCounter", де символ "MyCounter" є не змінною, а функцією. Не можна запитувати розмір функції.                                                                                                                                                                                                                                                                                                             |
| 073 | **Аргумент функції має бути масивом** (**аргумент** _ім'я_)
| Аргумент функції є константою або простою змінною, але функція вимагає, щоб ви передали масив.                                                                                                                                                                                                                                                                                                                                                       |
074 | **#define шаблон повинен починатися з літерного символу** | | | Шаблон #define повинен починатися з літерного символу
| Будь-який шаблон для директиви #define повинен починатися з літери, символу підкреслення ("\_") або "@"-символу. Шаблон - це перше слово, яке слідує за ключовим словом #define.                                                                                                                                                                                                                                                                                         |
| 075 | **занадто довгий рядок вводу (після підстановок)** | | ¦.
| Або вихідний файл містить дуже довгий рядок, або текстові заміни призводять до того, що рядок, який спочатку мав прийнятну довжину, виходить за її межі. Це може бути спричинено текстовою заміною, яка спричиняє рекурсивну заміну (шаблон збігається з частиною тексту заміни, тож ця частина тексту заміни також збігається і замінюється, і так далі).                                                                                  |
| 076 | **синтаксична помилка у виразі або недійсний** виклик функції
| Оператор виразу не було розпізнано як допустимий оператор (тому це "синтаксична помилка"). З тієї частини рядка, яка була розібрана, виглядає так, ніби у вихідному рядку міститься виклик функції у синтаксисі "виклик процедури" (без дужок), але результат функції використовується - присвоюється змінній, передається як параметр, використовується в експресії. . .                                                                                             |
| 077 | **неправильне кодування UTF-8 або пошкоджений файл: ім'я файлу** | ¦ ¦ ¦ ¦ ¦ ¦
| Файл починається з підпису у кодуванні UTF-8, але містить кодування, які не відповідають UTF-8. Якщо вихідний файл було створено за допомогою редактора або конвертера, який підтримує кодування UTF-8, підтримка UTF-8 є невідповідною.                                                                                                                                                                                                                                                     |
Функція використовує як "return", так і "return ¡value¿"** | | Функція використовує як "return", так і "return ¡value¿"** | ¦ Функція використовує як "return", так і "return".
| Функція повертає як із значенням, що повертається, так і без нього. Функція має бути послідовною і завжди повертатися з результатом функції або ніколи не повертати результат функції.                                                                                                                                                                                                                                                                                 |
079 | **Неузгоджені типи повернення (масив та не-масив)** | | ¦ ¦(масив та не-масив)| | ¦ ¦(масив та не-масив)
| Функція повертає як значення, так і масиви, що є неприпустимим. Якщо функція повертає масив, то всі оператори повернення повинні вказувати масив (однакового розміру та розмірностей).
| 080 | **невідомий символ, або не константний символ** (**символ** _ім'я_)
| Там, де очікувалося константне значення, знайдено невідомий символ або непостійний символ (змінну).                                                                                                                                                                                                                                                                                                                                                             |
081 | **неможливо прийняти тег як значення за замовчуванням для параметра індексованого масиву** (**символ** _ім'я_) | | ¦ ¦(**символ** _ім'я_)
| Оператор tagof було застосовано до параметра масиву, який також має індекс. Це не підтримується.                                                                                                                                                                                                                                                                                                                                                         |
| 082 | **Оператори, визначені користувачем, та власні функції не можуть мати станів**
| Тільки стандартні та загальнодоступні функції можуть мати стани.                                                                                                                                                                                                                                                                                                                                                                                                               |
| 083 | Функція або змінна може належати лише одному автомату_* (**символ** _ім'я_)
| Наявність декількох автоматів у декларації стану для вказаної функції або змінної не підтримується. У випадку функції: всі екземпляри функції повинні належати до одного автомата. У випадку змінної: допускається наявність декількох змінних з однаковим іменем, що належать різним автоматам, але тільки в окремих деклараціях - це різні змінні.                                                      |
| 084 | **конфлікт станів: один зі станів вже присвоєно іншій реалізації** (**символ** _ім'я_).
| Вказаний стан з'являється у специфікаторі стану двох реалізацій тієї самої функції.                                                                                                                                                                                                                                                                                                                                                                   |
085 | **для імені символу не визначено жодного стану** | | | (**символ** _ім'я_)
| Коли ця помилка виникає у функції, ця функція має резервну реалізацію, але не має інших станів. Якщо помилка стосується змінної, ця змінна не має списку станів між символами < і >. Замість неї використовуйте функцію без станів і змінну ir.                                                                                                                                                                                           |
| 086 | **невідома назва автомата** | ¦ ¦ ¦ ¦ ¦ ¦ ¦
| Оператор "стан" посилається на невідомий автомат.                                                                                                                                                                                                                                                                                                                                                                                                             |
| 087 | **Невідома назва стану для назви автомата**
| Оператор "стан" посилається на невідомий стан (для вказаного автомата).                                                                                                                                                                                                                                                                                                                                                                                   |
| 088 | | Загальнодоступні та локальні змінні можуть не мати станів**(**символ** _ім'я_)
| Тільки стандартні (глобальні) змінні можуть мати список станів (і автомат) в кінці оголошення.                                                                                                                                                                                                                                                                                                                                                        |
089 | Змінні зі списком станів не можна ініціалізувати** (**символ** _ім'я_) | | | Змінні зі списком станів можна не ініціалізувати.
| Змінні зі списком станів можуть не мати ініціалізаторів. Змінні стану завжди слід явно ініціалізувати, оскільки їхнє початкове значення є невизначеним.                                                                                                                                                                                                                                                                                                 |
090 | | **загальнодоступні функції не можуть повертати масиви** (**символ** _ім'я_) | ¦ ¦ ¦(**символ** _ім'я_)
| | | Загальнодоступна функція не може повертати масив. Повернення масивів дозволено лише для звичайних функцій.                                                                                                                                                                                                                                                                                                                                                                 |

### - Фатальні помилки

| Номер |Опис |Опис
| ------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 100 | **неможливо прочитати з файлу:** _ім'я_ файлу
| Компілятор не може знайти вказаний файл або не має до нього доступу.                                                                                                                                                                                                                                                            |
101 | **не вдається записати до файлу:** _ім'я_файлу_ | | ¦ ¦Компілятор не може знайти вказаний файл і не має до нього доступу.
| Компілятор не може записати до вказаного вихідного файлу, ймовірно, через брак місця на диску або обмежені права доступу (наприклад, файл може бути доступним лише для читання).                                                                                                                                                            |
| 102 | **переповнення таблиці:** _ім'я_таблиці
| Внутрішня таблиця у синтаксичному аналізаторі замала для зберігання необхідних даних. Деякі таблиці є динамічно зростаючими, що означає, що для зміни розміру таблиці не вистачило пам'яті. "Ім'я таблиці" має один з наступних значень:                                                                                                      |
| | "буфер очікування": у буфері очікування зберігається код, згенерований для виразу, перш ніж його буде передано оптимізатору вічка. Буфер обробки збільшується динамічно, тому переповнення буфера обробки в основному є помилкою "нестачі пам'яті".                                                                                      |
| "таблиця циклів": таблиця циклів - це стек, який використовується з вкладеними операторами do, for та while. Таблиця дозволяє вкладати ці оператори до 24 рівнів.                                                                                                                                                                                 |
| "таблиця літералів": у цій таблиці зберігаються літеральні константи (числа, рядки), які використовуються у виразах і як ініціалізатори для масивів. Таблиця літералів росте динамічно, тому переповнення таблиці літералів в основному є помилкою "за межами пам'яті".                                                                                |
| "стек компілятора": компілятор використовує стек для зберігання тимчасової інформації, необхідної йому під час синтаксичного аналізу. Переповнення цього стеку, ймовірно, спричинене глибоко вкладеним (або рекурсивним) включенням файлів. Стек компілятора зростає динамічно, тому переповнення стека компілятора, в основному, є помилкою "нестачі пам'яті".                     |
| "Таблиця опцій": у випадку, якщо у командному рядку або у файлі-відповіді є більше опцій, ніж може обробити компілятор.                                                                                                                                                                                                      |
| Недостатньо пам'яті*******************************************************.
| Загальна помилка "не вистачає пам'яті".                                                                                                                                                                                                                                                                                                        |
104 | **Неправильний символ інструкції асемблера** | **Неправильний символ інструкції асемблера** | **Неправильний код операції.
| Неправильний операційний код у директиві #emit.                                                                                                                                                                                                                                                                                              |
| 105 Числове переповнення, переповнення пам'яті.
| Числова константа, зокрема розмірність масиву, занадто велика для компілятора. Наприклад, при компіляції 16-бітної програми компілятор не може обробляти масиви з більш ніж 32767 елементами.                                                                                                                    |
| 106 | **Скомпільований скрипт перевищує максимальний розмір пам'яті** (_кількість_ **байт**)
| Розмір пам'яті для абстрактної машини, необхідний для виконання скрипта, перевищує значення, встановлене за допомогою #pragma amxlimit. Це означає, що скрипт занадто великий для підтримки хостом. Ви можете спробувати зменшити вимоги до пам'яті скрипта за допомогою                                                                               |
| | | - встановлення меншої області стеку/купки - див. розділ #pragma dynamic на сторінці 121; | | - використання упакованих рядків
| використання запакованих рядків замість розпакованих - див. сторінки 99 і 137; | | - використання повторюваних рядків
винесення коду, що повторюється, в окремі функції; | | | - винесення коду, що повторюється, в окремі функції
винесення даних (рядків), що повторюються, у глобальні змінні; | | | - намагання знайти більш компактні способи винесення даних, що повторюються, у глобальні змінні
| намагання знайти більш компактні алгоритми для виконання тієї самої задачі.                                                                                                                                                                                                                                                                    |
| Занадто багато повідомлень про помилки/попередження в одному рядку
| Один рядок, який викликає декілька повідомлень про помилки/попереджень, часто є ознакою того, що синтаксичний аналізатор не може "оговтатися" від попередньої помилки. У такій ситуації синтаксичний аналізатор навряд чи зможе розібратися з наступним вихідним кодом, видаючи лише (ще більше) невідповідних повідомлень про помилки. Тому компіляцію буде зупинено. |
| 108 | **файл зіставлення кодових сторінок не знайдено**
| Не вдалося завантажити файл перекладу кодових сторінок, який було вказано за допомогою опції компілятора -c або директиви #pragma codepage.                                                                                                                                                                                           |
Невірний шлях:** _ім'я_ шляху_ | 109 | **неправильний шлях:** _ім'я_ шляху_ | ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦
| Невірно вказано шлях, наприклад, до файлів включення або файлів кодових сторінок.                                                                                                                                                                                                                                                                  |
| 110 | **не вдалося виконати перевірку:** _вираз_.
| Не вдалося виконати перевірку під час компіляції.                                                                                                                                                                                                                                                                                                        |
111 | | Помилка користувача:| _повідомлення_ | ¦ ¦Падіння синтаксичного аналізатора.
| Синтаксичний аналізатор потрапив на директиву #error.                                                                                                                                                                                                                                                                                               |

### Попередження

| Номер |Опис |Опис
| ------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
200 | **символ урізано до** _кількість_ **символів** | | символ урізано до**_кількість_ **символів** | | символ урізано до
| Символ довший за максимальну довжину символу. Максимальна довжина символу залежить від того, чи є символ власним, загальнодоступним або ні тим, ні іншим. Усічення може призвести до того, що різні назви символів стануть однаковими, що може спричинити помилку 021 або попередження 219.                                                                                                                                                          |
| 201 |** перевизначення константи/макросу**(**символ** _ім'я_)
| Символ раніше було визначено з іншим значенням, або макрос підстановки тексту, який починається з імені префікса, було перевизначено з іншим текстом підстановки.                                                                                                                                                                                                                                      |
202 | **Кількість аргументів не відповідає визначенню** | | | При виклику функції
| Під час виклику функції кількість переданих у функцію аргументів (фактичних аргументів) відрізняється від кількості формальних аргументів, оголошених у заголовку функції. Для оголошення функцій зі змінними списками аргументів використовуйте еліпсис (...) за останнім відомим аргументом у заголовку функції, наприклад: print(formatstring,...); (див. стор. 80).                                                      |
| 203 | **символ ніколи не використовується:** _ідентифікатор_ | | | символ визначено, але він ніколи не використовується.
| Символ визначено, але він ніколи не використовується. Загальнодоступні функції виключено з перевірки використання символів (оскільки їх можна викликати ззовні).                                                                                                                                                                                                                                                                    |
204 | | Символу присвоюється значення, яке ніколи не використовується:** _ідентифікатор_ | | | Символу присвоюється значення, яке ніколи не використовується.
| Символу присвоюється значення, але доступ до вмісту символу ніколи не здійснюється.                                                                                                                                                                                                                                                                                                                            |
| 205 | **надлишковий код: константний вираз дорівнює нулю**
| Там, де очікувався умовний вираз, знайдено константний вираз зі значенням нуль, наприклад, "while (0)" або "if (0)".                                                                                                                                                                                                                                                                                |
| Умовний код під тестом ніколи не виконується, тому він є надлишковим.                                                                                                                                                                                                                                                                                                                      |
| 206 | **Надлишковий тест: константний вираз не дорівнює нулю**
| Там, де очікується умовний вираз, знайдено константний вираз з ненульовим значенням, наприклад, якщо (1). Тест є надлишковим, оскільки умовний код завжди виконується.                                                                                                                                                                                                                       |
207 | | **невідомий "#pragma "** | ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦
| Компілятор ігнорує прагму. Директиви #pragma можуть змінюватися між компіляторами різних виробників та між різними версіями компілятора однієї версії.                                                                                                                                                                                                                                    |
208 | **Функція з тегом result використовується перед визначенням, примушуючи до виправлення** | _Функція з тегом result використовується перед визначенням, примушуючи до виправлення_*| _Функція
| Якщо функція "використовується" (викликається) до її оголошення, і ця функція повертає значення з іменем тегу, синтаксичний аналізатор повинен зробити додатковий прохід по вихідному коду, оскільки наявність імені тегу може змінити інтерпретацію операторів (за наявності операторів, визначених користувачем). Ви можете прискорити процес синтаксичного аналізу/компіляції, оголошуючи відповідні функції перед їх використанням.    |
209 | **функція повинна повертати значення** | | Функція повинна повертати значення
| Функція не має оператора повернення або не має виразу за оператором повернення, але результат функції використовується у виразі.                                                                                                                                                                                                                                               |
210 | | **можливе використання символу перед ініціалізацією:** _ідентифікатор_ | ¦ ¦ ¦ ¦
| Здається, що локальна (неініціалізована) змінна зчитується до того, як їй присвоюється значення. Компілятор не може визначити дійсний порядок читання зі змінних та запису до них і базує своє припущення про порядок виконання на фізичному порядку розташування операторів та виразів у вихідному файлі.                                                                                              |
| 211 | **можливе ненавмисне присвоювання**
| Там, де очікувався умовний вираз, було знайдено оператор присвоювання (=) замість оператора рівності (==). Оскільки це поширена помилка, компілятор видає попередження. Щоб уникнути цього повідомлення, візьміть вираз у круглі дужки, наприклад, if ( (a=2) ).                                                                                                                                       |
| 212 | **можливо, непередбачувана побітова операція** |.
| Там, де очікувався умовний вираз, замість булевого оператора (& або \|) було знайдено побітову операцію (&& або \|\|). У ситуаціях, коли побітова операція здається малоймовірною, компілятор видає це попередження. Щоб уникнути цього повідомлення, візьміть вираз у круглі дужки.                                                                                                                        |
| 213 | **невідповідність тегів** | ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦
| Невідповідність тегів виникає, коли:                                                                                                                                                                                                                                                                                                                                                                                    |
присвоєння змінній з тегом значення, яке не є тегом або має інший тег | | | - присвоєння змінній з тегом значення, яке не є тегом
| вирази по обидві сторони бінарного оператора мають різні теги
| | | - у виклику функції передача аргументу, що не має тегу або має інший тег, ніж той, з яким аргумент функції був визначений | | | - індексація масиву, що не має тегу, або має інший тег
індексування масиву, який потребує індексу з міткою, без мітки або з неправильним ім'ям мітки | | | - індексування масиву, який потребує індексу без мітки або з неправильною міткою
214 | **можливо, мався на увазі аргумент масиву типу "const":** _ідентифікатор_ | | - індексація масиву без тегу або з неправильним іменем тегу.
| Масиви завжди передаються за посиланням. Однак, якщо функція не змінює аргумент масиву, компілятор іноді може згенерувати компактніший і швидший код, якщо аргумент масиву спеціально позначити як "const".                                                                                                                                                                                   |
| 215 | **вираз не має ефекту** | **вираз не має ефекту**
| Результат виразу, очевидно, не зберігається у змінній і не використовується у тесті. Тому вираз або інструкція виразу є надлишковою.                                                                                                                                                                                                                                                          |
| 216 | **вкладений коментар**
| PAWN не підтримує вкладені коментарі.                                                                                                                                                                                                                                                                                                                                                                         |
| 217 вільний відступ
| Оператори на одному логічному рівні не починаються в одному стовпчику, тобто відступи операторів різні. Хоча pawn є мовою вільного формату, вільний відступ часто приховує логічну помилку у потоці керування.                                                                                                                                                                   |
| | | Компілятор також може помилково припустити вільний відступ, якщо розмір табуляції, за допомогою якого ви робили відступи у вихідному коді, відрізняється від передбачуваного розміру, див. розділ #pragma tabsize на сторінці 122 або параметр компілятора -t на сторінці 169.                                                                                                                                                                                       |
| 218 | **Прототипи старого стилю використовуються з необов'язковою крапкою з комою** | **Прототипи старого стилю використовуються з необов'язковою крапкою з комою**
| При використанні "необов'язкової крапки з комою" бажано явно оголошувати прямі функції за допомогою ключового слова forward, а не використовувати завершальну крапку з комою.                                                                                                                                                                                                                                                           |
219 | **Ідентифікатор локальної змінної затінює символ на попередньому рівні** | | _Ідентифікатор локальної змінної затінює символ на попередньому рівні__ | _Ідентифікатор локальної змінної
| Локальна змінна має те саме ім'я, що й глобальна змінна, функція, аргумент функції або локальна змінна на нижчому рівні пріоритету. Це називається "затіненням", оскільки нова локальна змінна робить попередньо визначену функцію або змінну недоступною.                                                                                                                                               |
| Примітка: якщо далі у скрипті також з'являються повідомлення про помилки щодо відсутніх змінних (з такими самими іменами) або проблем на рівні фігурних дужок, цілком можливо, що попередження про затінення пов'язані з цими синтаксичними та семантичними помилками. Виправте помилки перед тим, як звертати увагу на попередження про затінення.                                                                                                        |
220 | | **вираз із перевизначенням тегів має міститися у круглих дужках** |.
| У операторі case та у виразах в умовному операторі (" ? : ") будь-який вираз, що має перевизначення тегу, слід брати у круглі дужки, щоб двокрапка не була неправильно інтерпретована як роздільник оператора case або як частина умовного оператора.                                                                                                                              |
221 | | **ім'я мітки ідентифікатор тіні ім'я мітки** | | _ім'я мітки__ _ім'я мітки_*
| Кодова мітка (для інструкції goto) має ту саму назву, що й попередньо визначена мітка. Це може свідчити про помилкове перевизначення мітки; типовим випадком є спроба застосувати перевизначення мітки до змінної ліворуч від оператора = в операторі присвоювання.                                                                                                                                       |
| 222 | **кількість цифр перевищує точність раціонального числа** | **кількість цифр перевищує точність раціонального числа
| Буквальне раціональне число має у дробовій частині більше десяткових знаків, ніж підтримує точність раціонального числа. Решта десяткових знаків ігнорується.                                                                                                                                                                                                                                                       |
| 223 | **надлишковий "sizeof ": розмір аргументу завжди дорівнює 1** (**символ** _ім'я_)
| | | Аргумент функції має значення за замовчуванням, рівне розміру іншого аргументу тієї самої функції. Значення за замовчуванням "sizeof" корисне лише тоді, коли розмір аргументу, на який посилається функція, не вказано в оголошенні функції; тобто, якщо аргумент, на який посилається функція, є масивом.                                                                                                                              |
| 224 | **невизначений розмір масиву у виразі sizeof** (**символ** _ім'я_)
| Операндом оператора sizeof є масив з невизначеним розміром. Тобто, розмір змінної не може бути визначений під час компіляції. Якщо використовується в інструкції if, розглянемо умовно скомпільовану секцію, замінивши if на #if.                                                                                                                                                               |
| 225 | **недосяжний код** | ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦
| Вказаний код ніколи не буде виконаний, тому що інструкція, яка стоїть перед ним (вище), спричиняє вихід з функції, з циклу або деінде. Шукайте інструкції return, break, continue та goto вище вказаного рядка.                                                                                                                                                                                    |
| 226 | **змінна присвоюється сама собі** (**символ** _ім'я_)
| У коді зустрічається інструкція на кшталт "x = x". Синтаксичний аналізатор перевіряє присвоєння після виконання будь-яких текстових і константних підстановок, тому ліва і права частини присвоєння на перший погляд можуть відрізнятися. Наприклад, якщо символ "TWO" є константою зі значенням 2, то "var[TWO] = var[2]" також є самоприсвоєнням.                                                       |
| Звичайно, самоприсвоєння є надлишковим і може приховувати помилку (присвоєння не тій змінній, помилка в оголошенні констант).                                                                                                                                                                                                                                                                       |
| Зауважте, що синтаксичний аналізатор пішаків обмежений виконанням лише "статичних перевірок". У даному випадку це означає, що він може порівнювати тільки присвоєння масивів для самоприсвоєння з константними індексами масивів.                                                                                                                                                                                                                     |
| більше ініціалізаторів, ніж зчислювальних полів*****.
| Масив, розмір якого оголошено зі зчисленням, містить більше значень/полів як ініціалізаторів, ніж визначено у зчисленні.                                                                                                                                                                                                                                                                                   |
228 | **Довжина ініціалізатора перевищує розмір поля перечислення** | | ¦Довжина ініціалізатора перевищує розмір поля перечислення
| Масив, розмір якого оголошено за допомогою символу enum, а відповідне поле перечислення має розмір. Ініціалізатор у масиві містить більше значень, ніж дозволяє розмір поля перечислення.                                                                                                                                                                                                            |
| 229 | **Невідповідність тегу індексації** (**символ** _ім'я_)
| Під час індексування масиву вираз, що використовується як індекс, має іншу мітку, ніж та, що вказана в оголошенні масиву. Пояснення та приклади див. на стор. 29 і 68.                                                                                                                                                                                                                           |
| 230 | **не реалізовано стан** _ім'я_ **у функції** _ім'я_ **, не передбачено резервного коду** | ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦
| Функція не має реалізації для вказаного стану. Компілятор не може (статично) перевірити, чи функцію буде викликано у цьому стані, і тому видає це попередження. Коли функцію буде викликано у стані, для якого не існує реалізації, абстрактна машина завершить роботу з помилкою під час виконання.                                                                   |
| Про те, як вказати функцію відкату, дивіться на сторінці 83, а опис і приклад - на сторінці 44.                                                                                                                                                                                                                                                                                                              |
231 | **Специфікацію стану при прямому оголошенні ігнорується** | | _Специфікацію стану при прямому оголошенні ігнорується_.
| Специфікація стану є надлишковою у прямих оголошеннях. Сигнатура функції повинна бути однаковою для всіх станів. Тільки реалізації функції є специфічними для стану.                                                                                                                                                                                                                                  |
| Переповнення буферу стиснення****
| У деяких випадках компактне кодування може призвести до створення файлів, розмір яких буде більшим за розмір файлів у некомпактному кодуванні. Абстрактна машина не може впоратися з цим, оскільки вона розпаковує P-код "на місці". Коли компілятор виявляє таку ситуацію, він перезбирає файл з вимкненим компактним кодуванням. Щоб уникнути цього попередження, примусово збирайте файл у звичайному ("некомпактному") кодуванні - див. сторінку 120. |
| Ім'я змінної стану затуляє собою глобальну змінну****.
| Змінна стану має таку саму назву, як і глобальна змінна (без специфікаторів стану). Це означає, що глобальна змінна недоступна для функції з одним із тих самих станів, що й змінна.                                                                                                                                                                                                 |
234 | **функція позбавлена значення** (**символ** _ім'я_) | ¦ 234 | **функція позбавлена значення** (**символ** _ім'я_) | ¦ 234
| У скрипті використовується функція, яку позначено як "depricated". Основна програма може позначати (власні) функції як збіднені, якщо для них доступні кращі альтернативи або якщо функція може не підтримуватися у майбутніх версіях основної програми.                                                                                                                                         |
| 235 | **виклик неоголошеної загальнодоступної функції** (**символ** _ім'я_)
| У скрипті визначено загальнодоступну функцію, але немає прямого оголошення цієї функції. Можливо, ім'я функції записано невірно. Вимога прямого оголошення загальнодоступних функцій захищає від поширеної помилки.                                                                                                                                                                  |
Невідомий параметр у підстановці (неправильний #define шаблон)** | 236 | **Невідомий параметр у підстановці (неправильний #define шаблон)** | ¦.
| Шаблон #define містить параметр у заміні (наприклад, "%1"), але не містить параметра у шаблоні збігу. Синтаксис препроцесора описано на сторінці 93.

---

Пастки: 134`

Складений вираз: 112`

Складений вираз: 112`

`Передоплата за декларацію: 82

`Синтаксис імен символів: 97`

Послідовність втечі: 99`

`Порожній складений блок: 112`

`Однорядковий коментар: 97`.

`Іменовані проти позиційних параметрів: 74`

`#pragma rational: 121``.

`Передоплата за декларацію: 82

`Специфікатори стану: 83`.

`Відхилення: 83

Дивіться також #pragma

`amxlimit на сторінці 119`

`#pragma кодова сторінка: 120`

`#assert directive: 117` `#assert directive: 117`

`#директива помилки: 117``.

`Користувацькі оператори: 86`

`Передоплата за декларацію: 82

`Теги обговорюються на сторінці 68

Якщо... #else ... #endif: 117`

`Специфікатори стану: 83`

---

## Компілятор

---

Багато програм, які вбудовують мову сценаріїв PAWN, використовують окремий компілятор
компілятор, який постачається з набором інструментів PAWN. Компілятор PAWN є утилітою
утилітою командного рядка, що означає, що ви маєте запускати його з "вікна консолі",
терміналу/оболонки або "вікна DOS" (залежно від того, як це називається у вашій операційній системі).

### - Використання

Припускаючи, що компілятор командного рядка PAWN називається "_pawncc_" (Unix/
Linux) або "_pawncc.exe_" (DOS/Windows), синтаксис командного рядка буде таким:

    pawncc <ім'я файлу> [інші імена файлів...] [опції]

Ім'я вхідного файлу може бути довільним. Якщо розширення не вказано, вважається, що "_.pawn_"
або ".p". Компілятор створює вихідний файл, який за замовчуванням має
з таким самим ім'ям, як і вхідний файл, і розширенням ".amx".

Після переходу до каталогу зі зразками програм виконується команда:

    pawncc привіт

має скомпілювати найперший приклад "hello world" (сторінка 5). Слід, тому що
команда передбачає це:

- операційна система може знайти програму "_pawncc_" - можливо, вам доведеться додати її до шляху пошуку;

- компілятор PAWN може визначити власне розташування у файловій системі, щоб мати змогу знайти файли, що включаються - деякі операційні системи не підтримують цю можливість і вимагають використання опції -i (див. нижче).

### - Вхідний файл

Вхідним файлом для компілятора PAWN, файлом "вихідного коду" для
скрипту/програми, має бути звичайним текстовим файлом. Усі зарезервовані слова і всі імена символів
(імена змінних, функцій, символічних констант, тегів, ... ) повинні
використовувати набір символів ascii. Літеральні рядки, тобто текст між лапками, можуть бути у
розширеній кодуванні ascii, як, наприклад, один із наборів, стандартизованих у стандарті ISO 8859 - ISO 8859-1
добре відомий набір "Latin 1".

Компілятор PAWN також підтримує текстові файли у кодуванні UTF-8, які зручно використовувати
у середовищі, що базується на Unicode або UCS-4. Компілятор PAWN лише
розпізнає символи у кодуванні UTF-8 всередині нерозпакованих рядків і символьних
константи. Компілятор інтерпретує правила синтаксису для файлів у кодуванні UTF-8
строго; файли, що не відповідають правилам UTF-8, не розпізнаються. Вхідний файл може мати, але
не вимагається, підпис "Знак порядку байт"; компілятор
розпізнає формат UTF-8 на основі вмісту файлу.

### - Опції

Параметри починаються з тире ("-") або, у Microsoft Windows і DOS, з
прямої похилої риски ("/"). Іншими словами, всі платформи приймають опцію, записану у вигляді
у вигляді "-a" (див. нижче призначення цього параметра), а платформи
DOS/Windows приймають "/a" як альтернативу "-a".

Всі варіанти повинні бути відокремлені принаймні одним пробілом.

Багато варіантів приймають значення, яке іноді є обов'язковим. Значення може бути
відокремлене від літери опції двокрапкою або знаком рівності (a ":" і a "="
відповідно), або значення може бути приклеєне до літери опції. Три еквівалентні варіанти
для встановлення рівня налагодження, рівного двом, є три еквівалентні варіанти:

- -d2

- -d:2

- -d=2

Варіанти такі:

| Опція | Опис |
| ---------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| -a | Асемблер: згенерувати текстовий файл з псевдоасемблерним кодом для абстрактної машини PAWN замість двійкового коду.                                                                                                                                                                                                                                                                                                                                                            |
| -C+/- | Компактне кодування двійкового файлу, яке зменшує розмір вихідного файлу, як правило, до половини початкового розміру. Використовуйте -C+, щоб увімкнути його, і -C-, щоб повернутися до "звичайного" кодування. Параметр -C (без суфікса + або -) перемикає поточний параметр.                                                                                                                                                                                                                      |
| -cname | Кодова сторінка: встановити кодову сторінку для перекладу вихідного файлу з розширеної кодування ascii у Unicode/UCS-4. За замовчуванням переклад не виконується. Параметр name може вказувати повний шлях до "файлу зіставлення" або лише ідентифікатор кодової сторінки - у останньому випадку компілятор додає до ідентифікатора літери "cp", розширення ".txt" і завантажує файл зіставлення із системного каталогу.                                                                          |
| -Dpath | Каталог: "активний" каталог, у якому компілятор має шукати свої вхідні файли та зберігати вихідні файли.                                                                                                                                                                                                                                                                                                                                                              |
| Цей параметр підтримується не на всіх платформах. Щоб перевірити, чи підтримує компілятор PAWN цей параметр, запустіть компілятор без жодного параметра або імені файлу у командному рядку. Після цього компілятор покаже синтаксис використання і всі доступні опції в алфавітному порядку. Якщо ключ -D відсутній, опція буде недоступна.                                                                                                                                            |
| -dlevel | Рівень налагодження: 0 = немає, 1 = лише перевірка меж і тверджень, 2 = повна символьна інформація, 3 = повна символьна інформація і вимкнені оптимізації (так само як комбінація -d2 і -O0).                                                                                                                                                                                                                                                                                   |
| Якщо рівень налагодження дорівнює 2 або 3, компілятор PAWN також виводить приблизну кількість місця у стеку/купці, необхідну для програми.                                                                                                                                                                                                                                                                                                                                                 |
| -efilename | Файл помилок: задати назву файлу, до якого компілятор має записувати всі попередження та повідомлення про помилки; якщо встановлено, виведення на екран не відбувається.                                                                                                                                                                                                                                                                                                                              |
| -Hvalue | "HWND" (лише для версії для Microsoft Windows): компілятор може за бажанням надсилати повідомлення до вказаного дескриптора вікна після завершення генерації P-коду. Хост-програми, які викликають компілятор PAWN, можуть чекати на надходження цього повідомлення або сигналізувати користувачеві про завершення компіляції.                                                                                                                                                                       |
| Номер повідомлення, яке надсилається у вікно, створюється за допомогою функції Microsoft Windows SDK RegisterWindowMessage з іменем "PawnNotify". Параметр wParam повідомлення містить код повернення компілятора: 0 = успіх, 1 = попередження, 2 = помилки (плюс, можливо, попередження), 3 = компіляцію перервано користувачем.                                                                                                                                                               |
| -ipathname | Шлях включення: задати шлях, де компілятор може знайти файли включення. Цей параметр може з'являтися у командному рядку декілька разів, щоб ви могли вказати декілька шляхів до включення.                                                                                                                                                                                                                                                                                                  |
| -l | Лістинг: виконати лише читання та попередню обробку файлів; наприклад, для перевірки дії макросів підстановки тексту та умовно скомпільованих/пропущених розділів.                                                                                                                                                                                                                                                                                               |
| -Olevel | Рівень оптимізації: 0 = жодних оптимізацій; 1 = лише JIT-сумісні оптимізації (JIT = "Just In Time" компілятор, високопродуктивна абстрактна машина); 2 = повна оптимізація.                                                                                                                                                                                                                                                                                                    |
| -filename | Вихідний файл: задати ім'я та шлях до двійкового вихідного файлу.                                                                                                                                                                                                                                                                                                                                                                                                                    |
| -pfilename | Префіксний файл: ім'я "префіксного файлу", це файл, який розбирається перед вхідним файлом (як різновид неявного "include file"). Якщо використовується, цей параметр замінює стандартний файл включення "default.inc". Опція -p сама по собі (без імені файлу) вимикає обробку будь-якого неявного включаємого файлу.                                                                                                                                                               |
| -rfilename | Звіт: увімкнути створення звіту і за бажанням задати ім'я файлу, до якого буде записано витягнуту документацію і звіт з перехресними посиланнями.                                                                                                                                                                                                                                                                                                                      |
| Звіт створюється у форматі "XML". Параметр filename є необов'язковим; якщо його не вказано, файл звіту матиме те саме ім'я, що й вхідний файл з розширенням ".XML".                                                                                                                                                                                                                                                                                                              |
| -Svalue | Розмір стеку: розмір стеку та купи у комірках.                                                                                                                                                                                                                                                                                                                                                                                                                         |
| -svalue | Кількість пропущених рядків: кількість рядків, які слід пропустити у вхідному файлі перед початком компіляції; наприклад, пропустити "заголовок" у вихідному файлі, який не відповідає допустимому синтаксису PAWN.                                                                                                                                                                                                                                                                                                    |
| -tvalue | розмір табуляції: кількість пробілів для символу табуляції. Якщо значення параметра дорівнює нулю (наприклад, опція -t0), компілятор не видаватиме попередження 217 (нещільні відступи).                                                                                                                                                                                                                                                                                                       |
| -vvalue | Докладно: показувати інформаційні повідомлення під час компіляції. Значення може бути 0 (нуль) для "тихої" компіляції, 1 (одиниця) для звичайного виводу і 2 для звіту про використання коду/даних/стеку.                                                                                                                                                                                                                                                                                           |
| -wvalue+/- | Керування попередженнями: номер попередження після "-w" увімкнено або вимкнено, залежно від того, "+" чи "-" стоїть після цього номера. Якщо "+" або "-" відсутній, статус попередження перемикається. Наприклад, -w225- вимикає попередження про "недоступний код", -w225+ вмикає його, а -w225 перемикає між увімкненим/вимкненим станом.                                                                                                                                                |
| | | Можна вимкнути лише попередження (помилки та фатальні помилки не можна вимкнути). За замовчуванням усі попередження увімкнено.                                                                                                                                                                                                                                                                                                                                                                |
| -Xvalue | Обмеження для абстрактної машини: максимальні вимоги до пам'яті, які може мати скомпільований скрипт, у байтах. Це значення є корисним для (вбудованих) середовищ, де максимальний розмір скрипта обмежено жорсткою верхньою межею. Якщо не вказано обсяг оперативної пам'яті для даних і стека, це значення стосується загальних вимог до пам'яті; якщо обсяг оперативної пам'яті вказано явно, це значення визначає лише обсяг пам'яті, необхідний для коду і статичних даних. |
| -XDvalue | Ліміт оперативної пам'яті для абстрактної машини: максимальні вимоги до пам'яті для даних і стеку, які може мати скомпільований скрипт, у байтах. Це значення є корисним для (вбудованих) середовищ, де максимальний розмір даних скрипта обмежено жорсткою верхньою межею. Особливо у випадку, коли PAWN-скрипт запускається з ПЗП, потрібно встановити обидва розміри - і для коду, і для даних.                                                                                          |
| -\ | Керуючі символи починаються з "\" (для подібності до C, C++ та Java) | -^ | Керуючі символи починаються з "\
| -^ | Керуючі символи починаються з "ˆ" (для сумісності з попередніми версіями pawn).                                                                                                                                                                                                                                                                                                                                                                                             |
| -;+/- | З -;+ кожен оператор повинен закінчуватися крапкою з комою; з -;- крапка з комою необов'язкова, якщо оператор є останнім у рядку. Опція -; (без суфікса + або -) перемикає поточний параметр.                                                                                                                                                                                                                                                  |
| sym=value | визначити константу "sym" із заданим (числовим) значенням, значення не є обов'язковим; |.
| @filename | прочитати (більше) параметрів із вказаного "файлу-відповіді".                                                                                                                                                                                                                                                                                                                                                                                                                          |

### - Файл відповіді

Для підтримки операційних систем з обмеженою довжиною командного рядка (наприклад, Mi-
crosoft DOS), компілятор PAWN підтримує "файли-відповіді". Файл-відповідь
це текстовий файл, який містить опції, які ви могли б вказати у командному рядку
командного рядка. За допомогою команди

    pawncc @opts.txt prog.pawn

компілятор PAWN компілює файл "prog.pawn", використовуючи опції, які
перераховані у файлі-відповіді "opts.txt".

### - Файл конфігурації

На платформах, які його підтримують (наразі це Microsoft DOS, Microsoft Windows
і Linux), компілятор зчитує параметри з "конфігураційного файлу" під час запуску.

Конфігураційний файл повинен мати назву "pawn.cfg" і знаходитись у
у тому ж каталозі, що і виконувана програма компілятора.

У певному сенсі, файл конфігурації є неявним файлом відповіді. Параметри
вказані у командному рядку, можуть замінити ті, що вказані у конфігураційному файлі.

---

`Упаковані/розпаковані рядки: 99`

`Символьні константи: 99`.

`#pragma dynamic: 121` `#pragma dynamic: 121``.

Попередження: 161`

Дивіться також #pragma amxlimit на сторінці 119

`Дивіться також #pragma amxram на сторінці 120`.

---

## Обґрунтування

---

Першим питанням у презентації нової комп'ютерної мови має бути: навіщо
нова мова взагалі?

Дійсно, я вивчив кілька існуючих мов, перш ніж розробити свою власну.
свою власну. Багато маленьких мов були призначені для написання сценаріїв командної оболонки (TCL, Perl,
Python). Інші мови не були розроблені як мови розширення, і покладали
тягар вбудовування виключно на хост-додаток.

Оскільки я спочатку намагався використовувати Java як мову розширення (а не створювати власну мову, як зараз), різниця між PAWN і Java є ілюзорною.
(а не створювати свою власну, як я роблю зараз), відмінності між PAWN та Java є ілюзорними, оскільки обидві мови мають майже однакові цілі
ілюзорні, оскільки цілі розробки обох мов майже збігаються. Наприклад,

Java сприяє розподіленим обчисленням, де "пакети" знаходяться на різних носіях.
PAWN розроблено так, щоб скомпільовані аплети можна було легко зберігати у
складеному файлі разом з іншими даними. Крім того, Java розроблена таким чином, щоб бути
архітектурно нейтральною та незалежною від додатків, і навпаки, PAWN розроблена так, щоб
бути тісно пов'язаним з додатком; власні функції є табу в деякій мірі в Java (принаймні, принаймні, в
певною мірою табу в Java (принаймні, це вважається "нечистим"), в той час як власні функції
є "причиною для існування" для PAWN. З точки зору PAWN, цільове
використання Java перевернуте з ніг на голову: нативні функції розглядаються як допоміжна бібліотека
яку використовує додаток - на Java; в PAWN нативні функції є частиною
"програми", а сама програма PAWN є набором допоміжних функцій
які використовує програма.

**Мова для написання сценаріїв додатків:** PAWN розроблено як розширену мову, призначену для написання макросів і програм.
мова розширення, призначена для написання специфічних макросів або підпрограм для додатків.
PAWN не є відповідною мовою для реалізації бізнес-додатків
або операційних систем. PAWN розроблено так, щоб її можна було легко інтегрувати з іншими системами та
вбудовуватися в інші системи/додатки.

Як мова розширення, програми PAWN зазвичай маніпулюють об'єктами
основної програми. В анімаційних системах PAWN-скрипти мають справу зі спрайтами,
подіями та часовими інтервалами; у комунікаційних програмах PAWN-скрипти обробляють
пакетами та з'єднаннями. Я припускаю, що хост-додаток надасть
(підмножину) своїх ресурсів і функціональних можливостей за допомогою функцій, дескрипторів,
чарівних файлів cookie. . . подібно до того, як сучасна операційна система
надає інтерфейс до процесів, написаних на C/C++ - наприклад, Win32 API ("дескриптори
всюди") або "glibc" GNU/Linux. З цією метою PAWN має простий та
ефективний інтерфейс до "рідних" функцій хостової програми. СКРИПТ PAWN
маніпулює об'єктами даних у хост-програмі за допомогою викликів функцій,
але він не може отримати доступ до даних основної програми безпосередньо.

Першими і головними критеріями для мови PAWN були швидкість виконання
та надійність. Надійність у тому сенсі, що програма на PAWN не повинна
викликати аварійне завершення роботи програми або інструменту, в який вона вбудована - принаймні, не
легко. Хоча це значно обмежує можливості мови,
переваги є подвійними:

- розробник програми може бути впевнений, що його програма не вийде з ладу через користувацькі доповнення або макроси,

- користувач може вільно експериментувати з мовою без ризику (або з незначним ризиком) пошкодження файлів програми.

**Швидкість має велике значення:** Програми PAWN, ймовірно, працюватимуть на абстрактній машині, а абстрактні машини, як відомо, працюють повільно.
а абстрактні машини, як відомо, повільні. Я повинен був створити мову
з низькими накладними витратами і мову, для якої можна було б написати швидку абстрактну машину.
написати швидку абстрактну машину. Швидкість також повинна бути надійною, в тому сенсі, що PAWN-скрипт не повинен
не повинен сповільнюватися з часом або мати випадкові збої у роботі. Отже, PAWN виключає
Отже, PAWN виключає будь-який необхідний "фоновий процес", такий як збір сміття, і ядро абстрактної машини
збір сміття, а ядро абстрактної машини не виділяє неявно
ядро абстрактної машини не виділяє системні ресурси або ресурси додатків під час роботи. Тобто, PAWN не
не виділяє пам'ять і не відкриває файли без допомоги власної функції, яку
яку скрипт викликає явно.

Як сказав Денніс Рітчі, за задумом, мова C обмежується засобами
які можна відносно ефективно і безпосередньо відобразити у машинні інструкції. Те ж саме
те саме стосується і PAWN, і це також є частковим поясненням того, чому PAWN виглядає
так схожий на C. Хоча PAWN працює на абстрактній машині, мета полягає у тому, щоб
зробити цю абстрактну машину маленькою і швидкою. PAWN використовується у крихітних вбудованих
системах з розміром оперативної пам'яті 32 кілобайти або менше, а також у високопродуктивних іграх
яким потрібен кожен процесорний цикл для графічного рушія та ігрового процесу.  
В обох середовищах важка підтримка сценаріїв є складною для сприйняття.

Короткий аналіз показав, що логіка декодування інструкцій для абстрактної машини
швидко стане вузьким місцем у продуктивності абстрактної машини.
машини. Щоб спростити декодування, кожен опкод повинен мати однаковий розмір (за винятком операндів)
однаковий розмір (за винятком операндів), і опкод повинен повністю визначати інструкцію
(включаючи методи адресації, розмір операндів і т.д.). Це означає
що для кожної операції над змінною абстрактній машині потрібен окремий
опкод для кожної комбінації типу змінної, класу зберігання та методу доступу
(прямого чи розіменованого). Навіть для трьох типів (int, char та unsigned int),
двох класів зберігання (глобальний і локальний) і трьох методів доступу (прямий, індексований
прямий або індексований), загалом потрібно 18 опкодів (3*2*3), щоб просто отримати
значення змінної.

У той же час, щоб абстрактна машина була невеликою і керованою, я поставив собі за мету
приблизно 100 інструкцій.∗ З 18 опкодами для завантаження змінної
в регістр, ще 18, щоб зберегти регістр у змінну, ще 18, щоб отримати
адресу змінної і т.д. і т.п. Я швидко перевищив встановлений мною ліміт
у сто опкодів.

Мови bob та rexx надихнули мене на створення безтипологічної мови. Це
врятувало мене від великої кількості опкодів. В той же час, мову більше не можна було
називати "підмножиною C". Я змінював мову. Чому ж тоді не піти на крок
далі у зміні мови? Тут у гру вступили ще кілька рекомендацій щодо дизайну:

- дати програмісту інструмент загального призначення, а не спеціальне рішення

- уникати помилкових мовних конструкцій; сприяти перевірці помилок

- бути прагматичними

**Інструмент загального призначення:** PAWN розроблено як мову розширення, без
не визначено, що саме вона буде розширювати. Зазвичай, програма або
інструмент, який використовує PAWN як мову розширення, надасть багато оптимізованих
процедур або команд для роботи з власними об'єктами, будь то текст, база даних
записів або анімованих спрайтів. Мова розширень існує для того, щоб дозволити користувачеві
робити те, що розробник програми забув або вирішив не включати. Замість того, щоб
Замість того, щоб надавати вичерпну бібліотеку функцій для сортування даних, зіставлення регулярних виразів або малювання
регулярних виразів або побудови кубічних сплайнів Б'єзьє, PAWN має надавати засоби (загального призначення) для використання
призначення) засоби для використання, розширення та комбінування специфічних ("рідних") функцій
які надає програма.

PAWN не має повної стандартної бібліотеки. За задумом, у PAWN також відсутні такі функції, як вказівники, динамічний розподіл пам'яті
таких як вказівники, динамічне виділення пам'яті, прямий доступ до операційної системи або апаратного забезпечення, які необхідні для того, щоб конкурувати з іншими програмами.
системи або до апаратного забезпечення, які необхідні для того, щоб залишатися конкурентоспроможними у сфері
загального призначення або системного програмування. Ви не можете створювати зв'язані
списки або динамічні деревоподібні структури даних у PAWN, а також ви не можете отримати доступ до будь-якої
пам'яті за межами абстрактної машини. Це не означає, що
що програма на PAWN не може використовувати динамічні, відсортовані таблиці символів або змінювати
параметр у операційній системі; вона може це робити, але їй потрібно
робити це за допомогою виклику "власної" функції, яку програма надає абстрактній машині.

---

###### ∗ На момент написання статті визначено 136 опкодів, плюс 20 "макро" опкодів. Для використання приросту продуктивності за рахунок примусового вирівнювання слів пам'яті (необхідного для мікропроцесорів ARM), поточна абстрактна машина використовує 32-розрядні опкоди. Технічних обмежень на кількість опкодів не існує, але в інтересах малої займаної площі, кількість опкодів слід обмежити

---

Іншими словами, якщо програма вирішує реалізувати добре відомі функції peek і
poke (з мови BASIC) в абстрактній машині, програма PAWN може
отримати доступ до будь-якого байту в пам'яті, якщо це дозволяє операційна система. Аналогічно,
програма може надавати власні функції, які вставляють, видаляють або шукають
символів у таблиці і дозволяє виконувати над ними декілька операцій. Запропоновані основні функції
getproperty і setproperty є прикладом власних функцій, які створюють
зв'язаний список у фоновому режимі.

**Сприяти перевірці помилок:** Як ви могли помітити, один з головних
критерій проєктування мови C, "довіряти програмісту", відсутній у
у моєму списку критеріїв проєктування. Користувачі скриптових мов можуть не бути досвідченими
програмістами; і навіть якщо це так, PAWN, ймовірно, не буде їхньою основною
мовою. Більшість PAWN-програмістів продовжуватимуть вивчати мову в процесі роботи, і навіть через багато років
Більшість програмістів PAWN продовжуватимуть вивчати мову на ходу, і навіть через роки не стануть експертами. Отже, є достатньо підстав
щоб замінити елементи мови C, схильні до помилок (вказівники), на
економнішими, хоча і менш загальними, конструкціями (посиланнями).† Посилання скопійовано з C++.
Вони є нічим іншим, як замаскованими вказівниками, але вони
обмежені різними, здебільшого корисними, способами. Зверніться до книги з C⁺⁺, щоб знайти більше обґрунтувань для посилань.

Я вважаю сумним, що багато, навіть сучасних, мов програмування мають так мало
мало вбудованої або простої у використанні підтримки для підтвердження того, що програми роблять
що програми працюють так, як задумав програміст. Я не маю на увазі теоретичну коректність (яка
надто дорого досягти для чогось більшого, ніж іграшкові програми), але
а про практичні, прості у використанні механізми перевірки на допомогу програмісту.
PAWN надає твердження про час компіляції та час виконання, які можна використовувати для передумов, постумов та інваріантів.

Механізм типізації, який використовується у більшості мов програмування, також є автоматичним "ловцем" цілого класу помилок.
автоматичним "ловцем" цілого класу помилок. В силу того, що це безтипова мова
PAWN не мала таких можливостей перевірки помилок. Це було очевидним недоліком, і я
створив механізм "тегів" як еквівалент для перевірки передачі параметрів функцій, індексації масивів та інших помилок.
передачі параметрів функції, індексації масивів та інших операцій.

---

###### † Ви повинні розглядати це зауваження у контексті мого попереднього твердження про те, що багато програмістів "PAWN" будуть програмістами-початківцями. З мого (викладацького) досвіду, програмісти-початківці роблять багато помилок з вказівниками, на відміну від досвідчених програмістів C/C++

---

Якість інструментів: компілятора та абстрактної машини, також має
великий вплив на надійність коду - незалежно від мови. Хоча
це дуже слабо пов'язано з дизайном мови, я поставив собі за мету
побудувати інструменти таким чином, щоб вони сприяли перевірці помилок. Система попереджень у PAWN
виходить за рамки простого повідомлення про те, що синтаксичному аналізатору не вдається
інтерпретувати дані відповідно до граматики мови. У деяких випадках компілятор
виконує перевірки, які абсолютно не пов'язані з генерацією коду і які реалізовано спеціально для виявлення можливих помилок.
які реалізовано спеціально для виявлення можливих помилок. Аналогічно, "гачок відладчика"
розроблений прямо в абстрактній машині, він не є надбудовою, реалізованою
як додаткове доповнення.

Будьте прагматичними: Об'єктно-орієнтована парадигма програмування не зовсім
об'єктно-орієнтована парадигма програмування, на мою думку, не зовсім виправдала покладені на неї сподівання. З одного боку, ООП вирішує багато
завдань більш простим і чистим способом, завдяки додатковому рівню абстракції. З іншого боку, сучасне об'єктно-орієнтоване програмування
іншого боку, сучасні об'єктно-орієнтовані мови змушують вас боротися з
мовою, а не із завданням, що стоїть перед вами. Об'єктно-орієнтовані мови є
привабливі головним чином завдяки широким бібліотекам класів, з якими вони поставляються
але використання стандартних бібліотек суперечить одній з цілей проєктування
PAWN. Об'єктно-орієнтоване програмування не є рішенням для
програміста, який не має достатньо терпіння для штучного ускладнення. Критерій
"бути прагматичним" - це нагадування шукати рішення, а не елегантність.

### - Практичні критерії дизайну

Той факт, що PAWN так схожий на C, не може бути збігом, і це не так.
PAWN почалася як діалект C і залишилася ним, тому що C має перевірену репутацію
репутацію. Зміни від C здебільшого народилися з необхідності після того, як я викреслив
особливостей C, які я не хотів бачити у мові сценаріїв: відсутність вказівників
і ніякої системи "набору".

PAWN, як безтипова мова, потребувала інших засобів для оголошення змінних.
Під час модифікації я також відмовився від вимоги мови C
що всі змінні мають бути оголошені на початку складеного оператора. PAWN - це
трохи більше схожа на C⁺⁺ у цьому відношенні.

Функції мови C можуть передавати "вихідні значення" через аргументи-покажчики. Стандартна функція
стандартна функція scanf, наприклад, зберігає значення або рядки, які вона зчитує
з консолі у свої аргументи. Ви можете спроєктувати функцію у C таким чином, щоб
необов'язково повертала значення через аргумент-покажчик; якщо користувачеві, який викликає функцію
не цікавить значення, що повертається, він передає NULL як значення вказівника
значення. Стандартна функція strtol є прикладом такої функції. Цей прийом
часто рятує вас від оголошення та передачі фіктивних змінних.
PAWN замінює вказівники посиланнями, але посилання не можуть бути NULL. Таким чином,
PAWN потребує іншої техніки для "скидання" значень, які повертає функція
через посилання. Рішенням цієї проблеми є використання "заповнювача аргументів"
який записується у вигляді символу підкреслення (" "); програмісти на Пролозі розпізнають
це як аналогічну функцію у цій мові. Заповнювач аргументу
резервує тимчасовий анонімний об'єкт даних ("комірку" або масив комірок)
який автоматично знищується після виклику функції.

Тимчасова комірка для заповнювача аргументу все одно повинна мати значення be-
оскільки функція може сприймати параметри посилання як вхідні/вихідні дані. Тому
функція повинна вказувати для кожного переданого за посиланням аргументу, яке значення він
матиме на вході, коли користувач передасть заповнювач замість фактичного аргументу.
замість фактичного аргументу. Крім того, я також додав значення за замовчуванням для аргументів, які
є "переданим значенням". Можливість за бажанням вилучати всі аргументи зі значеннями за замовчуванням
значеннями за замовчуванням справа була скопійована з C++.

Говорячи про BCPL і B, Денніс Річі сказав, що C був винайдений частково
щоб забезпечити правдоподібний спосіб роботи з рядками символів, коли хтось починає
зі словесно-орієнтованої мови. PAWN надає два варіанти роботи з рядками
рядками, упаковані та неупаковані рядки. У розпакованому рядку кожен символ

поміщається у комірку. Накладні витрати для типової 32-бітної реалізації великі: один
символ займає чотири байти. Упаковані рядки зберігають до чотирьох символів
в одній комірці, що значно ускладнює роботу з ними.
обробляти, якщо б ви мали доступ лише до повних комірок. Сучасні реалізації BCPL надають два методи індексування масивів
індексації масивів: один для отримання слова з масиву і один для отримання символу
з масиву. PAWN копіює цю концепцію, хоча синтаксис відрізняється від
від синтаксису BCPL. Функція упакованого рядка також призвела до появи нового оператора char.

Програми Unicode часто мають справу з двома наборами символів:
8-бітним для застарілих форматів файлів і стандартизованих форматів передачі (як і багато протоколів Інтернету) і 16-бітним набором символів
протоколів) і 16-бітним набором символів Unicode (або 31-бітним набором символів UCS-4).
набір символів UCS-4). Хоча компілятор PAWN має опцію, яка робить символи 16-бітними
(таким чином, у 32-бітну комірку поміщається лише два символи), зазвичай зручніше зберігати однобайтові символи
зручніше зберігати однобайтові рядки символів у запакованих рядках, а багатобайтові рядки у
у розпакованих рядках. Це перетворюється на слабке місце PAWN - необхідність розрізняти
упаковані рядки від неупакованих - на сильну сторону: PAWN може зробити це

розрізняти досить легко. І замість того, щоб створювати дві реалізації для кожної
функції, яка має справу з рядками (версію ascii та версію Unicode - подивіться
на API Win32 або навіть стандартну бібліотеку C), PAWN дозволяє функціям
легко обробляти як запаковані, так і розпаковані рядки.

Незважаючи на вищезгадані зміни, а також зміни, описані в розділі "Підводні камені: відмінності від С" (стор. 134), я намагався зробити PAWN близьким до С.
falls: відмінності від C" (сторінка 134), я намагався зберегти PAWN близькою до C. А
Останній пункт, який не пов'язаний з дизайном мови, але все ж таки важливий,
це ліцензія: PAWN розповсюджується під ліберальною ліцензією, яка дозволяє вам використовувати
та/або адаптувати код з мінімальними обмеженнями - див. додаток D.

---

`Підтримка рядкових літералів Unicode: 139

---

## Ліцензія

---

Програмний інструментарій "PAWN" (компілятор, абстрактна машина та
документація) захищені авторським правом з 1997-2006 ITB CompuPhase. Реалізація абстрактної машини на Intel
асемблерна реалізація абстрактної машини та компілятор just-in-time
piler (зокрема, файли amxexec.asm, amxjitr.asm та amxjits.asm)
захищені авторським правом c 1998-2003 Марк Пітер. Файл amxjitsn.asm перекладено
з amxjits.asm і частково з 2004 G.W.M. Vissers. Файл amxex-
ecn.asm перекладено з amxexec.asm і частково c 2004-2005 ITB CompuPhase.

PAWN розповсюджується за ліцензією "zLib/libpng", яка відтворюється без
низький:

---

Це програмне забезпечення надається "як є", без будь-яких явних або неявних гарантій. В жодному разі
жодному разі автори не несуть відповідальності за будь-які збитки, що виникли внаслідок використання
цього програмного забезпечення.

Дозвіл надається будь-кому для використання цього програмного забезпечення з будь-якою метою, включаючи
комерційних цілях, а також змінювати його та вільно розповсюджувати, за умови дотримання
наступних обмежень:

1 Походження цього програмного забезпечення не повинно бути спотворено; ви не повинні стверджувати
що ви написали оригінальне програмне забезпечення. Якщо ви використовуєте це програмне забезпечення у своєму продукті,
ми будемо вдячні, якщо ви зазначите це у документації до продукту.
але не є обов'язковим.

2 Змінені версії вихідного коду повинні бути чітко позначені як такі, і не повинні
не можна видавати за оригінальне програмне забезпечення.

3 Це повідомлення не може бути видалене або змінене з будь-якого джерела розповсюдження.

---

Ліцензію zLib/libpng схвалено організацією "Open Source Initiative".

---

[Повернутися до змісту](00-Contents.md)
