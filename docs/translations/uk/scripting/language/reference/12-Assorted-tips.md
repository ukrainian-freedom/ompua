# Асорті чайових

---

### - Робота з символами та рядками

Рядки можуть бути в упакованому або неупакованому форматі. У упакованому форматі кожна
комірка зазвичай містить чотири символи (у звичайних реалізаціях комірка має
32-бітною, а символ - 8-бітним). У цій конфігурації перший символ
у "пачці" з чотирьох символів є старшим байтом комірки, а четвертий символ знаходиться у
молодшому байті кожної комірки.

Рядок повинен зберігатись у масиві. Для нерозпакованого рядка масив повинен бути
бути достатньо великим, щоб вмістити усі символи рядка плюс завершальну нульову комірку
нульову комірку. Тобто, у наведеному нижче прикладі змінна ustring визначається як така, що має п'ять
комірок, що якраз достатньо для зберігання рядка, яким її ініціалізовано:

Лістинг: розпакований рядок

```c

new ustring[5] = "test"

```

У упакованому рядку кожна комірка містить декілька символів, а рядок
закінчується нульовим символом. Оператор char допомагає оголосити розмір масиву
щоб він містив потрібну кількість символів. У прикладі нижче буде виділено
достатньо комірок для розміщення п'яти упакованих символів. У типовій реалізації, у масиві
буде дві комірки в масиві.

Лістинг: упакований рядок

```c

new pstring[5 char] = !"test"

```

Іншими словами, оператор char ділить свій лівий операнд на кількість
байт, що вміщується у комірці, і округлює у більшу сторону. Знову ж таки, у типовій реалізації
це означає ділення на чотири і округлення у більшу сторону.

Ви можете створювати підпрограми, які працюють з рядками як в упакованих, так і в неупакованих матах
килимках. Щоб дізнатися, чи є рядок упакованим або неупакованим, подивіться на першу
комірку рядка. Якщо її значення від'ємне або перевищує максимально можливе
значення непакованого символу, то рядок є упакованим. У протилежному випадку
це нерозпакований рядок.

Фрагмент коду нижче повертає true, якщо вхідний рядок упаковано, і false у протилежному випадку:

Лістинг: упакована функція

```c

bool: ispacked(string[])
    return !(0 <= string[0] <= ucharmax)

```

Неупакований рядок закінчується повною нульовою коміркою. Кінець упакованого рядка
позначається лише нульовим символом. Оскільки у 32-бітній комірці може бути до чотирьох символів
у 32-бітній комірці, цей нульовий символ може знаходитись у будь-якій з чотирьох позицій у
"пакунку". Оператор { } витягує символ з комірки в масиві
масиву. В основному, для розпакованих рядків використовується оператор індексу комірки ("[ ]"), а для нерозпакованих
оператор індексу символів ("{ }") для роботи з упакованими рядками.

Наприклад, процедура, яка повертає довжину в символах будь-якого
рядка (упакованого або неупакованого):

Лістинг: моя функція strlen

```c

my_strlen(string[])
{
    new len = 0
    if (ispacked(string))
        while (string{len} != EOS) /* отримуємо символ з пакету */
            ++len
    else
        while (string[len] != EOS) /* отримуємо комірку */
            ++len
    return len
}

```

Якщо ви створюєте функції, які працюють виключно з упакованими або неупакованими рядками,
варто додати твердження для забезпечення виконання цієї умови:

Лістинг: функція стриптизу

```c

stripper(string[])
{
    assert ispacked(string)

    for (new i=0; string{i} != EOS; ++i)
        string{i} = toupper(string{i})
}

```

Хоча у попередніх параграфах ми припускали, що комірка має ширину 32
біт, а символ має довжину 8 біт, на це не слід покладатися. Розмір комірки
розмір комірки визначається реалізацією; максимальне та мінімальне значення
у визначених константах cellmax та cellmin. Існують аналогічні визначені константи
константи для символів. Можна з упевненістю припустити, що як розмір символу у байтах, так і розмір
символу у байтах і розмір комірки у байтах є степенями двійки.

Оператор char дозволяє визначити, скільки упакованих символів поміститься в
комірці. Наприклад:

```c

#if 4 char == 1
    /* код, який передбачає 4 упаковані символи в комірці */
#elseif 4 char == 2
    /* код, який передбачає 2 упаковані символи в комірці */
#elseif 4 char == 4
    /* код, який передбачає 1 упакований символ в комірці */
#else
    #assert 0 /* непідтримуваний розмір комірки/символу */
#endif

```

### - Інтернаціоналізація

У прикладах програмування у цьому посібнику використовується англійська мова для
виведення (підказки, повідомлення, ... ), а також латинський набір символів. Це
не є обов'язковим; ви можете, наприклад, змінити першу програму "hello world" на сторінці 5 на:

Список: "привіт світу" грецькою мовою

```c

main()
    printf " ˙ ˙\n"

```

PAWN має базову підтримку нелатинських алфавітів, але вона приймає лише нелатинські
символи лише у рядках та символьних константах. Мова PAWN
вимагає, щоб усі ключові слова і символи (назви функцій, змінних, тегів та інших
елементи) повинні бути закодовані у наборі символів ascii.

Для мов, для яких необхідний набір символів відносно невеликий, поширеним рішенням є використання розширеного набору символів ascii.
є використання 8-бітового розширеного набору символів ascii (набір символів ascii є
7-бітовий, містить 128 символів). Верхні 128 кодів розширеного набору містять

зберігають специфічні для мови гліфи. Для західноєвропейських мов добре відомим набором символів є
відомим набором символів є "Латиниця-1", який стандартизовано як ISO 8859-1 - той самий набір також має назву "кодова сторінка 1252".
той самий набір також відомий під назвою "кодова сторінка 1252", принаймні для Microsoft Win
dows.∗ Кодові сторінки були визначені для багатьох мов; наприклад, ISO
8859-2 ("Латиниця-2") містить гліфи, що використовуються у Центральній та Східній Європі, а ISO
8859-7 містить грецький алфавіт у верхній половині розширеного набору ascii.

На жаль, вибір кодової сторінки може заплутати, оскільки виробники операційних
систем зазвичай створюють власні кодові сторінки незалежно від того, що
що вже існувало. Як наслідок, для більшості наборів символів існує декілька несумісних кодових сторінок

---

###### ∗ Кодова сторінка 1252 не зовсім збігається з Латиницею-1; Microsoft розширила стандартний набір, включивши до нього гліфи в позиціях коду, які в Латиниці-1 позначено як "зарезервовані".

---

Наприклад, кодова сторінка 1253 для Microsoft Windows також кодує
грецький алфавіт, але він несумісний з ISO 8859-7. Під час написання
текстів грецькою мовою, важливо перевірити, яке кодування використовується
використовується, оскільки багато програм для Microsoft Windows підтримують обидва кодування.

Якщо набір символів мови перевищує 256 гліфів, кодова сторінка
недостатньо. Традиційно техніку кодових сторінок розширювали за рахунок резервування
спеціальних "зсувних" кодів у базовому наборі символів, які переходять до нового набору
гліфів. Наступний символ вказує на конкретний гліф. По суті, гліф
тепер ідентифікується 2-байтовим індексом. З іншого боку, деякі символи (особливо
7-бітовий набір ascii) все ще можна позначити одним байтом. Стандарт
Стандарт "Shift-JIS" для японського набору символів є прикладом кодування змінної довжини.

Кодові сторінки стають проблематичними під час обміну документами або даними з
людьми в регіонах, які використовують інші кодові сторінки, або при використанні різних
мови в одному документі. Кодові сторінки, які використовують символи "зсуву", ще більше усувають цю проблему, тому що тепер при обробці тексту необхідно враховувати
ще більше покращують ситуацію, оскільки обробка тексту тепер повинна враховувати
що символ може займати як один, так і два байти. Сканування рядка справа наліво
справа наліво може навіть стати неможливим, оскільки байт може позначати або
гліф з базового набору ("незсунутий"), або гліф зі зсунутого набору
-у останньому випадку попередній байт вказує на зсувну множину, але значення попереднього символу
попереднього символу залежить від символу, що стоїть перед ним.

Стандарт ISO/IEC 10646 "Універсальний набір символів" (UCS) має амбітну мету
амбітну мету - врешті-решт включити всі символи, що використовуються у всіх письмових мовах світу.
мовами світу, використовуючи 31-бітний набір символів. Це вирішує обидві проблеми
пов'язані з кодовими сторінками та "зсунутими" наборами символів. Однак, організація ISO/IEC
не зміг створити стандарт вчасно, і тому консорціум переважно американських
американських виробників програмного забезпечення почав паралельно працювати над спрощеною
16-бітним набором символів під назвою "Юнікод". Обґрунтуванням Юнікоду було те, що

він кодував би абстрактні символи, а не гліфи, і тому 65 536 було б достатньо.
На практиці, однак, Юнікод кодує гліфи, і невдовзі після
після його появи стало очевидно, що 65 536 кодових точок буде недостатньо
недостатньо. Щоб протистояти цьому, пізніші версії Юнікоду були розширені кількома
"площинами" і спеціальними кодами, які вибирають площину. Поєднання
площини та вказівника коду всередині цієї площини називається "сурогатною парою".

---

###### † Якщо Юнікод кодує символи, то "шрифт Юнікоду" є протиріччям in terminis - оскільки шрифт кодує гліфи.

---

Перші 65 536 кодових точок знаходяться у "Базовій багатомовній площині" (BMP) і
символи у цьому наборі не потребують перемикача площини.

По суті, введення сурогатних пар у стандарті Unicode
еквівалентно зсувним кодам більш ранніх наборів символів - і це несе в собі деякі з
проблем, які Юнікод мав на меті вирішити. Кодування UCS-4 за стандартом
ISO/IEC 10646 не має/потребує сурогатних пар.

Підтримка Unicode/UCS-4 у (хост) програмах та операційних системах
з'явилася двома різними способами: або внутрішнє представлення символів
є багатобайтовим (зазвичай 16-бітним або 2-байтовим), або програма зберігає рядки
у форматі UTF-8, і ці рядки перетворюються у відповідні гліфи
лише під час відображення або друку. Останні версії Microsoft Windows
використовують Unicode всередині; операційна система Plan-9 стала першопрохідцем у кодуванні UTF-8, який зараз широко використовується у всьому світі.
кодування UTF-8, який зараз широко використовується у Unix/Linux. Перевага
перевагою кодування UTF-8 як внутрішнього представлення є те, що це фізично 8-бітне кодування
8-бітним кодуванням, а отже, сумісним майже з усіма існуючими базами даних, файловими форматами і бібліотеками.
форматами і бібліотеками. Це дозволяє уникнути необхідності у подвійних точках входу для
функцій, які приймають рядкові параметри - як у випадку з Microsoft Windows,
де багато функцій існує у версії "A "nsi та "W "ide. Недоліком UTF-8 є те, що
є те, що це кодування змінної довжини, і багато операцій з рядками у пам'яті
тому багато операцій з рядками у пам'яті є незграбними (і неефективними). Тим не менш, з появою
появою сурогатних пар, Юнікод також став кодуванням змінної довжини
кодуванням змінної довжини.

Мова PAWN вимагає, щоб назви ключових слів та символів були у кодуванні ascii,
і допускає використання у рядках символів не у кодуванні ascii. Існує п'ять способів, якими хост-додаток
може підтримувати не-ascii символи у рядках та символьних
символів у рядках і літералах:

1 Підтримка кодових сторінок: у цій стратегії вся складність вибору
правильних гліфів і шрифтів делегується хост-додатку. Підтримка кодових сторінок
базується на файлах зіставлення кодових сторінок у форматі "перехресних таблиць зіставлення", що поширюються
таблиць відображення", що розповсюджуються консорціумом Unicode.

2 Підтримуйте Unicode або UCS-4 і дозвольте компілятору PAWN конвертувати скрипти, які
були написані з використанням кодової сторінки, у "широкі" символи: для цієї стратегії вам потрібно
потрібно задати #pragma кодову сторінку або скористатися еквівалентною опцією компілятора. Компілятор
компілятор буде коректно перекладати символи лише у нерозпакованих рядках.

3 Підтримувати Unicode або UCS-4 і дозволити компілятору PAWN конвертувати скрипти, закодовані
у кодуванні UTF-8 у "широкі" символи: коли вихідний файл для компілятора PAWN
у кодуванні UTF-8, компілятор розширює символи до Unicode/UCS-4 у розпакованих рядках.

4 Підтримуйте кодування UTF-8 внутрішньо (у хост-додатку) і запишіть вихідний файл
вихідний файл у кодуванні UTF-8: тепер усі рядки мають бути упакованими рядками, щоб компілятор не
компілятору конвертувати їх.

Для більшості стратегій інтернаціоналізації, як ви можете бачити, хост-додаток
має підтримувати Unicode або UCS-4. Зауважимо, що компілятор PAWN не
генерує сурогатні пари Unicode. Якщо потрібні символи за межами BMP

і хост-додаток (або операційна система) не підтримує повне кодування UCS-4
кодування, хост-програма повинна розділити 32-бітну комірку символів, надану
компілятором PAWN на сурогатну пару.

Компілятор PAWN приймає вихідний файл як текстовий файл у кодуванні UTF-8 - див.
сторінку 168. Якщо вихідний файл у кодуванні UTF-8, "широкі" символи у
розпакованому рядку зберігаються у вигляді багатобайтових символів Unicode/UCS-4; широкі
символи в упакованому рядку залишаються у кодуванні UTF-8. Щоб записати
вихідних файлів у кодуванні UTF-8, вам, звісно, потрібен редактор (програмістський)
який підтримує UTF-8. Переклад кодової сторінки не застосовується до файлів, які
мають кодування UTF-8.

Для символів Unicode, що зустрічаються у буквеному рядку, альтернативою може бути
використання екранованої послідовності. Оскільки таблиці символів Unicode
зазвичай документуються з шістнадцятковими індексами гліфів, послідовність xhhh;, ймовірно, є
зручнішим способом задання довільного символу Unicode. Наприклад,
ескейп-послідовність "\x2209" означає символ "6∈".

Інтернаціоналізація - це набагато більше, ніж просто базова підтримка розширених
розширених наборів символів, як-от форматування полів дати і часу, порядок читання
(зліва направо або справа наліво) та локалізований переклад системних повідомлень. Інструментарій
PAWN делегує ці питання хостовій програмі.

### - Робота з тегами

Система імен тегів була винайдена для того, щоб додати до PAWN механізм "перевірки використання".
Тег позначає "призначення" значення або змінної, і компілятор PAWN
видає діагностичне повідомлення, коли тег виразу не збігається з тегом
необхідному тегу для контексту виразу.

Багато сучасних комп'ютерних мов пропонують типи змінних, де тип визначає
розташування пам'яті та призначення змінної. Мова програмування

потім перевіряє еквівалентність типів; мова паскаль дуже сувора у перевірці
рівності типів, тоді як мова програмування C є більш поблажливою. У мові
PAWN не має типів: усі змінні мають розмір і розташування
комірки, хоча представлення бітів у комірці може залежати від призначення
змінної. Підводячи підсумок:

- тип визначає розміщення пам'яті та діапазон змінних і результатів функцій

- tagname позначає призначення змінних, констант і результатів функцій

Теги в PAWN здебільшого необов'язкові. Програма, яка була "укріплена" тегом
в оголошеннях змінних і констант, працюватиме однаково, коли
прибрати всі імена тегів. Виняток становлять визначені користувачем оператори:
компілятор PAWN використовує теги операндів для вибору між будь-якими визначеними користувачем операторами
визначеними користувачем операторами та стандартним оператором.

У фрагменті нижче оголошено три змінні та виконано три присвоєння, два з яких
з яких видають діагностичне повідомлення "невідповідність тегів":

Лістинг: порівнюємо яблука з апельсинами

```c

new apple:elstar /* змінна "elstar" з тегом "apple" */
new orange:valencia /* змінна "valencia" з тегом "orange" */
new x /* змінна "x" без тегу */

elstar = valencia /* невідповідність тегу */
elstar = x /* невідповідність тегу */
x = valencia /* ok */

```

Перше присвоєння викликає діагностику "невідповідності тегів", оскільки воно присвоює змінній з тегом "or-
ange" змінній зі змінною з тегом "apple". Друге присвоювання
поміщає значення x без тегів у змінну з тегами, що знову ж таки призводить до ди
агностику. Коли немічена змінна знаходиться у лівій частині оператора присвоювання
як у третьому привласненні, не видається жодних попереджень або повідомлень про помилки. Оскільки
змінна x є неміченою, вона може приймати значення будь-якої слабкої мітки.

Той самий механізм застосовується до передачі змінних або виразів у функції
як операнди функції - приклад наведено на сторінці 78. Коротше кажучи, коли функція
очікує певну назву тегу в якості аргументу, ви повинні передати вираз/
змінну з відповідною міткою до цієї функції; але якщо функція очікує на аргумент без мітки
аргумент без тегів, ви можете передавати аргументи з будь-якими слабкими тегами.

Іноді необхідно тимчасово змінити тег виразу.
Наприклад, з оголошеннями попереднього фрагмента коду, якщо ви
хочете порівняти яблука з апельсинами (нещодавні дослідження показують, що порівняння
яблука з апельсинами не є настільки абсурдним, як прийнято вважати), ви можете скористатися:

```c

if (apple:valencia < elstar)
    valencia = orange:elstar

```

Тестовий вираз інструкції if (у дужках) порівнює змінну
змінну valencia зі змінною elstar. Щоб уникнути діагнозу "невідповідність тегів"
"невідповідності тегів", він ставить перевизначення тегу apple: на valencia -після цього, вирази в лівій руці оператора
у лівій та правій частинах оператора > мають однаковий тег
ім'я: "apple:". Другий рядок, призначення elstar для valencia, перевизначає
ім'я тегу elstar або orange: перед присвоєнням. У призначенні
ви не можете перевизначити ім'я тегу призначення, тобто ліву частину оператора
оператора =. Помилково писати "apple:valencia = elstar". В інструкції as-
valencia є "l-значенням", і ви не можете перевизначити ім'я тегу l-значення
lvalue.

Як було показано раніше, якщо у лівій частині присвоювання міститься змінна
нерозмічена змінна, вираз у правій частині може мати будь-яке ім'я слабкої мітки. Коли
використовується як l-значення, немаркована змінна сумісна з усіма іменами слабких тегів.
Точніше, слабкий тег ігнорується, коли його присвоюється нерозміченій змінній або коли вона передається
змінній або коли вона передається у функцію, яка очікує на немічений аргумент.
Якщо ім'я тегу вказує на бітову структуру комірки, пропущення слабкого тегу
може приховати помилки. Наприклад, у фрагменті нижче є помилка, яка не є
одразу не помітна:

Лістинг: поганий спосіб використання тегів

```c

#pragma rational float

новий ліміт = -5.0
нове значення = -1.0

if (value < limit)
    printf("Значення %f нижче межі %f\n", value, limit)
else
    printf("Значення вище межі\n")

```

Через "#pragma rational" всі раціональні числа отримують тег "float"
і ці числа кодуються у 4-байтовому форматі IEEE 754. Фрагмент
оголошує дві змінні, limit і value, обидві з яких не мають тегів
(це і є помилка). Хоча літеральні значення -5.0 і -1.0 неявно
неявно позначені тегом float:, цей слабкий тег не помічається, коли значення
присвоюються нерозміченим символам limit і value. Тепер, інструкція if
порівнює value з limit як цілі числа, використовуючи вбудований стандартний оператор <
(для порівняння двох значень у кодуванні IEEE 754 краще використовувати оператор, визначений користувачем).
значень у кодуванні IEEE 754). При виконанні цей фрагмент коду повідомляє нам, що "Значення -1.000000
нижче межі -5.000000" - що, звісно, невірно.

Щоб такі тонкі помилки не залишилися непоміченими, слід використовувати сильні теги. A
сильний тег - це просто назва тегу, яка починається з великої літери, наприклад
наприклад, Float: замість float:. Сильна мітка ніколи не "відкидається" автоматично,
але його все ще можна явно перевизначити. Нижче наведено змінений фрагмент коду
із запропонованими адаптаціями:

Лістинг: сильні теги безпечніші

```c

#pragma rational Float

new Float:limit = -5.0
new Float:value = -1.0

if (value < limit)
    printf("Значення %f нижче межі %f\n", _:value, _:limit)
інакше
    printf("Значення вище межі\n")

```

Забуття імені тегу Float: в оголошенні змінних
limit або value негайно призводить до діагностики "невідповідності тегів", оскільки літерал
значення -5.0 і -1.0 тепер мають сильне ім'я тегу.

printf - це функція загального призначення, яка може друкувати рядки та значення у
різних форматах. Щоб бути універсальною, printf приймає аргументи з будь-яким слабким тегом
name, наприклад, apple:, orange: або будь-яким іншим. Функція printf
приймає аргументи без тегів - слабкі теги відкидаються, коли очікується аргумент
якщо очікується аргумент без тегів. Однак, сильні мітки ніколи не відкидаються, і
у вищенаведеному фрагменті (який використовує оригінальне визначення printf), мені
потрібно було замінити порожній тег "\_:" перед змінними value і limit у
першого виклику printf.

Існує альтернатива вилученню тегів у виразах із сильними іменами тегів у функціях загального призначення
функціях загального призначення: скоригуйте визначення функції так, щоб вона приймала як
всі слабкі мітки, так і вибірковий набір сильних імен міток. Мова PAWN підтримує
декілька імен тегів для кожного аргументу функції. Початкове визначення функції printf (з файлу console.inc) має такий вигляд:

```c

native printf(const format[], ...);

```

Додавши як тег Float:, так і порожній тег перед еліпсом ("..."),
printf прийматиме аргументи з назвою тегу Float:, аргументи без
і аргументи, які мають слабку назву тегу. Щоб вказати множину імен тегів
візьміть усі назви тегів без останньої двокрапки між дужками і комою, що розділяє назви тегів
з комою, що розділяє імена тегів (див. приклад нижче). Для цього необхідно
додати порожню специфікацію тегу до списку назв тегів, оскільки printf
прийматиме лише аргументи з назвою тегу типу Float:. Нижче наведено нове
визначення функції printf:

```c

native printf(const format[], {Float, \_}: ...);

```

Множинні теги дозволяють написати одну функцію, яка приймає комірки з попередньо визначеною підмножиною тегів.
чітко визначеною підмножиною тегів (сильних та/або слабких). Хоча аргумент функції
може приймати фактичні аргументи з різними тегами, змінна може
може мати лише один тег - і формальний аргумент функції є локальною змінною у
у тілі функції. За наявності множинних тегів формальний аргумент функції
аргумент формальної функції отримує тег, який вказано першим.

Іноді вам може знадобитися перевірити, який тег має фактичний аргумент функції
якщо аргумент приймає множинні теги. Перевірка тегу формального
аргументу (у тілі функції) не має сенсу, оскільки він завжди матиме перший тег у списку тегів
матиме перший тег у списку тегів в оголошенні аргументу функції.
Ви можете перевірити тег фактичного аргументу, додавши до функції додатковий аргумент
до функції і встановити його значення за замовчуванням як "tagof" відповідного аргументу
про який йде мова. Подібно до оператора sizeof, оператор tagof має особливе
значення, коли він застосовується у значенні за замовчуванням
аргументу функції: вираз обчислюється у точці виклику функції,
а не у місці визначення функції.
Це означає, що "значенням за замовчуванням" аргументу функції є
фактичний тег параметра, переданого у функцію.

У тілі функції ви можете порівняти тег з відомими тегами за,
знову ж таки, за допомогою оператора tagof.

### - Об'єднання рядків

PAWN - мова вільного формату, але директиви синтаксичного аналізатора повинні бути в одному рядку.
Рядки також не можуть займати більше одного рядка. Якщо це незручно,
ви можете використати символ зворотної косої риски ("\") у кінці рядка, щоб "склеїти" цей
рядок з наступним рядком.

Наприклад:

```c

#define max_path max_drivename + max_directorystring + \
                    max_filename + max_extension

```

Ви також можете використовувати символ конкатенації, щоб розрізати довгі літерні рядки на
декілька рядків. Зауважте, що символ "\" поглинає усі пропуски після нього
і пробіли перед ним на наступному рядку. У наведеному нижче прикладі надруковано "Hello
world" з одним пропуском між двома словами (оскільки між
"Hello" і зворотною косою рискою):

```c

print("Hello \
      world")

```

### - програма, яка генерує власний вихідний код

Дивним, дещо академічним критерієм для кількісної оцінки "виразності" мови програмування є розмір найменшої програми, яка
мови програмування є розмір найменшої програми, яка після виконання повторно генерує власний вихідний код.
генерує власний вихідний код. Обґрунтування цього критерію
полягає в тому, що чим коротша самогенеруюча програма, тим гнучкішою та виразнішою має бути
мова повинна бути гнучкішою та виразнішою. Програми такого типу були створені для багатьох мов програмування - іноді несподівано
мов програмування - іноді напрочуд малих, як для мов, що мають вбудовані рефлексивні можливості.
вбудовані рефлексивні можливості.

Самогенеруючі програми називаються "квінами", на честь філософа Вілларда Ван Ормана Куайна.
філософа Вілларда Ван Ормана Куайна, який писав фрази природною мовою, що самостворюються.
Роботи Ван Ормана Куайна стали широко відомими завдяки книгам "G¨odel,
Ешер, Бах" та "Метамагічні теми" Дугласа Гофстедтера.

У прикладі нижче наведено квін PAWN; він змодельований за зразком відомого квіну "C"
quine (яких існує безліч варіацій). Маючи 77 символів, вона є однією з
найменших версій для класу імперативних мов програмування, і
розмір можна зменшити до 73 символів, видаливши чотири символи "пробілу", які
які були залишені для зручності читання.

Лістинг: quine.p

```c

    new s[]="new s[]=%c%s%c; main() printf s,34,s,34"; main() printf s,34,s,34

```

---

`Дивіться окрему примітку щодо запропонованих власних функцій, які працюють як з упакованими, так і з неупакованими рядками`

`EOS: попередньо визначена константа для позначення кінця рядка; має значення '\0'`.

`Заздалегідь визначені константи: 102`

`Упаковані та розпаковані рядки: 99`

Послідовність втечі: 99`

`Імена тегів: 68

`Користувацькі оператори: 86`

`Більше назв тегів рулить: 68`

`lvalue (визначення ~): 104`

Директиви: 77`

Директиви: 117`

---

[Повернутися до змісту](00-Contents.md)


