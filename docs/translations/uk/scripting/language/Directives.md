---
title: "Ключові слова: Директиви"
---

Директиви - це вказівки, які передаються компілятору для керування інтерпретацією вашого вихідного коду.

## "Стверджую

Перевіряється, чи константний вираз істинний, і якщо ні, то компіляція зупиняється.

```c
#define MOO 10
#assert MOO > 5
```

Це буде скомпільовано добре.

```c
#define MOO 1
#assert MOO > 5
```

Це не допоможе і призведе до фатальної помилки. Це схоже на:

```c
#визначити MOO 1
#if MOO <= 5
    #error Перевірка MOO не вдалася
#endif
```

Однак стверджувати дасть похибку:

```
Твердження не виконано: 1 > 5
```

Тоді як другий дасть похибку в розмірі:

```
Помилка користувача: Не вдалося виконати перевірку му
```

Що може бути корисним, а може й ні.

## "Визначити

`#define` - це директива заміни тексту, де б не знаходився перший символ дефініції, там буде розміщено решту.

```c
#визначити MOO 7
printf("%d", MOO);
```

Буде змінено на:

```c
printf("%d", 7);
```

Ось чому всі визначення втрачаються при декомпіляції, оскільки вони не існують під час компіляції коду (всі директиви попередньо обробляються). Визначення не обов'язково повинні містити числа:

```c
#define PL new i = 0; i < MAX_PLAYERS; i++) if (IsPlayerConnected(i)

for(PL) printf("%d підключено", i);
```

Компілюватиметься до циклу програвача, який ми всі знаємо і любимо (зневажаємо). Зверніть увагу, як тут використано дужки, деякі з них від for, а деякі від макросу define (заміна).

Ще одним маловідомим фактом про визначення є те, що вони можуть бути багаторядковими, якщо ви переходите на новий рядок. Зазвичай новий рядок завершує визначення, однак наступне є дійсним:

```c
#визначити PL \
        new i = 0; i < MAX_PLAYERS; i++) \
                if (IsPlayerConnected(i)

printf("%d", MOO(6));
```

Буде виведено 42 (ні, не випадкове число). Помітили надмірну кількість дужок у визначенні? Це тому, що визначення є заміною прямого тексту, тому вони будуть скомпільовані як:

```c
printf("%d", ((6) * 7));
```

Це добре, але давайте візьмемо цей приклад:

```c
printf("%d", MOO(5 + 6));
```

Можна було б очікувати, що компіляція виведе 77 ((5 + 6) \* 7) і з дужками так і буде, але без дужок у вас їх немає:

```c
#define MOO(%0) \
        %0 * 7

printf("%d", MOO(5 + 6));
```

Що перетворюється на:

```c
printf("%d", MOO(5 + 6 * 7));
```

Що, зважаючи на порядок виконання операцій, складається як (5 + (6 \* 7)), що дорівнює 47 і є дуже неправильним. Цікавим фактом про параметри є те, що якщо їх занадто багато, то останній параметр - це всі зайві. Так і відбувається:

```c
#define PP(%0,%1) \
        printf(%0, %1)

PP(%s %s %s, "привіт", "привіт", "привіт");
```

Напечатає:

```
Привіт, привіт, привіт.
```

Як `%1` містить "hi", "hello", "hi". Ви також могли помітити використання `#` для перетворення літерала у рядок. Ця функція доступна лише для SA-MP і може бути корисною. Її було додано для того, щоб чіткіше розрізняти параметри.

## Інакше.

`#else` схоже на else, але для #if замість if.

## Якщо ні, то я не знаю, що робити далі.

`#elseif` - це як інакше, якби не #if.

```c
#define MOO 10

#if MOO == 9
        printf("if");
#elseif MOO == 8
        printf("else if");
#else
        printf("else");
#endif
```

## Я не знаю, що робити далі.

Ця директива не вказана у таблиці pawn-lang.pdf, але вона існує. По суті, це вбудований компілятор. Якщо ви знаєте AMX, ви можете використовувати її, щоб вставити опкоди AMX безпосередньо у ваш код. Єдиним обмеженням є те, що він допускає лише один аргумент. Синтаксис: `#emit <опкод> <аргумент>`. <Аргумент> може бути раціональним числом, цілим числом або (локальним чи глобальним) символом (змінні, функції та мітки). Список опкодів та їх значення можна знайти у Pawn Toolkit ver. 3664.

## `#endif`

`#endif` подібний до закриваючої дужки для if. У #if не використовуються дужки, все умовно додається до відповідного #endif.

## `#endinput, #endscript`

Це зупиняє включення одного файлу.

## Помилка.

Це миттєво зупиняє компілятор і видає спеціальне повідомлення про помилку. Дивіться приклад #assert.

## "Якщо

`#if` - це для пропроцесора, що if - для коду. Звідси ви можете вибрати, що саме компілювати, а що ні. Для прикладу розглянемо наступний код:

```c
#define LIMIT 10

if (LIMIT < 10)
{
    printf("Ліміт занадто низький");
}
```

Це буде скомпільовано як:

```c
if (10 < 10)
{
    printf("Ліміт занадто низький");
}
```

Що, очевидно, ніколи не буде істинним, і компілятор знає це, тому він повідомляє вам про це, видаючи попередження про "константний вираз". Питання в тому, що якщо це ніколи не буде істинним, то який сенс взагалі його включати? Ви можете просто видалити код, але тоді не буде ніяких перевірок, якщо хтось змінить LIMIT і перекомпілює. Ось для чого потрібен #if. На відміну від звичайного if, який видає попередження, якщо вираз є константою, вираз #if ПОВИНЕН бути константою. Отже:

```c
#define LIMIT 10

#if LIMIT < 10
    #error Занадто низький ліміт
#endif
```

Це дозволить перевірити, що ліміт не є занадто малим під час компіляції, і якщо він є замалим, то буде видано помилку під час компіляції, замість того, щоб ви тестували режим, щоб побачити, чи все гаразд. Це також означає, що не буде згенеровано зайвого коду. Зверніть увагу на відсутність дужок, ви можете використовувати їх, і вони можуть знадобитися у більш складних виразах, але вони не є обов'язковими.

Ось ще один приклад:

```c
#define LIMIT 10

if (LIMIT < 10)
{
    printf("Ліміт менше 10");
}
else
{
    printf("Межа дорівнює або перевищує 10");
}
```

Знову ж таки, це постійна перевірка, яка видасть попередження, але обидва роздруківки будуть скомпільовані, коли ми знатимемо, що буде виконано лише одну з них. Використовуючи #if це стає:

```c
#define LIMIT 10

#if LIMIT < 10
    printf("Ліміт менше 10");
#else
    printf("Ліміт дорівнює або перевищує 10");
#endif
```

Таким чином, буде скомпільовано лише той printf, який потрібно, а інший залишиться у вашому коді на випадок зміни LIMIT і перекомпіляції, але не буде включений до коду, оскільки він не потрібен. Цей спосіб також означає, що безглуздий if не буде виконуватися кожного разу, коли виконується ваш код, що завжди добре.

## "Включити

Вона бере весь код з вказаного файлу і вставляє його у ваш код у місці, де знаходиться рядок включення. Існує два типи включень: відносні та системні (я щойно вигадав ці терміни, якщо у вас є кращі, будь ласка, скажіть). Відносні включають використовують подвійні лапки навколо імені файлу і розташовуються відносно поточного файлу, тому:

```c
#include "me.pwn"
```

включатиме файл "me.pwn" з того ж каталогу, що і файл, що включає цей файл. Інший тип, system, включає файл з каталогу "include", який знаходиться або у тому ж каталозі, що і компілятор Pawn, або у батьківському каталозі (шляхи: "include", "../include"):

```c
#include "<me>"
```

Включить файл "me.inc" (зверніть увагу на відсутність розширення, ви можете вказати його, якщо файл не є .p (не .pwn) або .inc) з каталогу pawno/include (за умови, що ви використовуєте pawno).

Обидва ці типи можуть приймати каталоги:

```c
#include "folder/me.pwn"
```

```c
#include <folder/me>
```

Обидва варіанти включатимуть файл, розташований на один каталог нижче від відповідних каталогів за замовчуванням. Якщо файл не існує, компіляція миттєво завершиться невдачею.

## "Прагма

Це одна з найскладніших директив. Вона має ряд опцій для керування роботою вашого скрипта. Приклад налаштування виглядатиме так:

```c
#pragma ctrlchar '$'
```

Це змінює символ екранування з \ на $, тому новий рядок замість "\r\n" (вікна CR-LF) матиме вигляд "$r\$n". Багато з цих параметрів призначено для керування компіляцією amx для вбудованих систем і тому вони обмежують можливості, які на ПК є майже необмеженими, всі вони перелічені у pawn-lang.pdf, але тут наведено лише вибрані з них, що стосуються SA:MP:

| Ім'я, значення, опис.
| ---------- | ----------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| codepage | ім'я/значення | Задає кодову сторінку Unicode, яку слід використовувати для рядків.                                                                                                                                                                                                                                                                                                                           |
| compress | 1/0 | Не підтримується у SA-MP - не намагайтеся його використовувати.                                                                                                                                                                                                                                                                                                                             |
| застарілий символ | Створює попередження у разі використання цього символу, щоб повідомити про наявність кращої версії.                                                                                                                                                                                                                                                                      |
| динамічне значення (зазвичай степінь 2) | Встановлює розмір пам'яті (у комірках), призначеної для стеку та купи. Потрібно, якщо після компіляції ви отримуєте попередження про надмірне використання пам'яті. (Дивна таблиця після рядка про авторські права компілятора)
бібліотека | ім'я бібліотеки | ім'я dll | Вкрай некоректно використовується у SA-MP. Це вказує бібліотеці на отримання власних функцій, визначених у файлі, з якого вона походить. Це не визначає файл **як** бібліотеку.                                                                                                                                                                                                        |
| pack | 1/0 | Поміняти місцями значення !"" і "". Докладнішу інформацію про упаковані рядки наведено у pawn-lang.pdf.                                                                                                                                                                                                                                                                              |
| tabsize | значення | Ще один параметр, який часто використовують не за призначенням. Його слід використовувати для встановлення розміру табуляції, щоб уникнути попереджень компілятора, які є помилковими через взаємозамінне використання пробілів і табуляцій. У SA:MP цей параметр має значення 4, оскільки саме таким є розмір табуляції у pawno. Значення 0 ігнорує всі попередження щодо відступів, але вкрай не рекомендується, оскільки це може призвести до нечитабельного коду. |
| невикористовуваний | символ | Подібно до deprecated, він з'являється після символу, для якого ви хочете витіснити попередження "символ ніколи не використовується". Загалом, найкращим методом для цього є використання запасів, однак це не завжди можливо (наприклад, параметри функції не можуть не компілюватися).                                                                                                      |

### Застаріла.

```c
новий
    gOldVariable = 5;

#pragma deprecated gOldVariable

main() {printf("%d", gOldVariable);}
```

Це призведе до попередження про те, що gOldVariable більше не слід використовувати. Це здебільшого корисно для функцій, які зберігають зворотну сумісність при оновленні API.

### `#tryinclude``

Це схоже на #include, але якщо файл не існує, компіляція не завершиться невдачею. Це корисно для включення функцій у ваш скрипт, якщо у користувача встановлений правильний плагін (або, принаймні, плагін include):

**myinc.inc**.

```c
#if визначено _MY_INC_INC
    #endinput
#endif
#визначити _MY_INC_INC

stock MyIncFunc() {printf("Hello");}
```

**Gamemode:**

```c
#tryinclude <myinc>

main()
{
    #if визначено _MY_INC_INC
        MyIncFunc();
    #endif
}
```

Це призведе до виклику MyIncFunc лише у тому випадку, якщо файл з ним було знайдено і скомпільовано. Це, як зазначалося раніше, добре підходить для таких речей, як плагіни IRC, щоб перевірити, чи вони дійсно мають цей плагін.

### Не знаю.

Видаляє попередньо визначений макрос або символ константи.

```c
#визначити MOO 10
printf("%d", MOO);
#undef MOO
printf("%d", MOO);
```

Він не скомпілюється, оскільки MOO більше не існує на момент досягнення другого printf.

```c
enum {
    e_example = 300
};

printf("%d", e_example);
#undef e_example
printf("%d", e_example); // фатальна помилка
```


