---
назва: "Путівник по пішаковому стилю"
description: Короткий посібник із загальноприйнятих угод щодо іменування та інших аспектів вихідного коду Pawn, щоб полегшити спілкування про наміри та спростити налагодження і спільне використання коду.
---

Цей документ є коротким посібником із загальноприйнятих угод щодо іменування та інших аспектів вихідного коду Pawn, щоб полегшити спілкування про наміри та спростити налагодження і спільне використання коду.

Дивіться також:

- [Сучасний пішак](https://github.com/Southclaws/sampctl/wiki/Modern-Pawn)
- [Pawn Package](https://github.com/Southclaws/sampctl/wiki/Packages)

## Термінологія

### Заява

Оператор - це фрагмент коду, який імперативно наказує головній програмі щось зробити. Оператор - це дійсний фрагмент коду, який дає певний результат.

```c
a = b + c;
```

Це оператор, що складається зі змінної, якій присвоюється результат [#Вираз].

```c
SetPlayerColor(playerid, 0xFF4700FF);
```

Це інструкція, яка вказує програмі викликати функцію з деякими аргументами.

```c
x + 8
```

Це _не_ оператор, оскільки результат ніде не використовується, це просто [#Вираз].

### Складений оператор

Складений оператор - це набір операторів, оточених фігурними дужками.

```c
{
    new message[] = "hi!";
    print(message);
}
```

Це складений оператор, що складається з двох операторів.

```c
if (a == b)
{
    print("hello!");
}
```

Це складений оператор з умовою `if`, який зазвичай називають "оператором if".

```c
return Function1(), Function2(), Function3();
```

Це _не_ складний оператор, а ланцюжок операторів, розділених комами. Така форма ланцюжка операторів вважається поганою практикою.

### Вираз

Вираз - це частина синтаксису, яка повертає значення, він не є дійсним оператором, якщо отримане значення не використовується якимось чином.

Вирази часто складаються для формування тверджень.

```c
a + b
```

Це простий вираз додавання, який приймає два значення і застосовує до них оператор додавання.

## Вказівки

### Брекети.

Перевага надається брекетам Allman:

```пішак
функція()
{
    //
}
```

Однак, якщо м'язову пам'ять не вдається струснути, брекети K&R також є дійсним пішаком:

пішак
function() {
    //
}
```

### Перемикачі

Перемикачі повинні використовувати два рівні відступів: один для блоку switch і другий для кожного оператора case або складеного оператора.

```пішак
switch (змінна)
{
    case 0:
        повернути 0;
    case 1:
        повернути 1;
    case 2:
        повернути 2;
    за замовчуванням:
        повернути -1;
}
```

```пішак
switch (змінна)
{
    case 0
    {
        // код...
        return 0;
    }
    case 1
    {
        // код...
        return 1;
    }
    case 2
    {
        // код...
        return 2;
    }
    default:
    {
        // код...
        return -1;
    }
}
```

### Складені оператори (блоки)

Блоки завжди повинні використовувати фігурні дужки, навіть якщо в блоці є лише один рядок коду. Це стосується всіх рівнів, включаючи функції.

пішак
func()
{
    singleLineExpr();
}
```

пішак
func()
{
    if ()
    {
        singleLineExpr();
    }
}
```

пішак
func()
{
    if ()
    {
        singleLineExpr();
    }
    else if ()
    {
        //
    }
    else
    {
        //
    }
}
```

### Іменування

#### Функції

Функції повинні бути названі з використанням регістру `PascalCase`.

#### Глобальні змінні

Глобальні змінні, оголошені з використанням `new`, завжди повинні використовувати `g_` префікс PascalCase, тобто `g_VariableName`, однак якщо вони оголошені з використанням `static`, вони завжди повинні використовувати `_` префікс PascalCase, тобто `_VariableName`.

Константні глобали повинні використовувати `SCREAMING_SNAKE_CASE`.

#### Локальні змінні

Локальні змінні завжди повинні використовувати `camelCase` і ніколи не повинні використовувати однолітерні імена, крім:

- `i`, `j`, `k` і т.д. у циклах for
- `x`, `y`, `z` тощо в математичних контекстах

#### Переписувачі

Перелічувачі, якщо вони названі, повинні мати префікс `E_` (сильний тег) або `e_` (слабкий тег)

Поля перелічувачів також мають бути `SCREAMING_SNAKE_CASE` і використовувати ім'я перелічувача як префікс.

пішак
static enum E_PLAYER_DATA {
    E_PLAYER_CASH,
    Float:E_PLAYER_HEALTH,
}
```

Використання слабкого тегу

пішак
static enum e_PLAYER_DATA {
    E_PLAYER_CASH,
    Float:E_PLAYER_HEALTH,
}
```

Неіменовані поля-зчислювачі також мають бути `SCREAMING_SNAKE_CASE` і використовувати ім'я зчислювача як префікс.

пішак
static enum {
    ENUMATOR_INTEGER,
    Float:ENUMATOR_FLOAT,
}
```

Перелічувачі завжди мають бути оголошені як `статичні`, якщо вони не використовуються за межами модуля.

#### Макроси та визначення препроцесора

Макроси завжди повинні використовувати `SCREAMING_SNAKE_CASE` незалежно від їхнього використання.

Визначення препроцесора (визначення констант) також повинні використовувати `SCREAMING_SNAKE_CASE`.

Це допомагає розрізняти змінні та константи, а також функції та макроси.

Загалом рекомендується уникати винайдення нових синтаксичних елементів, щоб запобігти плутанині серед новачків щодо того, які слова є частиною мови, а які - з бібліотек.

Однак деякі старі бібліотеки роблять це і не можуть змінитися через зворотну сумісність.

### Документація

Завжди документуйте експортовані функції простим рядковим коментарем у форматі `// FunctionName does X, Y and Z and returns A`, де перше слово - це назва самої функції, за яким слідує короткий опис того, що вона робить. Не потрібно витрачати час на опис кожного окремого параметра. Наприклад:

```пішак
// LoadPlayerAccount викликається для ініціювання процесу завантаження акаунта. Ця
// функція буде ініціювати HTTP-дзвінки для отримання даних гравця, показуватиме діалоги
// гравцеві і, врешті-решт, після завершення процесу, подія
// `OnPlayerLogin` буде згенеровано у разі успіху. У разі невдачі гравця буде викинуто.
stock Error:LoadPlayerAccount(playerid)
{
    // код...
}
```

Кожен пакунок повинен мати `README` і, якщо необхідно, кожен модуль повинен мати коментар у першому рядку з описом того, що надає цей модуль.


