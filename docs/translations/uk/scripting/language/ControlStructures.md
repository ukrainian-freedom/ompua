---
назва: "Структури управління"
description: Огляд керуючих структур у мові Pawn
---

## Умовні позначення

### Якщо

Оператор if перевіряє, чи є щось істинним, і виконує певні дії, якщо це так.

```c
новий
    a = 5;
if (a == 5)
{
    print("a дорівнює 5");
}
```

Код у дужках після "if" називається умовою, і ви можете перевіряти різні речі (див. оператори).

У наведеному вище прикладі і "a", і 5 є символами, функції також можуть бути символами:

```c
if (SomeFunction() == 5)
{
    print("SomeFunction() дорівнює 5");
}
```

Це перевірить значення, що повертається функцією SomeFunction (див. нижче), на 5.

Ви також можете комбінувати перевірки, щоб перевірити кілька речей:

```c
новий
    a = 5,
    b = 3;
if (a == 5 && b != 3)
{
    print("Не буде виведено");
}
```

У цьому прикладі перевіряється, що a дорівнює 5, а b не дорівнює 3, але b дорівнює 3, тому перевірка не спрацьовує.

```c
новий
    a = 5,
    b = 3;
if (a == 5 || b != 3)
{
    print("Буде виведено");
}
```

У цьому прикладі перевіряється, що a дорівнює 5 АБО b не дорівнює 3, b дорівнює 3, так що частина помилкова\* однак a дорівнює 5, так що частина істинна, ми використовуємо || (або), тому тільки одна частина повинна бути істинною (якщо обидві частини істинні, твердження все одно істинне, це трохи відрізняється від лінгвістичного значення "або", що означає тільки одне або інше), так що оператор if істинний.

Також можна об'єднати порівняння в ланцюжок без явного І-об'єднання двох різних порівнянь.

```c
новий
    idx = 3;

if (0 < idx < 5)
{
    print("idx більше 0 і менше 5!")
}
```

### Оператори

Нижче наведені символи, які ви можете використовувати в порівняннях та їх поясненнях. Деякі з них вже використовувалися в прикладах.

| Оператор. Значення. Використання.
| ------------ | ----------------------------------------------------------------- | ------------------------------------------------------------ |
| if (Left == Right) == Лівий дорівнює правому if (Left == Right) == Лівий дорівнює правому
| Лівий не дорівнює правому if (Лівий != Правий)
| > | Лівий більший за правий | if (Left > Right) | ¦ ¦ == | Лівий більший за правий | if (Left > Right)
| >= | Лівий більший або рівний правому | if (Left >= Right) | ¦ ¦ ¦Лівий більший або рівний правому | if (Left >= Right) | ¦ ¦ ¦Ліва
| < | Лівий менший за правий | if (Left < Right) | ¦ <= | Лівий менший за правий | if (Left < Right)
| <= | Лівий менше або дорівнює правому | if (Лівий <= Правий) | | && | та | if (Лівий <= Правий)

або | if (Left &#124;&#124; Right) | або | if (Left &#124;&#124; Right) | !
| !            | не if (!Змінна)
| ні if (!(Left &#124;&#124; Right))                              |
| ні та ні if (!(Left && Right))                                        |
| виключне або (xor, eor) - істинно тільки одне або інше, а не обидва | if (!(Left && Right) && (Left &#124;&#124;Right))            |
| не виключне або (nxor, neor) - істинно або одне, або інше | if ((Left && Right) &#124;&#124; !(Left &#124;&#124; Right)) |

### Дужки

Інший важливий аспект інструкцій if - це дужки, вони керують порядком виконання дій:

```c
новий
    a = 3,
    b = 3,
    c = 1;
if (a == 5 && b == 3 || c == 1)
{
    print("Чи буде це викликано?");
}
```

Існує два способи поглянути на наведене вище твердження:

```c
if ((a == 5 && b == 3) || c == 1)
```

І:

```c
if (a == 5 && (b == 3 || c == 1))
```

Перша версія перевіряє, чи a дорівнює 5 і b дорівнює 3, якщо це не так (тобто одне або обидва значення не є відповідними), вона перевіряє, чи c дорівнює 1. (a == 5 && b == 3) є хибним, як ви повинні знати з вищесказаного, тому ви замінюєте цю групу на FALSE:

```c
if (FALSE || c == 1)
```

Ми знаємо, що FALSE не може бути істинним (оскільки воно не є істинним за визначенням), однак c дорівнює 1, тому половина істинна, а оскільки ми використовуємо АБО між ними, то все твердження є істинним.

У другій версії перевіряється, чи дорівнює a 5, і якщо так, то перевіряється, чи b дорівнює 3 або c дорівнює 1. Гра спочатку виконає частину a == 5, але для наочності ми зробимо це у зворотному порядку. (b == 3 || c == 1) істинно, обидві половини істинні, хоча повинна бути тільки одна, тому переходимо до нашого оператора if:

```c
if (a == 5 && TRUE)
```

(a == 5) хибна, оскільки a дорівнює 3, тому маємо:

```c
if (FALSE && TRUE)
```

Очевидно, що FALSE є хибним, тому твердження не може бути істинним, тому перевірка не спрацює.

Цей невеликий приклад показує, як використання дужок може змінити результат перевірки, без дужок компілятор отримає першу з двох продемонстрованих версій, але це не завжди можна гарантувати, тому ви завжди повинні використовувати дужки, навіть якщо ви просто пояснюєте, що відбувається, іншим людям.

- (b != 3) у прикладі АБО насправді не зазнає невдачі, оскільки вона ніколи не викликається, компілятор впорядковує код, використовуючи таку річ, як замикання, оскільки перша частина вже істинна, немає сенсу перевіряти другу частину, оскільки вона не вплине на кінцевий результат, але якби він перевірив її, то зазнав би невдачі.

### Інакше

else в основному виконує щось, якщо перевірка if не спрацьовує:

```c
новий
    a = 5;
if (a == 3) // False
{
    print("Не буде викликано");
}
else
{
    print("Буде викликано, оскільки перевірка не пройшла")
}
```

### else if

Інший if - це перевірка, яка відбувається, якщо перша перевірка if не змогла перевірити щось інше:

```c
новий
    a = 5;
if (a == 1)
{
    print("Буде викликано, якщо a дорівнює 1");
}
else if (a == 5)
{
    print("Буде викликано, якщо a дорівнює 5");
}
else
{
    print("Усі інші числа");
}
```

Ви можете мати стільки чеків, скільки хочете (ви можете мати тільки один якщо і ще один в групі чеків):

```c
новий
    a = 4;
if (a == 1)
{
    // False
}
else if (a == 2)
{
    // False
}
else if (a == 3)
{
    // False
}
else if (a == 4)
{
    // True
}
else
{
    // False
}
```

else ifs перевірить значення лише таким, яким воно було на момент запуску ifs, що ви не можете зробити:

```c
новий
    a = 5;
if (a == 5)
{
    // Буде викликано
    a = 4;
}
else if (a == 4)
{
    // Не буде викликано, тому що перша перевірка не завершилась невдачею, хоча a тепер 4
}
```

Щоб обійти цю проблему, ви можете просто додати else if до if.

### ?:

'?' і ':' разом називаються тріадичним оператором, вони діють як оператор if всередині іншого оператора:

```c
новий
    a,
    b = 3;
if (b == 3)
{
    a = 5;
}
else
{
    a = 7;
}
```

Це простий приклад присвоювання змінної на основі іншої змінної, але його можна зробити набагато коротшим:

```c
новий
    a,
    b = 3;
a = (b == 3) ? (5) : (7);
```

Частина перед символом '?' - це умова, вона точно така ж, як і звичайна умова. Частина між '?' і ':' - це значення, яке повертається, якщо умова істинна, інша частина - це значення, яке повертається, якщо умова хибна. Ви можете складати їх так само, як і інші if:

```c
новий
    a,
    b = 3;
if (b == 1)
{
    a = 2;
}
else if (b == 2)
{
    a = 3;
}
else if (b == 3)
{
    a = 4;
}
else
{
    a = 5;
}
```

Можна записати як:

```c
новий
    a,
    b = 3;
a = (b == 1) ? (2) : ((b == 2) ? (3) : ((b == 3) ? (4) : (5)));
```

Насправді, це більше схоже на роботу:

```c
новий
    a,
    b = 3;
if (b == 1)
{
    a = 2;
}
else
{
    if (b == 2)
    {
        a = 3;
    }
    else
    {
        if (b == 3)
        {
            a = 4;
        }
        else
        {
            a = 5;
        }
    }
}
```

Але вони еквівалентні (принаймні, в цьому прикладі).

## Петлі

### Поки

Цикли "while" виконують щось, доки вказана умова є істинною. Умова має такий самий формат, як і умова в операторі if, просто вона перевіряється багаторазово, і код виконується, якщо вона істинна, кожного разу, коли вона перевіряється:

```c
новий
    a = 9;
while (a < 10)
{
    // Код у циклі
    a++;
}
// Код після циклу
```

Цей код перевірить, чи 'a' менше 10. Якщо так, то буде виконано код всередині дужок (a++;), який збільшить 'a'. Коли буде досягнуто закриваючу дужку, виконання коду повернеться до перевірки і виконає її знову, цього разу перевірка не вдасться, оскільки 'a' дорівнює 10, і виконання коду перейде на наступний крок після циклу. Якби 'a' починалося з 8, код було б виконано двічі і т.д.

### for()

Цикл for - це, по суті, стислий цикл while. Оператор "for" складається з трьох частин: ініціалізації, умови та завершення. У вигляді циклу "for" можна записати наведений вище приклад з циклом "while":

```c
for (new a = 9; a < 10; a++)
{
    // Код у циклі
}
// Код після циклу
```

Це простий код для циклічного перебору всіх гравців:

```c
for(new i,a = GetMaxPlayers(); i < a; i++)
{
        if (IsPlayerConnected(i))
        {
                 //зробити щось
        }
}
```

Будь-яку з умов можна опустити, просто не вводячи в неї код:

```c
новий
    a = 9;
for ( ; a < 10; )
{
    // Код у циклі
    a++;
}
// Код після циклу
```

Цей приклад трохи полегшує демонстрацію того, як цикл for співвідноситься з циклом while. Існує дві дуже незначні відмінності між двома наведеними циклами "for". Перша полягає в тому, що в другому прикладі змінна 'a' оголошена за межами циклу, це означає, що її можна використовувати за межами циклу, а в першому прикладі область видимості змінної 'a' (ділянка коду, для якої існує змінна) знаходиться тільки всередині циклу. Друга відмінність полягає в тому, що a++ у другому прикладі насправді виконується трохи раніше, ніж a++ у першому прикладі, у 99% випадків це не має ніякого значення, єдиний випадок, коли це має значення - це коли ви використовуєте continue (див. нижче), continue викликає a++ у першому прикладі, але пропускає його у другому прикладі.

### Доки.

Цикл do-while - це цикл, в якому умова з'являється після коду всередині циклу, а не перед ним. Це означає, що код всередині циклу завжди буде виконаний принаймні один раз, оскільки він виконується до того, як буде виконана перевірка:

```c
новий
    a = 10;
do
{
    // Код всередині циклу
    a++;
}
while (a < 10); // Звернути увагу на крапку з комою
// Код після циклу
```

Якби це був стандартний цикл while, a не збільшувався б, оскільки перевірка (a < 10) є хибною, але тут він збільшується перед перевіркою. Якби a починалося з 9, цикл також був би виконаний лише один раз, 8 - двічі і т.д.

### if-goto

Це, по суті, те, до чого компілюються наведені вище цикли, використання goto зазвичай не рекомендується, проте цікаво побачити, що саме робить цикл:

```c
новий
    a = 9;

loop_start:
if (a < 10)
{
    // Код у циклі
    a++;
    goto loop_start;
}
// Код після циклу
```

### OBOE

OBOE розшифровується як Off By One Error. Це дуже поширена помилка, коли цикл виконується на один або два рази більше, ніж потрібно. Наприклад

```c
новий
    a = 0,
    b[10];
while (a <= sizeof (b))
{
    b[a] = 0;
}
```

Цей дуже простий приклад демонструє одну з найпоширеніших помилок OBOE, на перший погляд може здатися, що цикл перегляне весь вміст b і встановить його в 0, проте насправді він виконається 11 разів і спробує отримати доступ до b[10], якого не існує (це буде 11-й слот у b, починаючи з 0), що може спричинити різноманітні проблеми. Це називається помилкою виходу за межі (Out Of Bounds, OOB).

Ви повинні бути особливо обережними з OBOE при використанні циклів, оскільки вони ЗАВЖДИ виконуються принаймні один раз.

## Перемикач

### Перемикач

Оператор switch - це, по суті, структурована система if/else (подібно до того, як for є структурованою системою while). Найпростіший спосіб пояснити це на прикладі:

```c
новий
    a = 5;
switch (a)
{
    case 1
    {
        // Не буде викликано
    }
    case 2:
    {
        // Не буде викликано
    }
    case 5: { // Не буде викликано }
    {
        // Буде викликано
    }
    default:
    {
        // Не буде викликано
    }
}
```

Це функціонально еквівалентно:

```c
новий
    a = 5;
if (a == 1)
{
    // Не буде викликано
}
else if (a == 2)
{
    // Не буде викликано
}
else if (a == 5)
{
    // Буде викликано
}
else
{
    // Не буде викликано
}
```

Однак тепер стало трохи зрозуміліше, що відбувається.

Важливо звернути увагу на різні способи обробки if та switch:

```c
switch (SomeFunction())
{
    case 1: {}
    case 2: {}
    case 3: {}
}
```

Це викличе SomeFunction() ОДИН раз і порівняє його результат 3 рази.

```c
if (SomeFunction() == 1) {}
else if (SomeFunction() == 2) {}
else if (SomeFunction() == 3) {}
```

Це призведе до виклику SomeFunction() тричі, що дуже неефективно, краще використовувати switch:

```c
новий
    result = SomeFunction();
if (result == 1) {}
else if (result == 2) {}
else if (result == 3) {}
```

Для тих з вас, хто знає C, перемикач PAWN дещо відрізняється: окремі умови НЕ є прохідними і обмежуються дужками, тому немає необхідності в операторах break.

### Справа в тому, що

оператори case (частини оператора switch, що містять "case X:") можуть мати інші варіанти, окрім одного числа. Ви можете порівнювати значення зі списком чисел (замінюючи пропуск у C) або навіть з діапазоном значень:

```c
випадок 1, 2, 3, 4:
```

Цей випадок спрацьовує, якщо символ, що перевіряється, дорівнює 1, 2, 3 або 4, це те ж саме, що робити:

```c
if (bla == 1 || bla == 2 || bla == 3 || bla == 4)
```

але набагато лаконічніше. Номери в списках не обов'язково повинні йти підряд, насправді, якщо вони йдуть підряд, це краще:

```c
справа 1 .. 4:
```

У цьому випадку буде виконано те саме, що й у попередньому випадку, але замість списку буде перевірено діапазон:

```c
if (bla >= 1 && bla <= 4)
```

```c
новий
    a = 4;
switch (a)
{
    case 1 .. 3
    {
    }
    case 5, 8, 11:
    {
    }
    case 4:
    {
    }
    default:
    {
    }
}
```

### за замовчуванням

Це еквівалент else в операторах if, він робить щось, якщо всі інші оператори case не спрацювали.

## Однорядкові оператори

### Я йду.

goto - це, по суті, перехід, він переходить до мітки без запитань (тобто немає жодної умови, яка повинна бути істинною). Ви можете побачити приклад вище у циклі if-goto.

```c
goto my_label;

// Цей розділ буде перескочено

my_label: // Мітки закінчуються двокрапкою і знаходяться в окремому рядку

// Цей розділ буде оброблено як звичайно
```

Використання gotos не рекомендується через їхній вплив на потік програми.

### Перерва.

перерва виривається з циклу, передчасно завершуючи його:

```c
for (new a = 0; a < 10; a++)
{
    if (a == 5) break
}
```

Цей цикл буде виконано 6 разів, але код після перерви буде виконано лише 5 разів.

### Продовжуйте.

continue в основному пропускає ітерацію циклу

```c
for (new a = 0; a < 3; a++)
{
    if (a == 1) continue;
    printf("a = %d", a);
}
```

Це дасть на виході

```c
a = 0 a = 2
```

Продовження в основному переходить до закриваючої дужки циклу, як було сказано вище, ви повинні бути обережними, використовуючи продовження з деякими циклами:

```c
новий
    a = 0;
while (a < 3)
{
    if (a == 1) continue;
    printf("a = %d", a);
    a++;
}
```

Це дуже схоже на інший приклад, але цього разу continue пропустить рядок a++;, тому цикл застрягне у нескінченному циклі, оскільки a завжди буде дорівнювати 1.

### Повернись.

return зупиняє функцію і повертається до місця в коді, з якого вона була викликана:

```c
main()
{
    print("1");
    MyFunction(1);
    print("3");
}

MyFunction(num)
{
    if (num == 1)
    {
        return;
    }
    print("2");
}
```

Цей код дасть на виході

1 3

Тому що рядок print("2"); ніколи не буде досягнутий.

Ви також можете використовувати return для повернення значення:

```c
main()
{
    print("1");
    if (MyFunction(1) == 27)
    {
        print("3");
    }
}

MyFunction(num)
{
    if (num == 1)
    {
        return 27;
    }
    print("2");
    return 0;
}
```

Цей код дасть той самий результат, що й наведений вище, однак зверніть увагу, що в кінці функції було додано додаткове повернення. Кінець функції передбачає повернення, однак це повернення не має значення, ви не можете повернути значення і не повернути значення з тієї самої функції, тому ми повинні явно повернути значення.

Символ, який ви повертаєте, може бути числом, змінною або навіть іншою функцією (у цьому випадку інша функція буде викликана, вона поверне значення (вона ПОВИННА повернути значення, якщо ви використовуєте її як значення, що повертається), і це значення буде повернуто з першої функції.

Ви також можете зберігати значення повернення для подальшого використання:

```c
main()
{
    print("1");
    новий
        ret = MyFunction(1);
    if (ret == 27)
    {
        print("3");
    }
}

MyFunction(num)
{
    if (num == 1)
    {
        return 27;
    }
    print("2");
    return 0;
}
```


