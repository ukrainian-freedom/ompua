---
title: "Ключові слова: Statements"
---

## "стверджувати

Перериває виконання з помилкою під час виконання, якщо вираз обчислюється як логічно хибний. Здається, працює тільки у блоці main(). Оператор assert слід використовувати для вказівки на логічну помилку (програміста), а не на помилку під час виконання (користувача).

```c
main()
{
    assert (MAX_PLAYERS == GetMaxPlayers()); // перевірити, що визначення MAX_PLAYERS дорівнює фактичній кількості використовуваних серверних слотів
}
```

## "Брейк

Виривається з циклу миттєво, залишає тільки цикл верхнього рівня, а не всі поточні цикли.

```c
for (new i = 0; i < 10; i++)
{
    printf("%d", i);
    if (i == 5)
    {
        break
    }
}
```

Буде зроблено:

```c
0
1
2
3
4
5
```

Поки що:

```c
for (new i = 0; i < 10; i++)
{
    if (i == 5)
    {
        break;
    }
    printf("%d", i);
}
```

Буде зроблено:

```c
0
1
2
3
4
```

Оскільки вихід з циклу відбувається миттєво, жоден з циклів не доходить до 10, і другий цикл завершується до того, як буде виведено число 5.

## "Справа

Обробляє певний результат в операторі switch. Результатом може бути як одне число, так і вибірка чисел або діапазон чисел:

```c
новий
    switchVar = 10;
switch (switchVar)
{
    case 1
    {
        printf("switchVar дорівнює 1");
    }
    case 4:
    {
        printf("switchVar is 4");
    }
    case 2, 3, 5
    {
        printf("switchVar дорівнює 2, 3 або 5");
    }
    case 7 .. 11
    {
        printf("switchVar знаходиться десь між 7 та 11 включно (7, 8, 9, 10 або 11)");
    }
    default:
    {
        printf("switchVar не дорівнює 1, 2, 3, 4, 5, 7, 8, 9, 10 або 11");
    }
}
```

## Продовжуйте.

Схожа на break, але просто переходить до наступної ітерації циклу. Важливо зазначити, що точка, до якої відбувається перехід, залежить від того, який тип циклу ви використовуєте.

```c
for (new i = 0; i < 10; i++)
{
    if (i == 5)
    {
        продовжити;
    }
    printf("%d", i);
}
```

Буде зроблено:

```c
0
1
2
3
4
6
7
8
9
```

Продовження після виводу на екран нічого не зробить. У циклі for continue переходить на третій оператор в операторі for (у цьому прикладі на біт "i++;"), це відрізняється від того, як він поводиться у циклі while:

```c
новий
    i = 0;
while (i < 10)
{
    if (i == 5)
    {
        продовжити;
    }
    printf("%d", i);
    i++;
}
```

Це призведе до нескінченного циклу, оскільки continue перескочить на місце ПІСЛЯ "i++;" і повернеться до частини "while (i < 10)". У цей час "i" все ще буде дорівнювати 5, оскільки "i++;" ніколи не викликався, тому continue буде викликано знову, і "i" застрягне на рівні 5 назавжди.

## "За замовчуванням

за замовчуванням обробляє результати операторів switch, які не обробляються явно операторами case. Зверніться до прикладу, наведеного у розділі case.

## Зробіть це.

do - це тип циклу, який можна використовувати з while для створення циклу, який завжди виконуватиметься принаймні один раз. Зверніть увагу на крапку з комою після while () у наступному прикладі:

```c
новий
    i = 10;
do
{
    printf("%d", i);
    i++;
}
while (i < 10);
```

"i" явно не менше, ніж 10, але цей цикл дасть результат:

```c
10
```

так чи інакше. Аналогічний цикл while:

```c
новий
    i = 10;
while (i < 10)
{
    printf("%d", i);
    i++;
}
```

} Не дасть жодного результату, оскільки умова миттєво зазнає невдачі.

Вони також корисні для уникнення подвійних перевірок:

```c
новий
    checkVar = 10;
if (checkVar == 10)
{
    новий
        i = 0;
    while (checkVar == 10)
    {
        checkVar = someFunction(i);
        i++;
    }
}
```

Очевидно, що це не є серйозною проблемою, але ви перевіряєте checkVar двічі поспіль на початку циклу, що є досить безглуздим, однак if є необхідним, оскільки вам потрібно виконати код, якщо умова істинна, але за межами циклу (це досить поширена ситуація). Це можна виправити, виконавши такі дії:

```c
новий
    checkVar = 10;
if (checkVar == 10)
{
    новий
        i = 0;
    do
    {
        checkVar = someFunction(i);
        i++;
    }
    while (checkVar == 10);
}
```

У цьому випадку результат буде точно таким же, але, що важливо, з однією менш безглуздою перевіркою.

## "Інакше

else викликається, коли інструкція if зазнає невдачі (за умови, що вона присутня):

```c
новий
    checkVar = 5;
if (checkVar == 10)
{
    printf("This will never be called");
}
else
{
    printf("Оператор if завершився невдало, тому буде виведено це");
}
```

else також можна комбінувати з if:

```c
новий
    checkVar = 2;
if (checkVar == 1)
{
    printf("Ця функція не буде викликана"):
}
else if (checkVar == 2)
{
    printf("Перший if не спрацював, тому було перевірено другий і він є істинним")
}
else
{
    printf("Цей метод не буде викликано, оскільки один з if був істинним"); }
}
```

## Виходьте.

Це миттєвий вихід з поточної програми.

```c
main()
{
    вихід;
    return 0;
}
```

## За те, що

Цикл for - це тип циклу, що складається з трьох етапів: ініціалізації, порівняння та оновлення. Кожна з них розділена крапкою з комою (Wink), і кожну з них можна виключити, просто поставивши пробіл. Найпростіший цикл for має такий вигляд:

```c
for ( ; ; ) {}
```

Він не має ініціалізації, порівняння та оновлення і, як наслідок, буде виконуватися вічно (порівняння, оскільки воно відсутнє, за замовчуванням дорівнює true).

Один з найпоширеніших циклів:

```c
for (new i = 0; i < MAX_PLAYERS; i++)
{
    printf("%d", i);
}
```

Ініціалізація у цьому циклі така:

```c
new i = 0;
```

Крапка з комою позначає кінець ініціалізації. Тут оголошується нова змінна з ім'ям i, яка може бути використана тільки у цьому циклі. Далі виконується наступне порівняння. Порівнюється i з MAX_PLAYERS (за замовчуванням 500 - див. #define), і якщо воно менше, то продовжується. Потім виконується вміст циклу. Спочатку буде виведено "0". Нарешті виконується оновлення "i++", що збільшує значення i. Тепер виконується повна ітерація, цикл зациклюється, як випливає з його назви, і повертається до етапу порівняння (ініціалізація виконується лише один раз за виклик).

Результатом роботи цього циклу є виведення всіх чисел від 0 до 499 включно. Еквівалентом циклу while (ігноруючи вплив continue) буде наступний:

```c
новий
    i = 0;
while (i < MAX_PLAYERS)
{
    printf("%d", i);
    i++;
}
```

Ці три етапи можна зробити набагато складнішими, якщо потрібно, використовуючи коми для першого та останнього розділів і стандартні порівняння для середнього розділу:

```c
for (new i = 0, j = 200; i < MAX_PLAYERS && j > 10; i++, j -= 2)
{
    printf("%d %d", i, j);
}
```

Це створить дві нові змінні і встановить їх у значення 0 і 200, а потім зациклить, поки одна з них буде меншою за 200, а інша - більшою за 10, щоразу збільшуючи одну з них і зменшуючи іншу на два значення щоразу.

Як зазначалося раніше, область видимості змінних зазвичай обмежується циклом:

```c
for (new i = 0; i < MAX_PLAYERS; i++)
{
    printf("%d", i);
}
printf("%d", i);
```

Це призведе до помилки, оскільки "i" не існує після завершення циклу. Однак:

```c
новий
    i = 0;
for ( ; i < MAX_PLAYERS; i++)
{
    printf("%d", i);
}
printf("%d", i);
```

Добре, оскільки "i" не оголошено у циклі. Ви також можете ініціалізувати "i" у циклі, але не оголошувати його там:

```c
новий
    i;
for (i = 0; i < MAX_PLAYERS; i++)
{
    printf("%d", i);
}
printf("%d", i);
```

## "Вперед".

goto та мітки зазвичай не рекомендуються у спільноті програмістів, оскільки те, що вони роблять, зазвичай можна зробити краще, реструктуризувавши код належним чином. Однак, по суті, goto - це стрибок:

```c
goto my_label;
printf("Це ніколи не буде надруковано");
my_label:
printf("Це буде надруковано");
```

Однак компілятор не дуже добре обробляє goto, тому його не буде оптимізовано взагалі і тому подібне:

```c
{
    new
        i = 5;
    if (i == 5)
    {
        goto my_label;
    }
    else
    {
        my_label:
        return 0;
    }
}
```

Видаватиме попередження про неузгоджені типи повернення, оскільки вважає, що істинна гілка нічого не повертає, хоча насправді повертає, але у дуже обхідний спосіб. І ще:

```c
MyFunction()
{
    новий
        i = 5;
    if (i == 5)
    {
        goto my_label;
    }
    return 0;
    my_label:
    return 1;
}
```

Видасть попередження про недоступність коду, незважаючи на те, що він насправді доступний.

Основний синтаксис такий:

```c
етикетка:

"Go to label.
```

Мітка повинна знаходитися в окремому рядку і закінчуватися двокрапкою, а не крапкою з комою. На мітки поширюються ті самі обмеження щодо іменування, що й на змінні, функції тощо.

## "Якщо

If - один з найважливіших операторів. Він визначає, потрібно щось робити чи ні, і діє відповідно, він, разом з goto, є основою майже всіх інших керуючих структур:

```c
for (new i = 0; i < 10; i++)
{
}
```

еквівалентно:

```c
новий
    i = 0;
for_loop:
if (i < 10)
{
    i++;
    goto for_loop;
}
```

Умов, які можна прийняти, занадто багато для цієї посади, але деякі з них перераховані нижче:

Пояснення оператора Приклад Результат при a=1, b=0 Результат при a=1, b=1 Результат при a=0, b=1 Результат при a=0, b=0 == Перевіряє, чи дорівнює один предмет іншому if (a == b) false true false true != Перевіряє, чи не дорівнює один предмет іншому if (a != b) true false false false false < Перевіряє, чи один предмет менше іншого if (a < b) false false false false > Перевіряє, чи один предмет більше іншого if (a > b) true false false false false <= Перевіряє, чи один предмет менше або дорівнює іншому if (a <= b) false true true true >= Перевіряє, чи одне більше або дорівнює іншому if (a >= b) true true true true true && Перевіряє, чи дві речі істинні (не 0) if (a && b) false true false false false || Перевіряє, чи хоча б одна з двох речей істинна (не 0) if (a || b) true true true true false ! Перевіряє, чи є щось хибним if (!(a == b)) true false false false false

Очевидно, що за допомогою них ви можете створювати складні умови:

```c
if (a == b && (c != d || f < g))
```

Це буде вірно, якщо a дорівнює b і або f менше g, або c не дорівнює d (або і те, і інше).

## "Повернись

Це розриває функцію і може повернути дані у функцію, що її викликає:

```c
MyFunction()
{
    новий
        someVar = OtherFunction();
}

OtherFunction()
{
    return 5;
}
```

someVar тепер буде 5.

```c
MyFunction()
{
    if (SomeFunction())
    {
        printf("Повернуто 1");
    }
}

SomeFunction()
{
    return random(2);
}
```

Це поверне або 1, або 0 в інструкцію if функції, що викликає функцію. 1 означає true, а 0 - false, тому текст буде надруковано лише у випадку повернення 1. Однак:

```c
MyFunction()
{
    if (SomeFunction())
    {
        printf("Повернуто щось від 1 до 10");
    }
}

SomeFunction()
{
    return random(11);
}
```

Вона поверне 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 або 10. Все, що не дорівнює 0, є істиною, тому текст буде показано, якщо буде повернуто щось від 1 до 10.

Ви також можете використовувати return з рядками:

```c
MyFunction()
{
    printf("%s", SomeFunction());
}

SomeFunction()
{
    новий
        str[10] = "Hello";
    return str;
}
```

Виведе "Hello" (без лапок).

Вам також не потрібно нічого повертати:

```c
MyFunction()
{
    SomeFunction();
}

SomeFunction()
{
    return;
}
```

Однак, якщо ви робите це, ви повинні переконатися, що повернення функції ніколи не використовується:

```c
MyFunction()
{
    if (SomeFunction())
    {
        printf("Проблема");
    }
}

SomeFunction()
{
    return;
}
```

Тут SomeFunction нічого не повертає, проте MyFunction перевіряє, чи значення, повернуте з SomeFunction, істинне чи ні - воно не істинне, оскільки його просто не існує, тому ви отримаєте помилку компілятора. За замовчуванням значення не повертається, тому

```c
SomeFunction()
{
    return;
}
```

І:

```c
SomeFunction()
{
}
```

однакові.

Нарешті, ви не можете змішувати значення, що повертаються:

```c
MyFunction()
{
    SomeFunction();
}

SomeFunction()
{
    if (random(2))
    {
        return 1;
    }
    else
    {
        return;
    }
}
```

Це призведе до помилки, тому що він не знає, що робити.

```c
SomeFunction()
{
    if (random(2))
    {
        return 1;
    }
}
```

Також не допускається, оскільки за замовчуванням повертається ніщо.

## спати.

sleep - це psudo-функція, яка призупиняє виконання на задану кількість мілісекунд:

```c
printf("Час 0s");
sleep(1000);
printf("Час 1с");
```

Це працює лише у main(), але не у зворотному виклику, оскільки він виконується у потоці PAWN.

## "Держава".

state є частиною машини станів PAWN та автономної системи, див. [цю гілку](https://forum.sa-mp.com/showthread.php?t=86850) для отримання додаткової інформації.

## "Перемикач

switch - це, по суті, структурована система if/else, якщо/інакше if/else:

```c
switch (someVar)
{
    case 1
    {
        printf("one");
    }
    case 2:
    {
        printf("two");
    }
    case 3
    {
        printf("three");
    }
    default:
    {
        printf("other");
    }
}
```

Це просто трохи ефективніший (і набагато чистіший) спосіб роботи:

```c
if (someVar == 1)
{
    printf("one");
}
else if (someVar == 2)
{
    printf("two");
}
else if (someVar == 3)
{
    printf("три");
}
else
{
    printf("інше");
}
```

## "поки

while - це тип циклу, подібний до for та do..while. Основною операцією є оператор if done, який, якщо він істинний, виконує деякий код і переходить назад до if. Якщо він хибний, він переходить до коду після циклу - більше нічого не виконується. Повернемося до прикладу з goto:

```c
новий
    i = 0;
for_loop:
if (i < 10)
{
    i++;
    goto for_loop;
}
```

Це також можна записати як:

```c
новий
    i = 0;
while (i < 10)
{
    i++;
}
```

Дивіться тут і тут для отримання додаткової інформації.


